!(function (e, t) {
  "object" == typeof exports && "object" == typeof module
    ? (module.exports = t(
        require("@babylonjs/core/Shaders/outline.fragment"),
        require("@babylonjs/core/Shaders/outline.vertex"),
        require("@babylonjs/core/Buffers/buffer"),
        require("@babylonjs/core/Engines/constants"),
        require("@babylonjs/core/Materials/clipPlaneMaterialHelper"),
        require("@babylonjs/core/Materials/drawWrapper"),
        require("@babylonjs/core/Materials/effectFallbacks"),
        require("@babylonjs/core/Materials/materialHelper"),
        require("@babylonjs/core/scene"),
        require("@babylonjs/core/sceneComponent"),
        require("@babylonjs/core/Materials/shaderLanguage"),
        require("@babylonjs/core/Loading/sceneLoader"),
        require("@babylonjs/core/Meshes/geometry"),
        require("@babylonjs/core/Meshes/mesh"),
        require("@babylonjs/core/Meshes/mesh.vertexData"),
        require("@babylonjs/core/Misc/tools"),
        require("@babylonjs/core/Morph/morphTarget"),
        require("@babylonjs/core/Morph/morphTargetManager"),
        require("@babylonjs/core/assetContainer"),
        require("@babylonjs/core/Bones/bone"),
        require("@babylonjs/core/Bones/skeleton"),
        require("@babylonjs/core/Culling/boundingInfo"),
        require("@babylonjs/core/Maths/math.vector"),
        require("@babylonjs/core/Misc/logger"),
        require("@babylonjs/core/Materials/material"),
        require("@babylonjs/core/Maths/math.color"),
        require("@babylonjs/core/Materials/Textures/texture"),
        require("@babylonjs/core/Misc/observable"),
        require("@babylonjs/core/Misc/timingTools"),
        require("@babylonjs/core/Materials/standardMaterial"),
        require("@babylonjs/core/Materials/materialDefines"),
        require("@babylonjs/core/Materials/materialPluginBase"),
        require("@babylonjs/core/Materials/shaderMaterial"),
        require("@babylonjs/core/Materials/Textures/renderTargetTexture"),
        require("@babylonjs/core/Misc/fileTools"),
        require("@babylonjs/core/Animations/animation"),
        require("@babylonjs/core/Animations/animationGroup"),
        require("@babylonjs/core/Animations/animationKey"),
        require("@babylonjs/core/Maths/math.axis"),
        require("@babylonjs/core/Cameras/camera"),
        require("@babylonjs/core/Physics/v2/physicsEngineComponent"),
        require("@babylonjs/core/Meshes/transformNode"),
        require("@babylonjs/core/Physics/v2/IPhysicsEnginePlugin"),
        require("@babylonjs/core/Physics/v2/physicsBody"),
        require("@babylonjs/core/Physics/v2/physicsConstraint"),
        require("@babylonjs/core/Physics/v2/physicsShape")
      ))
    : "function" == typeof define && define.amd
    ? define(
        "babylon-mmd",
        [
          "@babylonjs/core/Shaders/outline.fragment",
          "@babylonjs/core/Shaders/outline.vertex",
          "@babylonjs/core/Buffers/buffer",
          "@babylonjs/core/Engines/constants",
          "@babylonjs/core/Materials/clipPlaneMaterialHelper",
          "@babylonjs/core/Materials/drawWrapper",
          "@babylonjs/core/Materials/effectFallbacks",
          "@babylonjs/core/Materials/materialHelper",
          "@babylonjs/core/scene",
          "@babylonjs/core/sceneComponent",
          "@babylonjs/core/Materials/shaderLanguage",
          "@babylonjs/core/Loading/sceneLoader",
          "@babylonjs/core/Meshes/geometry",
          "@babylonjs/core/Meshes/mesh",
          "@babylonjs/core/Meshes/mesh.vertexData",
          "@babylonjs/core/Misc/tools",
          "@babylonjs/core/Morph/morphTarget",
          "@babylonjs/core/Morph/morphTargetManager",
          "@babylonjs/core/assetContainer",
          "@babylonjs/core/Bones/bone",
          "@babylonjs/core/Bones/skeleton",
          "@babylonjs/core/Culling/boundingInfo",
          "@babylonjs/core/Maths/math.vector",
          "@babylonjs/core/Misc/logger",
          "@babylonjs/core/Materials/material",
          "@babylonjs/core/Maths/math.color",
          "@babylonjs/core/Materials/Textures/texture",
          "@babylonjs/core/Misc/observable",
          "@babylonjs/core/Misc/timingTools",
          "@babylonjs/core/Materials/standardMaterial",
          "@babylonjs/core/Materials/materialDefines",
          "@babylonjs/core/Materials/materialPluginBase",
          "@babylonjs/core/Materials/shaderMaterial",
          "@babylonjs/core/Materials/Textures/renderTargetTexture",
          "@babylonjs/core/Misc/fileTools",
          "@babylonjs/core/Animations/animation",
          "@babylonjs/core/Animations/animationGroup",
          "@babylonjs/core/Animations/animationKey",
          "@babylonjs/core/Maths/math.axis",
          "@babylonjs/core/Cameras/camera",
          "@babylonjs/core/Physics/v2/physicsEngineComponent",
          "@babylonjs/core/Meshes/transformNode",
          "@babylonjs/core/Physics/v2/IPhysicsEnginePlugin",
          "@babylonjs/core/Physics/v2/physicsBody",
          "@babylonjs/core/Physics/v2/physicsConstraint",
          "@babylonjs/core/Physics/v2/physicsShape",
        ],
        t
      )
    : "object" == typeof exports
    ? (exports["babylon-mmd"] = t(
        require("@babylonjs/core/Shaders/outline.fragment"),
        require("@babylonjs/core/Shaders/outline.vertex"),
        require("@babylonjs/core/Buffers/buffer"),
        require("@babylonjs/core/Engines/constants"),
        require("@babylonjs/core/Materials/clipPlaneMaterialHelper"),
        require("@babylonjs/core/Materials/drawWrapper"),
        require("@babylonjs/core/Materials/effectFallbacks"),
        require("@babylonjs/core/Materials/materialHelper"),
        require("@babylonjs/core/scene"),
        require("@babylonjs/core/sceneComponent"),
        require("@babylonjs/core/Materials/shaderLanguage"),
        require("@babylonjs/core/Loading/sceneLoader"),
        require("@babylonjs/core/Meshes/geometry"),
        require("@babylonjs/core/Meshes/mesh"),
        require("@babylonjs/core/Meshes/mesh.vertexData"),
        require("@babylonjs/core/Misc/tools"),
        require("@babylonjs/core/Morph/morphTarget"),
        require("@babylonjs/core/Morph/morphTargetManager"),
        require("@babylonjs/core/assetContainer"),
        require("@babylonjs/core/Bones/bone"),
        require("@babylonjs/core/Bones/skeleton"),
        require("@babylonjs/core/Culling/boundingInfo"),
        require("@babylonjs/core/Maths/math.vector"),
        require("@babylonjs/core/Misc/logger"),
        require("@babylonjs/core/Materials/material"),
        require("@babylonjs/core/Maths/math.color"),
        require("@babylonjs/core/Materials/Textures/texture"),
        require("@babylonjs/core/Misc/observable"),
        require("@babylonjs/core/Misc/timingTools"),
        require("@babylonjs/core/Materials/standardMaterial"),
        require("@babylonjs/core/Materials/materialDefines"),
        require("@babylonjs/core/Materials/materialPluginBase"),
        require("@babylonjs/core/Materials/shaderMaterial"),
        require("@babylonjs/core/Materials/Textures/renderTargetTexture"),
        require("@babylonjs/core/Misc/fileTools"),
        require("@babylonjs/core/Animations/animation"),
        require("@babylonjs/core/Animations/animationGroup"),
        require("@babylonjs/core/Animations/animationKey"),
        require("@babylonjs/core/Maths/math.axis"),
        require("@babylonjs/core/Cameras/camera"),
        require("@babylonjs/core/Physics/v2/physicsEngineComponent"),
        require("@babylonjs/core/Meshes/transformNode"),
        require("@babylonjs/core/Physics/v2/IPhysicsEnginePlugin"),
        require("@babylonjs/core/Physics/v2/physicsBody"),
        require("@babylonjs/core/Physics/v2/physicsConstraint"),
        require("@babylonjs/core/Physics/v2/physicsShape")
      ))
    : (e.BABYLONMMD = t(
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON,
        e.BABYLON
      ));
})(
  "undefined" != typeof self ? self : "undefined" != typeof global ? global : this,
  (
    e,
    t,
    n,
    i,
    o,
    r,
    a,
    s,
    l,
    h,
    d,
    c,
    m,
    u,
    p,
    g,
    f,
    _,
    b,
    y,
    A,
    M,
    T,
    w,
    x,
    I,
    v,
    B,
    P,
    O,
    F,
    R,
    S,
    C,
    E,
    k,
    N,
    D,
    L,
    U,
    V,
    W,
    z,
    K,
    j,
    Y
  ) =>
    (() => {
      "use strict";
      var Q = {
          858: (e, t, n) => {
            e.exports = n.p + "f0260041efc5b0664bd8.wasm";
          },
          2524: (e, t, n) => {
            e.exports = n.p + "fccd3bd4917dc26791b1.wasm";
          },
          7236: (e, t, n) => {
            e.exports = n.p + "58c2510eab7462decfb0.wasm";
          },
          8754: (e, t, n) => {
            e.exports = n.p + "4a48a0499c264010fdec.wasm";
          },
          4268: (e) => {
            e.exports = k;
          },
          1259: (e) => {
            e.exports = N;
          },
          6871: (e) => {
            e.exports = D;
          },
          6320: (e) => {
            e.exports = y;
          },
          6429: (e) => {
            e.exports = A;
          },
          3376: (e) => {
            e.exports = n;
          },
          1068: (e) => {
            e.exports = U;
          },
          8619: (e) => {
            e.exports = M;
          },
          3843: (e) => {
            e.exports = i;
          },
          6532: (e) => {
            e.exports = c;
          },
          5918: (e) => {
            e.exports = C;
          },
          5197: (e) => {
            e.exports = v;
          },
          3272: (e) => {
            e.exports = o;
          },
          1308: (e) => {
            e.exports = r;
          },
          9127: (e) => {
            e.exports = a;
          },
          1860: (e) => {
            e.exports = x;
          },
          9430: (e) => {
            e.exports = F;
          },
          6604: (e) => {
            e.exports = s;
          },
          9190: (e) => {
            e.exports = R;
          },
          9866: (e) => {
            e.exports = d;
          },
          6837: (e) => {
            e.exports = S;
          },
          4229: (e) => {
            e.exports = O;
          },
          4619: (e) => {
            e.exports = L;
          },
          5501: (e) => {
            e.exports = I;
          },
          6377: (e) => {
            e.exports = T;
          },
          3898: (e) => {
            e.exports = m;
          },
          3929: (e) => {
            e.exports = u;
          },
          6867: (e) => {
            e.exports = p;
          },
          4044: (e) => {
            e.exports = W;
          },
          4232: (e) => {
            e.exports = E;
          },
          4751: (e) => {
            e.exports = w;
          },
          7508: (e) => {
            e.exports = B;
          },
          7116: (e) => {
            e.exports = P;
          },
          7466: (e) => {
            e.exports = g;
          },
          8698: (e) => {
            e.exports = f;
          },
          1755: (e) => {
            e.exports = _;
          },
          6970: (e) => {
            e.exports = z;
          },
          3466: (e) => {
            e.exports = K;
          },
          3301: (e) => {
            e.exports = j;
          },
          6247: (e) => {
            e.exports = V;
          },
          5755: (e) => {
            e.exports = Y;
          },
          7185: (t) => {
            t.exports = e;
          },
          3263: (e) => {
            e.exports = t;
          },
          9125: (e) => {
            e.exports = b;
          },
          7396: (e) => {
            e.exports = l;
          },
          2929: (e) => {
            e.exports = h;
          },
        },
        q = {};
      function H(e) {
        var t = q[e];
        if (void 0 !== t) return t.exports;
        var n = (q[e] = { exports: {} });
        return Q[e](n, n.exports, H), n.exports;
      }
      (H.m = Q),
        (H.d = (e, t) => {
          for (var n in t) H.o(t, n) && !H.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: t[n] });
        }),
        (H.u = (e) => e + ".babylon.mmd.min.js"),
        (H.g = (function () {
          if ("object" == typeof globalThis) return globalThis;
          try {
            return this || new Function("return this")();
          } catch (e) {
            if ("object" == typeof window) return window;
          }
        })()),
        (H.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)),
        (H.r = (e) => {
          "undefined" != typeof Symbol &&
            Symbol.toStringTag &&
            Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }),
            Object.defineProperty(e, "__esModule", { value: !0 });
        }),
        (() => {
          var e;
          H.g.importScripts && (e = H.g.location + "");
          var t = H.g.document;
          if (!e && t && (t.currentScript && (e = t.currentScript.src), !e)) {
            var n = t.getElementsByTagName("script");
            if (n.length) for (var i = n.length - 1; i > -1 && (!e || !/^http(s?):/.test(e)); ) e = n[i--].src;
          }
          if (!e) throw new Error("Automatic publicPath is not supported in this browser");
          (e = e
            .replace(/#.*$/, "")
            .replace(/\?.*$/, "")
            .replace(/\/[^\/]+$/, "/")),
            (H.p = e);
        })(),
        (H.b = document.baseURI || self.location.href);
      var G = {};
      return (
        (() => {
          H.r(G),
            H.d(G, {
              AnimationRetargeter: () => vt,
              BpmxConverter: () => bt,
              BpmxLoader: () => Ae,
              BpmxObject: () => oe,
              BpmxReader: () => ye,
              BvmdConverter: () => yt,
              BvmdLoader: () => At,
              ConsoleLogger: () => M,
              DisplayTimeFormat: () => Zi,
              HumanoidMmd: () => so,
              MixamoMmdHumanoidBoneMap: () => Bt,
              MmdAnimation: () => pt,
              MmdAnimationBase: () => Be,
              MmdAnimationSpan: () => Me,
              MmdAnimationTrack: () => Ze,
              MmdAsyncTextureLoader: () => Q,
              MmdBoneAnimationTrack: () => et,
              MmdCamera: () => co,
              MmdCameraAnimationGroup: () => Ne,
              MmdCameraAnimationGroupBezierBuilder: () => Ue,
              MmdCameraAnimationGroupHermiteBuilder: () => De,
              MmdCameraAnimationGroupSampleBuilder: () => Le,
              MmdCameraAnimationTrack: () => it,
              MmdCompositeAnimation: () => Te,
              MmdCompositeRuntimeCameraAnimation: () => we,
              MmdCompositeRuntimeModelAnimation: () => ve,
              MmdHumanoidMapper: () => Ot,
              MmdMesh: () => gt,
              MmdModel: () => _o,
              MmdModelAnimationGroup: () => qe,
              MmdModelAnimationGroupBezierBuilder: () => Xe,
              MmdModelAnimationGroupHermiteBuilder: () => Ge,
              MmdModelAnimationGroupSampleBuilder: () => $e,
              MmdModelMetadata: () => ft,
              MmdMorphAnimationTrack: () => nt,
              MmdMorphController: () => go,
              MmdMorphControllerBase: () => qi,
              MmdPhysics: () => Io,
              MmdPhysicsModel: () => xo,
              MmdPlayerControl: () => lo,
              MmdPropertyAnimationTrack: () => ot,
              MmdRuntime: () => vo,
              MmdRuntimeAnimation: () => Oe,
              MmdRuntimeCameraAnimation: () => Fe,
              MmdRuntimeCameraAnimationGroup: () => We,
              MmdRuntimeModelAnimation: () => Ke,
              MmdRuntimeModelAnimationGroup: () => Je,
              MmdStandardMaterial: () => te,
              MmdStandardMaterialBuilder: () => le,
              MmdStandardMaterialProxy: () => Gi,
              MmdWasmAnimation: () => ct,
              MmdWasmAnimationTrack: () => at,
              MmdWasmBoneAnimationTrack: () => st,
              MmdWasmInstanceTypeMD: () => yn,
              MmdWasmInstanceTypeMR: () => $n,
              MmdWasmInstanceTypeSD: () => Ii,
              MmdWasmInstanceTypeSR: () => zi,
              MmdWasmModel: () => oo,
              MmdWasmMorphAnimationTrack: () => ht,
              MmdWasmMorphController: () => Hi,
              MmdWasmMovableBoneAnimationTrack: () => lt,
              MmdWasmPropertyAnimationTrack: () => dt,
              MmdWasmRuntime: () => eo,
              MmdWasmRuntimeAnimationEvaluationType: () => Ji,
              MmdWasmRuntimeBone: () => io,
              MmdWasmRuntimeModelAnimation: () => mt,
              PmdLoader: () => pe,
              PmdReader: () => w,
              PmxLoader: () => _e,
              PmxObject: () => y,
              PmxReader: () => fe,
              ReferenceFileResolver: () => ne,
              SdefInjector: () => f,
              SharedToonTextures: () => W,
              StreamAudioPlayer: () => St,
              TextureAlphaChecker: () => se,
              TransparencyMode: () => ie,
              VmdData: () => Mt,
              VmdLoader: () => Ft,
              VmdObject: () => Tt,
              VpdLoader: () => Rt,
              VpdReader: () => wt,
              VrmMmdHumanoidBoneMap: () => Pt,
              getMmdWasmInstance: () => Qi,
            });
          var e = {};
          H.r(e),
            H.d(e, {
              AnimationPool: () => ln,
              MmdRuntime: () => dn,
              createAnimationPool: () => $t,
              createMmdRuntime: () => Gt,
              default: () => bn,
              init: () => Ht,
              initSync: () => fn,
              initThreadPool: () => rn,
              wbg_rayon_PoolBuilder: () => mn,
              wbg_rayon_start_worker: () => an,
            });
          var t = {};
          H.r(t),
            H.d(t, {
              AnimationPool: () => Un,
              MmdRuntime: () => Wn,
              createAnimationPool: () => En,
              createMmdRuntime: () => Cn,
              default: () => Gn,
              init: () => Sn,
              initSync: () => qn,
              initThreadPool: () => Nn,
              wbg_rayon_PoolBuilder: () => Kn,
              wbg_rayon_start_worker: () => Dn,
            });
          var n = {};
          H.r(n),
            H.d(n, {
              AnimationPool: () => _i,
              MmdRuntime: () => yi,
              createAnimationPool: () => si,
              createMmdRuntime: () => ai,
              default: () => xi,
              init: () => ri,
              initSync: () => Ti,
            });
          var i = {};
          H.r(i),
            H.d(i, {
              AnimationPool: () => Ei,
              MmdRuntime: () => Ni,
              createAnimationPool: () => Si,
              createMmdRuntime: () => Ri,
              default: () => Wi,
              init: () => Fi,
              initSync: () => Ui,
            }),
            H(7185),
            H(3263);
          var o = H(3376),
            r = H(3843),
            a = H(3272),
            s = H(1308),
            l = H(9127),
            h = H(6604),
            d = H(7396),
            c = H(2929);
          class m {
            static AdditionalUV1Kind = "additionalUv1";
            static AdditionalUV2Kind = "additionalUv2";
            static AdditionalUV3Kind = "additionalUv3";
            static AdditionalUV4Kind = "additionalUv4";
            static MatricesSdefCKind = "matricesSdefC";
            static MatricesSdefR0Kind = "matricesSdefR0";
            static MatricesSdefR1Kind = "matricesSdefR1";
            static EdgeScaleKind = "edgeScale";
          }
          var u = H(9866);
          const p =
              "\n#ifndef SDEFDECLARATION\n#define SDEFDECLARATION\n#if NUM_BONE_INFLUENCERS>0 && defined(SDEF)\nattribute vec3 matricesSdefC;attribute vec3 matricesSdefR0;attribute vec3 matricesSdefR1;vec4 rotationMatrixToQuaternion(mat3 matrix) {float trace=matrix[0][0]+matrix[1][1]+matrix[2][2];float s;float sqrtParam;if (trace>0.0) {sqrtParam=trace+1.0;} else if (matrix[0][0]>matrix[1][1] && matrix[0][0]>matrix[2][2]) {sqrtParam=1.0+matrix[0][0]-matrix[1][1]-matrix[2][2];} else if (matrix[1][1]>matrix[2][2]) {sqrtParam=1.0+matrix[1][1]-matrix[0][0]-matrix[2][2];} else {sqrtParam=1.0+matrix[2][2]-matrix[0][0]-matrix[1][1];}\nfloat sqrtValue=sqrt(sqrtParam);if (trace>0.0) {s=0.5/sqrtValue;return vec4(\n(matrix[1][2]-matrix[2][1])*s,\n(matrix[2][0]-matrix[0][2])*s,\n(matrix[0][1]-matrix[1][0])*s,\n0.25/s\n);} else if (matrix[0][0]>matrix[1][1] && matrix[0][0]>matrix[2][2]) {s=2.0*sqrtValue;return vec4(\n0.25*s,\n(matrix[0][1]+matrix[1][0])/s,\n(matrix[2][0]+matrix[0][2])/s,\n(matrix[1][2]-matrix[2][1])/s\n);} else if (matrix[1][1]>matrix[2][2]) {s=2.0*sqrtValue;return vec4(\n(matrix[0][1]+matrix[1][0])/s,\n0.25*s,\n(matrix[1][2]+matrix[2][1])/s,\n(matrix[2][0]-matrix[0][2])/s\n);} else {s=2.0*sqrtValue;return vec4(\n(matrix[2][0]+matrix[0][2])/s,\n(matrix[1][2]+matrix[2][1])/s,\n0.25*s,\n(matrix[0][1]-matrix[1][0])/s\n);}}\nmat3 quaternionToRotationMatrix(vec4 q) {float xx=q.x*q.x;float yy=q.y*q.y;float zz=q.z*q.z;float xy=q.x*q.y;float zw=q.z*q.w;float zx=q.z*q.x;float yw=q.y*q.w;float yz=q.y*q.z;float xw=q.x*q.w;return mat3(\n1.0-2.0*(yy+zz),2.0*(xy+zw),2.0*(zx-yw),\n2.0*(xy-zw),1.0-2.0*(zz+xx),2.0*(yz+xw),\n2.0*(zx+yw),2.0*(yz-xw),1.0-2.0*(yy+xx)\n);}\nvec4 slerp(vec4 q0,vec4 q1,float t) {float cosTheta=dot(q0,q1);q1=mix(-q1,q1,step(0.0,cosTheta));cosTheta=abs(cosTheta);if (cosTheta>0.999999) {return normalize(mix(q0,q1,t));}\nfloat theta=acos(cosTheta);float sinTheta=sin(theta);float w0=sin((1.0-t)*theta)/sinTheta;float w1=sin(t*theta)/sinTheta;return q0*w0+q1*w1;}\n#endif\n#endif\n",
            g =
              "\n#ifndef SDEFVERTEX\n#define SDEFVERTEX\n#if !defined(BAKED_VERTEX_ANIMATION_TEXTURE) && defined(SDEF)\n#if NUM_BONE_INFLUENCERS>0\n{float weight0=matricesWeights[0];float weight1=matricesWeights[1];\n#ifdef BONETEXTURE\nmat4 transformMatrix0=readMatrixFromRawSampler(boneSampler,matricesIndices[0]);mat4 transformMatrix1=readMatrixFromRawSampler(boneSampler,matricesIndices[1]);\n#else\nmat4 transformMatrix0=mBones[int(matricesIndices[0])];mat4 transformMatrix1=mBones[int(matricesIndices[1])];\n#endif\nmat3 slerpedRotationMatrix=quaternionToRotationMatrix(slerp(\nrotationMatrixToQuaternion(mat3(transformMatrix0)),\nrotationMatrixToQuaternion(mat3(transformMatrix1)),\nweight1\n));mat4 sdefInflunce=mat4(\nvec4(1.0,0.0,0.0,0.0),\nvec4(0.0,1.0,0.0,0.0),\nvec4(0.0,0.0,1.0,0.0),\nvec4(-matricesSdefC,1.0)\n);mat4 rotationMatrix=mat4(\nvec4(slerpedRotationMatrix[0],0.0),\nvec4(slerpedRotationMatrix[1],0.0),\nvec4(slerpedRotationMatrix[2],0.0),\nvec4(0.0,0.0,0.0,1.0)\n);sdefInflunce=rotationMatrix*sdefInflunce;vec3 positionOffset =\nvec3(transformMatrix0*vec4(matricesSdefR0,1))*weight0 +\nvec3(transformMatrix1*vec4(matricesSdefR1,1))*weight1;sdefInflunce[3]+=vec4(positionOffset,0.0);float useLinearDeform=step(0.0,-abs(matricesSdefR0.x));influence=mat4(\nmix(sdefInflunce[0],influence[0],useLinearDeform),\nmix(sdefInflunce[1],influence[1],useLinearDeform),\nmix(sdefInflunce[2],influence[2],useLinearDeform),\nmix(sdefInflunce[3],influence[3],useLinearDeform)\n);}\n#endif\n#endif\n#endif\n";
          class f {
            static OverrideEngineCreateEffect(e) {
              const t = e.createEffect.bind(e);
              e.createEffect = function (e, n, i, o, r, a, s, l, h, d = u.ShaderLanguage.GLSL) {
                let c;
                if (
                  ((c = n.attributes
                    ? n
                    : {
                        attributes: n,
                        uniformsNames: i,
                        uniformBuffersNames: [],
                        samplers: o ?? [],
                        defines: r ?? "",
                        fallbacks: a ?? null,
                        onCompiled: s ?? null,
                        onError: l ?? null,
                        indexParameters: h ?? null,
                        shaderLanguage: d,
                      }),
                  (c.shaderLanguage === u.ShaderLanguage.GLSL || void 0 === c.shaderLanguage) &&
                    (c.uniformsNames.includes("mBones") || c.samplers.includes("boneSampler")) &&
                    -1 === c.defines.indexOf("#define SDEF"))
                ) {
                  c.attributes.push(m.MatricesSdefCKind),
                    c.attributes.push(m.MatricesSdefR0Kind),
                    c.attributes.push(m.MatricesSdefR1Kind),
                    (c.defines += "\n#define SDEF");
                  const e = c.processCodeAfterIncludes;
                  c.processCodeAfterIncludes = e
                    ? function (t, n) {
                        return (n = e(t, n)), f.ProcessSdefCode(t, n);
                      }
                    : f.ProcessSdefCode;
                }
                return t(e, c, this);
              };
            }
            static ProcessSdefCode(e, t) {
              if ("vertex" !== e) return t;
              const n = "#define CUSTOM_VERTEX_DEFINITIONS";
              t = t.replace(n, `${n}\n${p}`);
              const i = new RegExp("finalWorld=finalWorld\\*influence;", "g");
              return t.replace(i, `${g}\nfinalWorld=finalWorld*influence;`);
            }
          }
          d.Scene.prototype.getMmdOutlineRenderer = function () {
            return this._mmdOutlineRenderer || (this._mmdOutlineRenderer = new _(this)), this._mmdOutlineRenderer;
          };
          class _ {
            static OutlineWidthScaleFactor = 0.01;
            static _StencilReference = 4;
            name = "MmdOutline";
            scene;
            zOffset = -8;
            zOffsetUnits = 4;
            _engine;
            _savedDepthWrite;
            _passIdForDrawWrapper;
            constructor(e) {
              (this.scene = e),
                (this._engine = e.getEngine()),
                this.scene._addComponent(this),
                (this._passIdForDrawWrapper = []);
              for (let e = 0; e < 3; ++e)
                this._passIdForDrawWrapper[e] = this._engine.createRenderPassId(`Mmd Outline Renderer (${e})`);
              this._savedDepthWrite = !1;
            }
            register() {
              this.scene._beforeRenderingMeshStage.registerStep(
                c.SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE,
                this,
                this._beforeRenderingMesh
              ),
                this.scene._afterRenderingMeshStage.registerStep(
                  c.SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE,
                  this,
                  this._afterRenderingMesh
                );
            }
            rebuild() {}
            dispose() {
              for (let e = 0; e < this._passIdForDrawWrapper.length; ++e)
                this._engine.releaseRenderPassId(this._passIdForDrawWrapper[e]);
            }
            render(e, t, n, i) {
              i = i ?? this._passIdForDrawWrapper[0];
              const o = this.scene,
                r = o.getEngine(),
                l =
                  r.getCaps().instancedArrays &&
                  ((null !== t.visibleInstances[e._id] && void 0 !== t.visibleInstances[e._id]) ||
                    e.getRenderingMesh().hasThinInstances);
              if (!this.isReady(e, l, i)) return;
              const d = e.getMesh(),
                c = d._internalAbstractMeshDataInfo._actAsRegularMesh ? d : null,
                m = e.getRenderingMesh(),
                u = c || m,
                p = e.getMaterial();
              if (!p || !o.activeCamera) return;
              const g = e._getDrawWrapper(i),
                f = s.DrawWrapper.GetEffect(g);
              if (
                (r.enableEffect(g),
                p.useLogarithmicDepth &&
                  f.setFloat("logarithmicDepthConstant", 2 / (Math.log(o.activeCamera.maxZ + 1) / Math.LN2)),
                f.setFloat("offset", n ?? p.outlineWidth * _.OutlineWidthScaleFactor),
                f.setColor4("color", p.outlineColor, p.outlineAlpha),
                f.setMatrix("viewProjection", o.getTransformMatrix()),
                f.setMatrix("world", u.getWorldMatrix()),
                h.MaterialHelper.BindBonesParameters(u, f),
                m.morphTargetManager && m.morphTargetManager.isUsingTextureForTargets && m.morphTargetManager._bind(f),
                h.MaterialHelper.BindMorphTargetParameters(m, f),
                l || m._bind(e, f, p.fillMode),
                p && p.needAlphaTesting())
              ) {
                const e = p.getAlphaTestTexture();
                e && (f.setTexture("diffuseSampler", e), f.setMatrix("diffuseMatrix", e.getTextureMatrix()));
              }
              (0, a.bindClipPlane)(f, p, o),
                r.setZOffset(-this.zOffset),
                r.setZOffsetUnits(-this.zOffsetUnits),
                m._processRendering(u, e, f, p.fillMode, t, l, (e, t) => {
                  f.setMatrix("world", t);
                }),
                r.setZOffset(0),
                r.setZOffsetUnits(0);
            }
            isReady(e, t, n) {
              n = n ?? this._passIdForDrawWrapper[0];
              const i = [],
                r = [o.VertexBuffer.PositionKind, o.VertexBuffer.NormalKind],
                s = e.getMesh(),
                d = e.getMaterial();
              if (!d) return !1;
              const c = s.getScene();
              d.needAlphaTesting() &&
                (i.push("#define ALPHATEST"),
                s.isVerticesDataPresent(o.VertexBuffer.UVKind) &&
                  (r.push(o.VertexBuffer.UVKind), i.push("#define UV1")),
                s.isVerticesDataPresent(o.VertexBuffer.UV2Kind) &&
                  (r.push(o.VertexBuffer.UV2Kind), i.push("#define UV2"))),
                d.useLogarithmicDepth && i.push("#define LOGARITHMICDEPTH"),
                (0, a.prepareStringDefinesForClipPlanes)(d, c, i);
              const u = new l.EffectFallbacks();
              if (s.useBones && s.computeBonesUsingShaders && s.skeleton) {
                r.push(o.VertexBuffer.MatricesIndicesKind),
                  r.push(o.VertexBuffer.MatricesWeightsKind),
                  s.numBoneInfluencers > 4 &&
                    (r.push(o.VertexBuffer.MatricesIndicesExtraKind), r.push(o.VertexBuffer.MatricesWeightsExtraKind)),
                  s.isVerticesDataPresent(m.MatricesSdefCKind) &&
                    (r.push(m.MatricesSdefCKind),
                    r.push(m.MatricesSdefR0Kind),
                    r.push(m.MatricesSdefR1Kind),
                    i.push("#define SDEF"));
                const e = s.skeleton;
                i.push("#define NUM_BONE_INFLUENCERS " + s.numBoneInfluencers),
                  s.numBoneInfluencers > 0 && u.addCPUSkinningFallback(0, s),
                  e.isUsingTextureForMatrices
                    ? i.push("#define BONETEXTURE")
                    : i.push("#define BonesPerMesh " + (e.bones.length + 1));
              } else i.push("#define NUM_BONE_INFLUENCERS 0");
              const p = s.morphTargetManager;
              let g = 0;
              p &&
                p.numInfluencers > 0 &&
                ((g = p.numInfluencers),
                i.push("#define MORPHTARGETS"),
                i.push("#define NUM_MORPH_INFLUENCERS " + g),
                p.isUsingTextureForTargets && i.push("#define MORPHTARGETS_TEXTURE"),
                h.MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(r, s, g)),
                t &&
                  (i.push("#define INSTANCES"),
                  h.MaterialHelper.PushAttributesForInstances(r),
                  e.getRenderingMesh().hasThinInstances && i.push("#define THIN_INSTANCES"));
              const _ = e._getDrawWrapper(n, !0),
                b = _.defines,
                y = i.join("\n");
              if (b !== y) {
                const e = [
                    "world",
                    "mBones",
                    "viewProjection",
                    "diffuseMatrix",
                    "offset",
                    "color",
                    "logarithmicDepthConstant",
                    "morphTargetInfluences",
                    "boneTextureWidth",
                    "morphTargetTextureInfo",
                    "morphTargetTextureIndices",
                  ],
                  t = ["diffuseSampler", "boneSampler", "morphTargets"];
                (0, a.addClipPlaneUniforms)(e),
                  _.setEffect(
                    this.scene
                      .getEngine()
                      .createEffect(
                        "outline",
                        {
                          attributes: r,
                          uniformsNames: e,
                          samplers: t,
                          defines: y,
                          indexParameters: { maxSimultaneousMorphTargets: g },
                          processCodeAfterIncludes: f.ProcessSdefCode,
                        },
                        this.scene.getEngine()
                      ),
                    y
                  );
              }
              return _.effect.isReady();
            }
            _beforeRenderingMesh(e, t, n) {
              this._savedDepthWrite = this._engine.getDepthWrite();
              const i = t.getMaterial();
              if (i && i.renderOutline) {
                i.needAlphaBlendingForMesh(e) &&
                  (this._engine.cacheStencilState(),
                  this._engine.setDepthWrite(!1),
                  this._engine.setColorWrite(!1),
                  this._engine.setStencilBuffer(!0),
                  this._engine.setStencilOperationPass(r.Constants.REPLACE),
                  this._engine.setStencilFunction(r.Constants.ALWAYS),
                  this._engine.setStencilMask(_._StencilReference),
                  this._engine.setStencilFunctionReference(_._StencilReference),
                  (this._engine.stencilStateComposer.useStencilGlobalOnly = !0),
                  this.render(t, n, 0, this._passIdForDrawWrapper[1]),
                  this._engine.setColorWrite(!0),
                  this._engine.setStencilFunction(r.Constants.NOTEQUAL)),
                  this._engine.setDepthWrite(!1);
                const o = this._engine.getAlphaMode(),
                  a = this._engine.alphaState.alphaBlend;
                this._engine.setAlphaMode(r.Constants.ALPHA_COMBINE),
                  this.render(t, n, void 0, this._passIdForDrawWrapper[0]),
                  this._engine.setAlphaMode(o),
                  this._engine.setDepthWrite(this._savedDepthWrite),
                  (this._engine.alphaState.alphaBlend = a),
                  i.needAlphaBlendingForMesh(e) &&
                    ((this._engine.stencilStateComposer.useStencilGlobalOnly = !1), this._engine.restoreStencilState());
              }
            }
            _afterRenderingMesh(e, t, n) {
              const i = t.getMaterial();
              null !== i &&
                i.renderOutline &&
                this._savedDepthWrite &&
                (this._engine.setDepthWrite(!0),
                this._engine.setColorWrite(!1),
                this.render(t, n, void 0, this._passIdForDrawWrapper[2]),
                this._engine.setColorWrite(!0));
            }
          }
          var b,
            y,
            A = H(6532);
          class M {
            log(e) {
              console.log(e);
            }
            warn(e) {
              console.warn(e);
            }
            error(e) {
              console.error(e);
            }
          }
          class T {
            isDeviceLittleEndian;
            _dataView;
            _decoder;
            _offset;
            constructor(e) {
              (this.isDeviceLittleEndian = this._getIsDeviceLittleEndian()),
                (this._dataView = new DataView(e)),
                (this._decoder = null),
                (this._offset = 0);
            }
            get offset() {
              return this._offset;
            }
            set offset(e) {
              this._offset = e;
            }
            _getIsDeviceLittleEndian() {
              const e = new Int16Array([256]);
              return 1 === new Int8Array(e.buffer)[1];
            }
            swap16Array(e) {
              for (let t = 0; t < e.length; ++t) {
                const n = e[t];
                e[t] = ((255 & n) << 8) | ((n >> 8) & 255);
              }
            }
            swap32Array(e) {
              for (let t = 0; t < e.length; ++t) {
                const n = e[t];
                e[t] = ((255 & n) << 24) | ((65280 & n) << 8) | ((n >> 8) & 65280) | ((n >> 24) & 255);
              }
            }
            getUint8() {
              const e = this._dataView.getUint8(this._offset);
              return (this._offset += 1), e;
            }
            getInt8() {
              const e = this._dataView.getInt8(this._offset);
              return (this._offset += 1), e;
            }
            getUint8Array(e) {
              const t = new Uint8Array(this._dataView.buffer, this._offset, e.byteLength);
              e.set(t), (this._offset += e.byteLength);
            }
            getUint16() {
              const e = this._dataView.getUint16(this._offset, !0);
              return (this._offset += 2), e;
            }
            getUint16Array(e) {
              const t = new Uint8Array(this._dataView.buffer, this._offset, e.byteLength);
              new Uint8Array(e.buffer, e.byteOffset, e.byteLength).set(t),
                (this._offset += e.byteLength),
                this.isDeviceLittleEndian || this.swap16Array(e);
            }
            getInt16() {
              const e = this._dataView.getInt16(this._offset, !0);
              return (this._offset += 2), e;
            }
            getUint32() {
              const e = this._dataView.getUint32(this._offset, !0);
              return (this._offset += 4), e;
            }
            getUint32Array(e) {
              const t = new Uint8Array(this._dataView.buffer, this._offset, e.byteLength);
              new Uint8Array(e.buffer, e.byteOffset, e.byteLength).set(t),
                (this._offset += e.byteLength),
                this.isDeviceLittleEndian || this.swap32Array(e);
            }
            getInt32() {
              const e = this._dataView.getInt32(this._offset, !0);
              return (this._offset += 4), e;
            }
            getInt32Array(e) {
              const t = new Uint8Array(this._dataView.buffer, this._offset, e.byteLength);
              new Uint8Array(e.buffer, e.byteOffset, e.byteLength).set(t),
                (this._offset += e.byteLength),
                this.isDeviceLittleEndian || this.swap32Array(e);
            }
            getFloat32() {
              const e = this._dataView.getFloat32(this._offset, !0);
              return (this._offset += 4), e;
            }
            getFloat32Array(e) {
              const t = new Uint8Array(this._dataView.buffer, this._offset, e.byteLength);
              new Uint8Array(e.buffer, e.byteOffset, e.byteLength).set(t),
                (this._offset += e.byteLength),
                this.isDeviceLittleEndian || this.swap32Array(e);
            }
            getFloat32Tuple(e) {
              const t = new Array(e);
              for (let n = 0; n < e; ++n) (t[n] = this._dataView.getFloat32(this._offset, !0)), (this._offset += 4);
              return t;
            }
            initializeTextDecoder(e) {
              this._decoder = new TextDecoder(e);
            }
            getDecoderString(e, t) {
              if (null === this._decoder) throw new Error("TextDecoder is not initialized.");
              let n = new Uint8Array(this._dataView.buffer, this._offset, e);
              if (((this._offset += e), t))
                for (let e = 0; e < n.length; ++e)
                  if (0 === n[e]) {
                    n = n.subarray(0, e);
                    break;
                  }
              return this._decoder.decode(n);
            }
            getSignatureString(e) {
              const t = new TextDecoder("utf-8"),
                n = new Uint8Array(this._dataView.buffer, this._offset, e);
              return (this._offset += e), t.decode(n);
            }
            getPaddedArrayOffset(e, t) {
              this._offset += this._offset % e == 0 ? 0 : e - (this._offset % e);
              const n = this._offset;
              return (this._offset += e * t), n;
            }
            get bytesAvailable() {
              return this._dataView.byteLength - this._offset;
            }
          }
          !(function (e) {
            let t;
            !(function (e) {
              let t;
              !(function (e) {
                (e[(e.Rotate = 0)] = "Rotate"),
                  (e[(e.RotateMove = 1)] = "RotateMove"),
                  (e[(e.Ik = 2)] = "Ik"),
                  (e[(e.Unknown = 3)] = "Unknown"),
                  (e[(e.IkLink = 4)] = "IkLink"),
                  (e[(e.RotateEffect = 5)] = "RotateEffect"),
                  (e[(e.IkTo = 6)] = "IkTo"),
                  (e[(e.Invisible = 7)] = "Invisible"),
                  (e[(e.Twist = 8)] = "Twist"),
                  (e[(e.RotateRatio = 9)] = "RotateRatio");
              })((t = e.Type || (e.Type = {})));
            })((t = e.Bone || (e.Bone = {})));
          })(b || (b = {})),
            (function (e) {
              let t, n, i, o, r, a, s, l, h;
              !(function (e) {
                let t;
                !(function (e) {
                  (e[(e.Utf16le = 0)] = "Utf16le"), (e[(e.Utf8 = 1)] = "Utf8"), (e[(e.ShiftJis = 2)] = "ShiftJis");
                })((t = e.Encoding || (e.Encoding = {})));
              })((t = e.Header || (e.Header = {}))),
                (function (e) {
                  let t;
                  !(function (e) {
                    (e[(e.Bdef1 = 0)] = "Bdef1"),
                      (e[(e.Bdef2 = 1)] = "Bdef2"),
                      (e[(e.Bdef4 = 2)] = "Bdef4"),
                      (e[(e.Sdef = 3)] = "Sdef"),
                      (e[(e.Qdef = 4)] = "Qdef");
                  })((t = e.BoneWeightType || (e.BoneWeightType = {})));
                })((n = e.Vertex || (e.Vertex = {}))),
                (function (e) {
                  let t, n;
                  !(function (e) {
                    (e[(e.IsDoubleSided = 1)] = "IsDoubleSided"),
                      (e[(e.EnabledGroundShadow = 2)] = "EnabledGroundShadow"),
                      (e[(e.EnabledDrawShadow = 4)] = "EnabledDrawShadow"),
                      (e[(e.EnabledReceiveShadow = 8)] = "EnabledReceiveShadow"),
                      (e[(e.EnabledToonEdge = 16)] = "EnabledToonEdge"),
                      (e[(e.EnabledVertexColor = 32)] = "EnabledVertexColor"),
                      (e[(e.EnabledPointDraw = 64)] = "EnabledPointDraw"),
                      (e[(e.EnabledLineDraw = 128)] = "EnabledLineDraw");
                  })((t = e.Flag || (e.Flag = {}))),
                    (function (e) {
                      (e[(e.Off = 0)] = "Off"),
                        (e[(e.Multiply = 1)] = "Multiply"),
                        (e[(e.Add = 2)] = "Add"),
                        (e[(e.SubTexture = 3)] = "SubTexture");
                    })((n = e.SphereTextureMode || (e.SphereTextureMode = {})));
                })((i = e.Material || (e.Material = {}))),
                (function (e) {
                  let t;
                  !(function (e) {
                    (e[(e.UseBoneIndexAsTailPosition = 1)] = "UseBoneIndexAsTailPosition"),
                      (e[(e.IsRotatable = 2)] = "IsRotatable"),
                      (e[(e.IsMovable = 4)] = "IsMovable"),
                      (e[(e.IsVisible = 8)] = "IsVisible"),
                      (e[(e.IsControllable = 16)] = "IsControllable"),
                      (e[(e.IsIkEnabled = 32)] = "IsIkEnabled"),
                      (e[(e.LocalAppendTransform = 128)] = "LocalAppendTransform"),
                      (e[(e.HasAppendRotate = 256)] = "HasAppendRotate"),
                      (e[(e.HasAppendMove = 512)] = "HasAppendMove"),
                      (e[(e.HasAxisLimit = 1024)] = "HasAxisLimit"),
                      (e[(e.HasLocalVector = 2048)] = "HasLocalVector"),
                      (e[(e.TransformAfterPhysics = 4096)] = "TransformAfterPhysics"),
                      (e[(e.IsExternalParentTransformed = 8192)] = "IsExternalParentTransformed");
                  })((t = e.Flag || (e.Flag = {})));
                })((o = e.Bone || (e.Bone = {}))),
                (function (e) {
                  let t, n, i;
                  !(function (e) {
                    (e[(e.System = 0)] = "System"),
                      (e[(e.Eyebrow = 1)] = "Eyebrow"),
                      (e[(e.Eye = 2)] = "Eye"),
                      (e[(e.Lip = 3)] = "Lip"),
                      (e[(e.Other = 4)] = "Other");
                  })((t = e.Category || (e.Category = {}))),
                    (function (e) {
                      (e[(e.GroupMorph = 0)] = "GroupMorph"),
                        (e[(e.VertexMorph = 1)] = "VertexMorph"),
                        (e[(e.BoneMorph = 2)] = "BoneMorph"),
                        (e[(e.UvMorph = 3)] = "UvMorph"),
                        (e[(e.AdditionalUvMorph1 = 4)] = "AdditionalUvMorph1"),
                        (e[(e.AdditionalUvMorph2 = 5)] = "AdditionalUvMorph2"),
                        (e[(e.AdditionalUvMorph3 = 6)] = "AdditionalUvMorph3"),
                        (e[(e.AdditionalUvMorph4 = 7)] = "AdditionalUvMorph4"),
                        (e[(e.MaterialMorph = 8)] = "MaterialMorph"),
                        (e[(e.FlipMorph = 9)] = "FlipMorph"),
                        (e[(e.ImpulseMorph = 10)] = "ImpulseMorph");
                    })((n = e.Type || (e.Type = {}))),
                    (function (e) {
                      let t;
                      !(function (e) {
                        (e[(e.Multiply = 0)] = "Multiply"), (e[(e.Add = 1)] = "Add");
                      })((t = e.Type || (e.Type = {})));
                    })((i = e.MaterialMorph || (e.MaterialMorph = {})));
                })((r = e.Morph || (e.Morph = {}))),
                (function (e) {
                  let t;
                  !(function (e) {
                    let t;
                    !(function (e) {
                      (e[(e.Bone = 0)] = "Bone"), (e[(e.Morph = 1)] = "Morph");
                    })((t = e.FrameType || (e.FrameType = {})));
                  })((t = e.FrameData || (e.FrameData = {})));
                })((a = e.DisplayFrame || (e.DisplayFrame = {}))),
                (function (e) {
                  let t, n;
                  !(function (e) {
                    (e[(e.Sphere = 0)] = "Sphere"), (e[(e.Box = 1)] = "Box"), (e[(e.Capsule = 2)] = "Capsule");
                  })((t = e.ShapeType || (e.ShapeType = {}))),
                    (function (e) {
                      (e[(e.FollowBone = 0)] = "FollowBone"),
                        (e[(e.Physics = 1)] = "Physics"),
                        (e[(e.PhysicsWithBone = 2)] = "PhysicsWithBone");
                    })((n = e.PhysicsMode || (e.PhysicsMode = {})));
                })((s = e.RigidBody || (e.RigidBody = {}))),
                (function (e) {
                  let t;
                  !(function (e) {
                    (e[(e.Spring6dof = 0)] = "Spring6dof"),
                      (e[(e.Sixdof = 1)] = "Sixdof"),
                      (e[(e.P2p = 2)] = "P2p"),
                      (e[(e.ConeTwist = 3)] = "ConeTwist"),
                      (e[(e.Slider = 4)] = "Slider"),
                      (e[(e.Hinge = 5)] = "Hinge");
                  })((t = e.Type || (e.Type = {})));
                })((l = e.Joint || (e.Joint = {}))),
                (function (e) {
                  let t, n, i;
                  !(function (e) {
                    (e[(e.TriMesh = 0)] = "TriMesh"), (e[(e.Rope = 1)] = "Rope");
                  })((t = e.Type || (e.Type = {}))),
                    (function (e) {
                      (e[(e.Blink = 1)] = "Blink"),
                        (e[(e.ClusterCreation = 2)] = "ClusterCreation"),
                        (e[(e.LinkCrossing = 4)] = "LinkCrossing");
                    })((n = e.Flag || (e.Flag = {}))),
                    (function (e) {
                      (e[(e.VertexPoint = 0)] = "VertexPoint"),
                        (e[(e.VertexTwoSided = 1)] = "VertexTwoSided"),
                        (e[(e.VertexOneSided = 2)] = "VertexOneSided"),
                        (e[(e.FaceTwoSided = 3)] = "FaceTwoSided"),
                        (e[(e.FaceOneSided = 4)] = "FaceOneSided");
                    })((i = e.AeroDynamicModel || (e.AeroDynamicModel = {})));
                })((h = e.SoftBody || (e.SoftBody = {})));
            })(y || (y = {}));
          class w {
            constructor() {}
            static async ParseAsync(e, t = new M()) {
              const n = new T(e);
              n.initializeTextDecoder("shift-jis");
              const i = this._ParseHeader(n),
                o = await this._ParseVerticesAsync(n),
                r = this._ParseIndices(n),
                a = this._ParseMaterials(n),
                s = this._ParseBones(n),
                l = this._ParseIks(n),
                h = this._ParseMorphs(n),
                [d, c] = this._ParseDisplayFrames(n, h);
              if (0 === n.bytesAvailable) {
                const e = [];
                return {
                  header: i,
                  vertices: o,
                  indices: r,
                  textures: e,
                  materials: this._ConvertMaterials(a, e),
                  bones: this._ConvertBones(s, l, o, d),
                  morphs: h,
                  displayFrames: d,
                  rigidBodies: [],
                  joints: [],
                  softBodies: [],
                };
              }
              0 !== n.getUint8() && this._ParseEnglishNames(n, i, s, h, d, c);
              const m = this._ParseToonTextures(n),
                u = this._ConvertMaterials(a, m);
              if (0 === n.bytesAvailable)
                return {
                  header: i,
                  vertices: o,
                  indices: r,
                  textures: m,
                  materials: u,
                  bones: this._ConvertBones(s, l, o, d),
                  morphs: h,
                  displayFrames: d,
                  rigidBodies: [],
                  joints: [],
                  softBodies: [],
                };
              const p = this._ParseRigidBodies(n),
                g = this._ConvertBones(s, l, o, d, p);
              this._NormalizeRigidBodyPositions(p, g);
              const f = this._ParseJoints(n);
              return (
                n.bytesAvailable > 0 && t.warn(`There are ${n.bytesAvailable} bytes left after parsing`),
                {
                  header: i,
                  vertices: o,
                  indices: r,
                  textures: m,
                  materials: u,
                  bones: g,
                  morphs: h,
                  displayFrames: d,
                  rigidBodies: p,
                  joints: f,
                  softBodies: [],
                }
              );
            }
            static _ParseHeader(e) {
              if (e.bytesAvailable < 7) throw new Error("is not pmd file");
              const t = e.getSignatureString(3);
              if ("Pmd" !== t) throw new Error("is not pmd file");
              const n = e.getFloat32(),
                i = e.getDecoderString(20, !0),
                o = e.getDecoderString(256, !0);
              return {
                signature: t,
                version: n,
                encoding: y.Header.Encoding.ShiftJis,
                additionalVec4Count: 0,
                vertexIndexSize: 2,
                textureIndexSize: 4,
                materialIndexSize: 4,
                boneIndexSize: 2,
                morphIndexSize: 2,
                rigidBodyIndexSize: 4,
                modelName: i,
                englishModelName: "",
                comment: o,
                englishComment: "",
              };
            }
            static async _ParseVerticesAsync(e) {
              const t = e.getUint32(),
                n = [];
              let i = performance.now();
              for (let o = 0; o < t; ++o) {
                const t = e.getFloat32Tuple(3),
                  r = e.getFloat32Tuple(3),
                  a = e.getFloat32Tuple(2),
                  s = y.Vertex.BoneWeightType.Bdef2,
                  l = { boneIndices: [e.getUint16(), e.getUint16()], boneWeights: e.getUint8() / 100 },
                  h = 0 !== e.getUint8();
                n.push({
                  position: t,
                  normal: r,
                  uv: a,
                  additionalVec4: [],
                  weightType: s,
                  boneWeight: l,
                  edgeScale: h ? 1 : 0,
                }),
                  o % 1e4 == 0 &&
                    100 < performance.now() - i &&
                    (await new Promise((e) => setTimeout(e, 0)), (i = performance.now()));
              }
              return n;
            }
            static _ParseIndices(e) {
              const t = e.getUint32(),
                n = new Uint16Array(t);
              return e.getUint16Array(n), n;
            }
            static _ParseMaterials(e) {
              const t = e.getUint32(),
                n = [];
              for (let i = 0; i < t; ++i) {
                const t = e.getFloat32Tuple(4),
                  i = e.getFloat32(),
                  o = e.getFloat32Tuple(3),
                  r = e.getFloat32Tuple(3),
                  a = e.getInt8(),
                  s = e.getUint8(),
                  l = e.getUint32(),
                  h = e.getDecoderString(20, !0);
                let d,
                  c,
                  m = 0;
                0 !== s && (m |= y.Material.Flag.EnabledToonEdge | y.Material.Flag.EnabledGroundShadow),
                  0.98 !== t[3] && (m |= y.Material.Flag.EnabledDrawShadow | y.Material.Flag.EnabledReceiveShadow),
                  t[3] < 1 && (m |= y.Material.Flag.IsDoubleSided);
                const u = h.indexOf("*");
                -1 !== u ? ((d = h.substring(0, u)), (c = h.substring(u + 1))) : ((d = h), (c = ""));
                const p = {
                  name: h,
                  englishName: "",
                  diffuse: t,
                  specular: o,
                  shininess: i,
                  ambient: r,
                  flag: m,
                  edgeColor: [0, 0, 0, 1],
                  edgeSize: 1,
                  textureIndex: d,
                  sphereTextureIndex: c,
                  sphereTextureMode:
                    "" !== c
                      ? "h" === c[c.length - 1].toLowerCase()
                        ? y.Material.SphereTextureMode.Multiply
                        : y.Material.SphereTextureMode.Add
                      : y.Material.SphereTextureMode.Off,
                  isSharedToonTexture: !1,
                  toonTextureIndex: a,
                  comment: "",
                  indexCount: l,
                };
                n.push(p);
              }
              return n;
            }
            static _ParseBones(e) {
              const t = e.getUint16(),
                n = [];
              for (let i = 0; i < t; ++i) {
                const t = {
                  name: e.getDecoderString(20, !0),
                  englishName: "",
                  parentBoneIndex: e.getInt16(),
                  tailIndex: e.getInt16(),
                  type: e.getUint8(),
                  ikIndex: e.getInt16(),
                  position: e.getFloat32Tuple(3),
                };
                n.push(t);
              }
              return n;
            }
            static _ParseIks(e) {
              const t = e.getUint16(),
                n = [];
              for (let i = 0; i < t; ++i) {
                const t = e.getUint16(),
                  i = e.getUint16(),
                  o = e.getUint8(),
                  r = e.getUint16(),
                  a = e.getFloat32(),
                  s = [];
                for (let t = 0; t < o; ++t) s.push(e.getUint16());
                const l = { boneIndex: t, targetIndex: i, iteration: r, rotationConstraint: a, links: s };
                n.push(l);
              }
              return n;
            }
            static _ParseMorphs(e) {
              const t = e.getUint16();
              if (0 === t) return [];
              const n = [];
              for (let i = 0; i < t; ++i) {
                const t = e.getDecoderString(20, !0),
                  i = e.getUint32();
                let o = { name: t, englishName: "", category: e.getUint8(), type: y.Morph.Type.VertexMorph };
                const r = new Int32Array(i),
                  a = new Float32Array(3 * i);
                for (let t = 0; t < i; ++t)
                  (r[t] = e.getUint32()),
                    (a[3 * t + 0] = e.getFloat32()),
                    (a[3 * t + 1] = e.getFloat32()),
                    (a[3 * t + 2] = e.getFloat32());
                (o = { ...o, indices: r, positions: a }), n.push(o);
              }
              const i = n.shift().indices;
              for (let e = 0; e < n.length; ++e) {
                const t = n[e].indices;
                for (let e = 0; e < t.length; ++e) {
                  const n = t[e];
                  0 <= n && n < i.length ? (t[e] = i[n]) : (t[e] = 0);
                }
              }
              return n;
            }
            static _ParseDisplayFrames(e, t) {
              const n = [],
                i = e.getUint8();
              for (let o = 0; o < i; ++o) {
                const i = { type: y.DisplayFrame.FrameData.FrameType.Morph, index: e.getUint16() },
                  o = { name: t[i.index]?.name ?? "", englishName: "", isSpecialFrame: !0, frames: [i] };
                n.push(o);
              }
              const o = n.length,
                r = e.getUint8();
              for (let t = 0; t < r; ++t) {
                const t = { name: e.getDecoderString(50, !0), englishName: "", isSpecialFrame: !1, frames: void 0 };
                n.push(t);
              }
              const a = e.getUint32();
              for (let t = 0; t < a; ++t) {
                const t = e.getUint16(),
                  i = n[o + e.getUint8() - 1];
                if (void 0 !== i) {
                  const e = { type: y.DisplayFrame.FrameData.FrameType.Bone, index: t };
                  void 0 === i.frames ? (i.frames = [e]) : i.frames.push(e);
                }
              }
              for (let e = o; e < n.length; ++e) {
                const t = n[e];
                void 0 === t.frames && (t.frames = []);
              }
              return [n, o];
            }
            static _ParseEnglishNames(e, t, n, i, o, r) {
              (t.englishModelName = e.getDecoderString(20, !0)), (t.englishComment = e.getDecoderString(256, !0));
              for (let t = 0; t < n.length; ++t) n[t].englishName = e.getDecoderString(20, !0);
              for (let t = 0; t < i.length; ++t) i[t].englishName = e.getDecoderString(20, !0);
              for (let t = r; t < o.length; ++t) o[t].englishName = e.getDecoderString(50, !0);
            }
            static _ParseToonTextures(e) {
              const t = [];
              for (let n = 0; n < 10; ++n) t.push(e.getDecoderString(100, !0));
              return t;
            }
            static _PathNormalize(e) {
              const t = (e = e.replace(/\\/g, "/")).split("/"),
                n = [];
              for (let e = 0; e < t.length; ++e) {
                const i = t[e];
                "." !== i && (".." === i ? n.pop() : n.push(i));
              }
              return n.join("/").toLowerCase();
            }
            static _ConvertMaterials(e, t) {
              const n = new Array(t.length);
              for (let e = 0; e < t.length; ++e) n[e] = this._PathNormalize(t[e]);
              for (let i = 0; i < e.length; ++i) {
                const o = e[i];
                if (0 <= o.toonTextureIndex && o.toonTextureIndex < t.length) {
                  const e = n[o.toonTextureIndex];
                  if (/toon(10|0[0-9])\.bmp/.test(e)) {
                    o.isSharedToonTexture = !0;
                    let t = e.substring(e.length - 6, e.length - 4);
                    "n" === t[0] && (t = t[1]), (o.toonTextureIndex = parseInt(t, 10) - 1);
                  }
                }
              }
              const i = new Map();
              for (let e = 0; e < t.length; ++e) i.set(this._PathNormalize(t[e]), e);
              for (let n = 0; n < e.length; ++n) {
                const o = e[n];
                if ("" !== o.textureIndex) {
                  const e = this._PathNormalize(o.textureIndex);
                  let n = i.get(e);
                  void 0 === n && ((n = i.size), i.set(e, n), t.push(o.textureIndex)), (o.textureIndex = n);
                }
                if ("" !== o.sphereTextureIndex) {
                  const e = this._PathNormalize(o.sphereTextureIndex);
                  let n = i.get(e);
                  void 0 === n && ((n = i.size), i.set(e, n), t.push(o.sphereTextureIndex)), (o.sphereTextureIndex = n);
                }
              }
              return e;
            }
            static _IkAngleLimitTable = new Map(
              Object.entries({ 左ひざ: [-180, -0.5, 0, 0, 0, 0], 右ひざ: [-180, -0.5, 0, 0, 0, 0] })
            );
            static _ConvertBones(e, t, n, i, o) {
              const r = new Map();
              for (let n = 0; n < t.length; ++n) {
                const i = t[n].boneIndex;
                0 <= i && i < e.length && !r.has(i) && r.set(i, n);
              }
              const a = [];
              for (let t = 0; t < e.length; ++t) {
                const n = e[t],
                  i = {
                    name: n.name,
                    englishName: n.englishName,
                    position: n.position,
                    parentBoneIndex: n.parentBoneIndex,
                    transformOrder: 0,
                    flag: y.Bone.Flag.UseBoneIndexAsTailPosition,
                    tailPosition: n.tailIndex <= 0 ? -1 : n.tailIndex,
                    appendTransform: void 0,
                    axisLimit: void 0,
                    localVector: void 0,
                    externalParentTransform: void 0,
                    ik: void 0,
                  };
                let o = r.has(t);
                switch (
                  ((i.flag |= y.Bone.Flag.IsRotatable | y.Bone.Flag.IsVisible | y.Bone.Flag.IsControllable),
                  (i.flag &=
                    ~y.Bone.Flag.IsMovable &
                    ~y.Bone.Flag.IsIkEnabled &
                    ~y.Bone.Flag.HasAppendRotate &
                    ~y.Bone.Flag.HasAxisLimit),
                  n.type)
                ) {
                  case b.Bone.Type.RotateMove:
                    i.flag |= y.Bone.Flag.IsMovable;
                    break;
                  case b.Bone.Type.Ik:
                    o = !0;
                    break;
                  case b.Bone.Type.RotateEffect:
                    (i.flag |= y.Bone.Flag.HasAppendRotate),
                      (i.flag &= ~y.Bone.Flag.UseBoneIndexAsTailPosition & ~y.Bone.Flag.IsVisible),
                      (i.appendTransform = { parentIndex: n.tailIndex, ratio: 0.01 * n.ikIndex });
                }
                o && ((i.flag |= y.Bone.Flag.IsMovable | y.Bone.Flag.IsIkEnabled), (i.transformOrder = 1)), a.push(i);
              }
              let s = Math.min(a.length, e.length);
              for (let t = 0; t < s; ++t) {
                const n = e[t],
                  i = a[t];
                if (n.type === b.Bone.Type.Twist) {
                  let t = e[n.tailIndex];
                  void 0 === t && (t = e[0]);
                  const o = t.position,
                    r = n.position;
                  i.axisLimit = [o[0] - r[0], o[1] - r[1], o[2] - r[2]];
                  const a = i.axisLimit,
                    s = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
                  (a[0] /= s), (a[1] /= s), (a[2] /= s), (i.flag &= ~y.Bone.Flag.UseBoneIndexAsTailPosition);
                }
              }
              const l = [];
              for (let n = 0; n < s; ++n) {
                const i = a[n];
                if (0 == (i.flag & y.Bone.Flag.IsIkEnabled)) continue;
                let o = 0;
                for (let r = 0; r < t.length; ++r) {
                  const s = t[r];
                  if (s.boneIndex !== n) continue;
                  let h;
                  0 === o
                    ? ((h = i), (o += 1))
                    : ((h = {
                        name: i.name + "+",
                        englishName: i.englishName,
                        position: [...i.position],
                        parentBoneIndex: n,
                        transformOrder: i.transformOrder,
                        flag: i.flag & ~y.Bone.Flag.IsVisible & ~y.Bone.Flag.UseBoneIndexAsTailPosition,
                        tailPosition: [0, 0, 0],
                        appendTransform: void 0 !== i.appendTransform ? { ...i.appendTransform } : void 0,
                        axisLimit: void 0 !== i.axisLimit ? [...i.axisLimit] : void 0,
                        localVector:
                          void 0 !== i.localVector ? { x: [...i.localVector.x], z: [...i.localVector.z] } : void 0,
                        externalParentTransform: i.externalParentTransform,
                        ik: void 0,
                      }),
                      l.push(h),
                      (o += 1)),
                    void 0 === h.ik && (h.ik = { target: 0, iteration: 0, rotationConstraint: 0, links: [] });
                  {
                    const t = h.ik;
                    (t.target = s.targetIndex),
                      (t.iteration = s.iteration),
                      (t.rotationConstraint = 4 * s.rotationConstraint);
                    const n = s.links;
                    for (let i = 0; i < n.length; ++i) {
                      const o = n[i];
                      if (0 <= o && o < a.length) {
                        const n = { target: o, limitation: void 0 };
                        if (0 <= o && o < e.length) {
                          const t = e[o].name,
                            i = this._IkAngleLimitTable.get(t);
                          void 0 !== i &&
                            (n.limitation = { minimumAngle: [i[0], i[2], i[4]], maximumAngle: [i[1], i[3], i[5]] });
                        }
                        t.links.push(n);
                      }
                    }
                  }
                }
              }
              a.push(...l), (s = Math.min(a.length, e.length));
              const h = [];
              for (let e = 0; e < s; ++e)
                if (0 != (a[e].flag & y.Bone.Flag.IsIkEnabled))
                  for (let n = 0; n < t.length; ++n)
                    if (t[n].boneIndex === e) {
                      h.push([e, n]);
                      break;
                    }
              let d = !0;
              for (let e = 0; e < h.length - 1; ++e)
                if (h[e][1] > h[e + 1][1]) {
                  d = !1;
                  break;
                }
              if (!d) {
                h.sort((e, t) => e[1] - t[1]);
                const e = new Array(h.length);
                for (let t = 1; t < h.length; ++t) {
                  let n = !0;
                  (h[t - 1][0] > h[t][0] || void 0 !== e[t - 1]) && (n = !1), n || (e[t] = a[h[t - 1][0]]);
                }
                const t = new Map();
                for (let n = 0; n < e.length; ++n) {
                  const i = e[n];
                  void 0 === i || t.has(i) || t.set(i, n);
                }
                const r = new Array(h.length);
                for (let e = 0; e < h.length; ++e) r[e] = a[h[e][0]];
                const s = a.slice();
                for (let n = 0; 0 < t.size; ++n) {
                  for (let n = 1; n < h.length; ++n)
                    if (void 0 !== e[n] && void 0 !== r[n] && !t.has(r[n])) {
                      const i = r[n],
                        o = a.indexOf(i);
                      a.splice(o, 1);
                      const s = a.indexOf(e[n]) + 1;
                      a.splice(s, 0, i), t.delete(i);
                    }
                  if (h.length < n) break;
                }
                const l = new Map();
                for (let e = 0; e < a.length; ++e) {
                  const t = a[e];
                  l.set(t, e);
                }
                for (let e = 0; e < n.length; ++e) {
                  const t = n[e].boneWeight;
                  if ("number" == typeof t.boneIndices) t.boneIndices = l.get(s[t.boneIndices]);
                  else {
                    const e = t.boneIndices;
                    for (let t = 0; t < e.length; ++t) e[t] = l.get(s[e[t]]);
                  }
                }
                for (let e = 0; e < a.length; ++e) {
                  const t = a[e];
                  if (
                    ((t.parentBoneIndex = l.get(s[t.parentBoneIndex])),
                    "number" == typeof t.tailPosition && (t.tailPosition = l.get(s[t.tailPosition])),
                    t.appendTransform && (t.appendTransform.parentIndex = l.get(s[t.appendTransform.parentIndex])),
                    t.ik)
                  ) {
                    t.ik.target = l.get(s[t.ik.target]);
                    const e = t.ik.links;
                    for (let t = 0; t < e.length; ++t) e[t].target = l.get(s[e[t].target]);
                  }
                }
                for (let e = 0; e < i.length; ++e) {
                  const t = i[e].frames;
                  if (void 0 !== t)
                    for (let e = 0; e < t.length; ++e) {
                      const n = t[e];
                      n.type === y.DisplayFrame.FrameData.FrameType.Bone && (n.index = l.get(s[n.index]));
                    }
                }
                if (void 0 !== o)
                  for (let e = 0; e < o.length; ++e) {
                    const t = o[e];
                    t.boneIndex = l.get(s[t.boneIndex]);
                  }
              }
              let c = !1;
              for (let e = 0; e < a.length; ++e) {
                let t = a[e];
                for (let n = 0; n < a.length; ++n) {
                  const i = a[n].parentBoneIndex;
                  if (i === e) {
                    c = !0;
                    break;
                  }
                  if (((t = a[i]), void 0 === t)) break;
                }
                if (c) break;
              }
              if (c)
                for (let e = 0; e < a.length; ++e) {
                  let e = !1;
                  for (let t = 0; t < a.length; ++t) {
                    const n = a[t];
                    let i = n,
                      o = n.transformOrder;
                    for (;;) {
                      const t = a[i.parentBoneIndex];
                      if (void 0 === t) break;
                      o < t.transformOrder && ((o = t.transformOrder), (e = !0)), (i = t);
                    }
                    n.transformOrder = o;
                  }
                  if (!e) break;
                }
              for (let e = 0; e < a.length; ++e) {
                const t = a[e];
                0 != (t.flag & y.Bone.Flag.UseBoneIndexAsTailPosition)
                  ? "number" != typeof t.tailPosition && (t.tailPosition = -1)
                  : "number" == typeof t.tailPosition && (t.tailPosition = [0, 0, 0]);
              }
              return a;
            }
            static _ParseRigidBodies(e) {
              const t = e.getUint32(),
                n = [];
              for (let i = 0; i < t; ++i) {
                const t = {
                  name: e.getDecoderString(20, !0),
                  englishName: "",
                  boneIndex: e.getInt16(),
                  collisionGroup: e.getUint8(),
                  collisionMask: e.getUint16(),
                  shapeType: e.getUint8(),
                  shapeSize: e.getFloat32Tuple(3),
                  shapePosition: e.getFloat32Tuple(3),
                  shapeRotation: e.getFloat32Tuple(3),
                  mass: e.getFloat32(),
                  linearDamping: e.getFloat32(),
                  angularDamping: e.getFloat32(),
                  repulsion: e.getFloat32(),
                  friction: e.getFloat32(),
                  physicsMode: e.getUint8(),
                };
                n.push(t);
              }
              return n;
            }
            static _NormalizeRigidBodyPositions(e, t) {
              for (let n = 0; n < e.length; ++n) {
                const i = e[n],
                  o = t[i.boneIndex < 0 ? 0 : i.boneIndex].position,
                  r = i.shapePosition;
                (r[0] += o[0]), (r[1] += o[1]), (r[2] += o[2]);
              }
            }
            static _ParseJoints(e) {
              const t = e.getUint32(),
                n = [];
              for (let i = 0; i < t; ++i) {
                const t = e.getDecoderString(20, !0),
                  i = e.getInt32(),
                  o = e.getInt32(),
                  r = e.getFloat32Tuple(3),
                  a = e.getFloat32Tuple(3),
                  s = e.getFloat32Tuple(3),
                  l = e.getFloat32Tuple(3),
                  h = e.getFloat32Tuple(3),
                  d = e.getFloat32Tuple(3),
                  c = e.getFloat32Tuple(3),
                  m = e.getFloat32Tuple(3),
                  u = {
                    name: t,
                    englishName: "",
                    type: y.Joint.Type.Spring6dof,
                    rigidbodyIndexA: i,
                    rigidbodyIndexB: o,
                    position: r,
                    rotation: a,
                    positionMin: s,
                    positionMax: l,
                    rotationMin: h,
                    rotationMax: d,
                    springPosition: c,
                    springRotation: m,
                  };
                n.push(u);
              }
              return n;
            }
          }
          var x = H(3898),
            I = H(3929),
            v = H(6867),
            B = H(7466),
            P = H(8698),
            O = H(1755),
            F = H(9125),
            R = H(6320),
            S = H(6429),
            C = H(8619),
            E = H(6377),
            k = H(4751),
            N = H(1860),
            D = H(5501),
            L = H(5197),
            U = H(7508),
            V = H(7116);
          class W {
            static Data = [
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=",
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==",
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC",
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==",
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==",
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=",
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=",
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=",
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=",
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=",
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=",
            ];
          }
          function z(e) {
            const t = (e = e.replace(/\\/g, "/")).split("/"),
              n = [];
            for (let e = 0; e < t.length; ++e) {
              const i = t[e];
              "." !== i && (".." === i ? n.pop() : n.push(i));
            }
            return n.join("/");
          }
          class K {
            uniqueId;
            leftLoadCount;
            isRequesting;
            errorTextureDatas;
            constructor(e) {
              (this.uniqueId = e), (this.leftLoadCount = 0), (this.isRequesting = !0), (this.errorTextureDatas = []);
            }
          }
          class j {
            observable;
            hasLoadError;
            constructor() {
              (this.observable = new U.Observable()), (this.hasLoadError = !1);
            }
          }
          class Y {
            cacheKey;
            _scene;
            _assetContainer;
            _options;
            _onLoad;
            _onError;
            _texture;
            constructor(e, t, n, i, o, r, a, s) {
              (this.cacheKey = e),
                (this._scene = t),
                (this._assetContainer = n),
                (this._options = r),
                (this._onLoad = a),
                (this._onError = s),
                (this._texture = null),
                o ||
                  t._loadFile(
                    i,
                    (i) => {
                      this._createTexture(t, n, e, i, r, a, (e, t) => {
                        s?.(e, t);
                      });
                    },
                    void 0,
                    !0,
                    !0,
                    (e, t) => {
                      s?.(e ? e.status + " " + e.statusText : "", t);
                    }
                  );
            }
            loadFromArrayBuffer(e) {
              this._createTexture(
                this._scene,
                this._assetContainer,
                this.cacheKey,
                e,
                this._options,
                this._onLoad,
                (e, t) => {
                  this._onError?.(e, t);
                }
              );
            }
            _onDisposeCallback = null;
            registerOnDisposeCallback(e) {
              (this._onDisposeCallback = e), this._texture.onDisposeObservable.addOnce(e);
            }
            unregisterOnDisposeCallback() {
              const e = this._onDisposeCallback;
              return null === e
                ? null
                : ((this._onDisposeCallback = null), this._texture.onDisposeObservable.removeCallback(e), e);
            }
            _createTexture(e, t, n, i, o, r, a) {
              e._blockEntityCollection = !!t;
              const s = {
                  noMipmap: o.noMipmap,
                  invertY: o.invertY,
                  samplingMode: o.samplingMode,
                  onLoad: () => {
                    null === this._texture ? null !== r && V.TimingTools.SetImmediate(r) : r?.();
                  },
                  onError: a,
                  buffer: i,
                  deleteBuffer: o.deleteBuffer,
                  mimeType: o.mimeType,
                },
                l = (this._texture = new L.Texture("data:" + n, e, s));
              (l._parentContainer = t), (e._blockEntityCollection = !1), t?.textures.push(l), (l.name = n);
            }
            get texture() {
              return this._texture;
            }
          }
          class Q {
            onModelTextureLoadedObservable = new Map();
            textureCache = new Map();
            _textureLoadInfoMap = new Map();
            _loadingModels = new Map();
            _errorTexturesReferenceCount = new Map();
            _incrementLeftLoadCount(e) {
              let t = this._loadingModels.get(e);
              void 0 === t && ((t = new K(e)), this._loadingModels.set(e, t)), (t.leftLoadCount += 1);
              let n = this.onModelTextureLoadedObservable.get(e);
              return void 0 === n && ((n = new U.Observable()), this.onModelTextureLoadedObservable.set(e, n)), t;
            }
            _decrementLeftLoadCount(e) {
              if (((e.leftLoadCount -= 1), !e.isRequesting && 0 === e.leftLoadCount)) {
                this._removeErrorTexturesReferenceCount(e.uniqueId), this._loadingModels.delete(e.uniqueId);
                const t = this.onModelTextureLoadedObservable.get(e.uniqueId);
                t?.notifyObservers(), t?.clear(), this.onModelTextureLoadedObservable.delete(e.uniqueId);
              }
            }
            loadModelTexturesEnd(e) {
              const t = this._loadingModels.get(e);
              if (void 0 !== t && ((t.isRequesting = !1), 0 === t.leftLoadCount)) {
                this._removeErrorTexturesReferenceCount(e), this._loadingModels.delete(e);
                const t = this.onModelTextureLoadedObservable.get(e);
                t?.notifyObservers(), t?.clear(), this.onModelTextureLoadedObservable.delete(e);
              }
            }
            _addErrorTextureReferenceCount(e, t) {
              this._loadingModels.get(e).errorTextureDatas.push(t),
                this._errorTexturesReferenceCount.set(t, (this._errorTexturesReferenceCount.get(t) ?? 0) + 1);
            }
            _removeErrorTexturesReferenceCount(e) {
              const t = this._loadingModels.get(e);
              for (let e = 0; e < t.errorTextureDatas.length; ++e) {
                const n = t.errorTextureDatas[e],
                  i = this._errorTexturesReferenceCount.get(n) - 1;
                0 === i
                  ? null !== n.texture
                    ? n.texture.dispose()
                    : (this._textureLoadInfoMap.delete(n.cacheKey),
                      this.textureCache.delete(n.cacheKey),
                      this._errorTexturesReferenceCount.delete(n))
                  : this._errorTexturesReferenceCount.set(n, i);
              }
            }
            _handleTextureOnDispose(e) {
              e.registerOnDisposeCallback(() => {
                this._textureLoadInfoMap.delete(e.cacheKey),
                  this.textureCache.delete(e.cacheKey),
                  this._errorTexturesReferenceCount.delete(e);
              });
            }
            async _loadTextureAsyncInternal(e, t, n, i, o, r, a) {
              const s = this._incrementLeftLoadCount(e);
              let l = this._textureLoadInfoMap.get(t);
              void 0 === l && ((l = new j()), this._textureLoadInfoMap.set(t, l));
              let h = this.textureCache.get(t);
              if (void 0 === h && !l.hasLoadError) {
                const s = null !== i ? W.Data[i] : t;
                (h = new Y(
                  t,
                  o,
                  r,
                  s,
                  null !== n,
                  a,
                  () => {
                    this._handleTextureOnDispose(h),
                      (l.hasLoadError = !1),
                      l.observable.notifyObservers(!1),
                      l.observable.clear();
                  },
                  (t, n) => {
                    null !== h.texture && this._handleTextureOnDispose(h),
                      this._addErrorTextureReferenceCount(e, h),
                      (l.hasLoadError = !0),
                      l.observable.notifyObservers(!0),
                      l.observable.clear();
                  }
                )),
                  this.textureCache.set(t, h);
                const d = n instanceof Blob ? await n.arrayBuffer() : n;
                null !== d && h.loadFromArrayBuffer(d);
              }
              return null !== h.texture && h.texture.isReady()
                ? (this._decrementLeftLoadCount(s), l.hasLoadError ? null : h.texture)
                : new Promise((e) => {
                    l.observable.addOnce((t) => {
                      this._decrementLeftLoadCount(s), e(t ? null : h.texture);
                    });
                  });
            }
            async loadTextureAsync(e, t, n, i, o, r) {
              let a;
              "number" == typeof n ? ((n < -1 || 9 < n) && (n = -1), (n += 1), (a = !0)) : (a = !1);
              const s = a ? (a ? "file:shared_toon_texture_" + n : n) : z(t + n);
              return await this._loadTextureAsyncInternal(e, s, null, a ? n : null, i, o, r);
            }
            async loadTextureFromBufferAsync(e, t, n, i, o, r, a = !0) {
              return a && (t = z(t)), await this._loadTextureAsyncInternal(e, t, n, null, i, o, r);
            }
          }
          var q,
            $ = H(4229),
            X = H(9430),
            J = H(9190);
          class Z extends X.MaterialDefines {
            SPHERE_TEXTURE = !1;
            SPHERE_TEXTURE_BLEND_MODE_MULTIPLY = !1;
            SPHERE_TEXTURE_BLEND_MODE_ADD = !1;
            TOON_TEXTURE = !1;
            IGNORE_DIFFUSE_WHEN_TOON_TEXTURE_DISABLED = !1;
            TEXTURE_COLOR = !1;
            SPHERE_TEXTURE_COLOR = !1;
            TOON_TEXTURE_COLOR = !1;
            SDEF = !1;
          }
          !(function (e) {
            (e[(e.Multiply = 1)] = "Multiply"), (e[(e.Add = 2)] = "Add"), (e[(e.SubTexture = 3)] = "SubTexture");
          })(q || (q = {}));
          class ee extends J.MaterialPluginBase {
            _sphereTexture = null;
            _sphereTextureBlendMode = q.Add;
            _toonTexture = null;
            _ignoreDiffuseWhenToonTextureIsNull = !1;
            textureColor = new D.Color4(1, 1, 1, 1);
            sphereTextureColor = new D.Color4(1, 1, 1, 1);
            toonTextureColor = new D.Color4(1, 1, 1, 1);
            _useTextureColor = !1;
            _useSphereTextureColor = !1;
            _useToonTextureColor = !1;
            _isEnabled = !1;
            get isEnabled() {
              return this._isEnabled;
            }
            set isEnabled(e) {
              this._isEnabled !== e && ((this._isEnabled = e), this.markAllDefinesAsDirty(), this._enable(e));
            }
            get sphereTexture() {
              return this._sphereTexture;
            }
            set sphereTexture(e) {
              this._sphereTexture !== e && ((this._sphereTexture = e), this.markAllSubMeshesAsTexturesDirty());
            }
            get sphereTextureBlendMode() {
              return this._sphereTextureBlendMode;
            }
            set sphereTextureBlendMode(e) {
              this._sphereTextureBlendMode !== e && ((this._sphereTextureBlendMode = e), this.markAllDefinesAsDirty());
            }
            get toonTexture() {
              return this._toonTexture;
            }
            set toonTexture(e) {
              this._toonTexture !== e && ((this._toonTexture = e), this.markAllSubMeshesAsTexturesDirty());
            }
            get ignoreDiffuseWhenToonTextureIsNull() {
              return this._ignoreDiffuseWhenToonTextureIsNull;
            }
            set ignoreDiffuseWhenToonTextureIsNull(e) {
              this._ignoreDiffuseWhenToonTextureIsNull !== e &&
                ((this._ignoreDiffuseWhenToonTextureIsNull = e), this.markAllDefinesAsDirty());
            }
            get useTextureColor() {
              return this._useTextureColor;
            }
            set useTextureColor(e) {
              this._useTextureColor !== e && ((this._useTextureColor = e), this.markAllDefinesAsDirty());
            }
            get useSphereTextureColor() {
              return this._useSphereTextureColor;
            }
            set useSphereTextureColor(e) {
              this._useSphereTextureColor !== e && ((this._useSphereTextureColor = e), this.markAllDefinesAsDirty());
            }
            get useToonTextureColor() {
              return this._useToonTextureColor;
            }
            set useToonTextureColor(e) {
              this._useToonTextureColor !== e && ((this._useToonTextureColor = e), this.markAllDefinesAsDirty());
            }
            _internalMarkAllSubMeshesAsTexturesDirty;
            markAllSubMeshesAsTexturesDirty() {
              this._enable(this._isEnabled), this._internalMarkAllSubMeshesAsTexturesDirty();
            }
            constructor(e, t = !0) {
              super(e, "MmdMaterial", 100, new Z(), t),
                (this._internalMarkAllSubMeshesAsTexturesDirty =
                  e._dirtyCallbacks[r.Constants.MATERIAL_TextureDirtyFlag]);
            }
            isReadyForSubMesh(e, t) {
              return (
                !this._isEnabled ||
                !(
                  e._areTexturesDirty &&
                  t.texturesEnabled &&
                  this._sphereTexture &&
                  !this._sphereTexture.isReadyOrNotBlocking()
                )
              );
            }
            bindForSubMesh(e, t, n, i) {
              if (!this._isEnabled) return;
              const o = i.materialDefines,
                r = this._material.isFrozen;
              (e.useUbo && r && e.isSync) ||
                (o.DIFFUSE && o.TEXTURE_COLOR && e.updateDirectColor4("textureColor", this.textureColor),
                o.NORMAL &&
                  o.SPHERE_TEXTURE &&
                  o.SPHERE_TEXTURE_COLOR &&
                  e.updateDirectColor4("sphereTextureColor", this.sphereTextureColor),
                o.TOON_TEXTURE &&
                  o.TOON_TEXTURE_COLOR &&
                  e.updateDirectColor4("toonTextureColor", this.toonTextureColor),
                o.SPHERE_TEXTURE && null !== i.effect && this._material.bindView(i.effect)),
                t.texturesEnabled &&
                  (o.NORMAL && this._sphereTexture && e.setTexture("sphereSampler", this._sphereTexture),
                  this._toonTexture && e.setTexture("toonSampler", this._toonTexture));
            }
            dispose(e) {
              e && (this._sphereTexture?.dispose(), this._toonTexture?.dispose());
            }
            getCustomCode(e) {
              if ("vertex" === e) {
                const e = {};
                return (
                  (e.CUSTOM_VERTEX_DEFINITIONS = p),
                  (e[
                    `!${this._escapeRegExp("finalWorld=finalWorld*influence;")}`
                  ] = `\n${g}\nfinalWorld=(finalWorld*influence);\n`),
                  e
                );
              }
              if ("fragment" === e) {
                const e = {
                  CUSTOM_FRAGMENT_DEFINITIONS:
                    "\n#if defined(SPHERE_TEXTURE) && defined(NORMAL)\nuniform sampler2D sphereSampler;\n#endif\n#ifdef TOON_TEXTURE\nuniform sampler2D toonSampler;\n#endif\n",
                  CUSTOM_FRAGMENT_MAIN_BEGIN: "\n#ifdef TOON_TEXTURE\nvec3 toonNdl;\n#endif\n",
                };
                return (
                  (e[
                    `!${this._escapeRegExp(
                      "#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION) || defined(PREPASS)\nuniform mat4 view;\n#endif"
                    )}`
                  ] =
                    "\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION) || defined(PREPASS)\nuniform mat4 view;\n#elif defined(NORMAL) && defined(SPHERE_TEXTURE)\nuniform mat4 view;\n#endif\n"),
                  (e[`!${this._escapeRegExp("baseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);")}`] =
                    "\n#if defined(DIFFUSE) && defined(TEXTURE_COLOR)\nbaseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset)*textureColor;\n#else\nbaseColor=texture2D(diffuseSampler,(vDiffuseUV+uvOffset));\n#endif\n"),
                  (e[`!${this._escapeRegExp("struct lightingInfo\n{")}`] =
                    "\nstruct lightingInfo {\n#ifdef TOON_TEXTURE\n#if !defined(NDOTL)\nfloat ndl;\n#endif\nfloat isToon;\n#endif\n"),
                  (e[`!${this._escapeRegExp("result.diffuse=ndl*diffuseColor*attenuation;")}`] =
                    "\n#ifdef TOON_TEXTURE\nresult.diffuse=diffuseColor*attenuation;result.ndl=ndl;result.isToon=1.0;\n#elif defined(IGNORE_DIFFUSE_WHEN_TOON_TEXTURE_DISABLED) \nresult.diffuse=diffuseColor*attenuation;\n#else\nresult.diffuse=(ndl*diffuseColor*attenuation);\n#endif\n"),
                  (e[`!${this._escapeRegExp("diffuseBase+=info.diffuse*shadow;")}`] =
                    "\n#ifdef TOON_TEXTURE\ntoonNdl=vec3(clamp(info.ndl*shadow,0.02,0.98));toonNdl.r=texture2D(toonSampler,vec2(0.5,toonNdl.r)).r;toonNdl.g=texture2D(toonSampler,vec2(0.5,toonNdl.g)).g;toonNdl.b=texture2D(toonSampler,vec2(0.5,toonNdl.b)).b;\n#ifdef TOON_TEXTURE_COLOR\ntoonNdl*=toonTextureColor.rgb*toonTextureColor.a;\n#endif\ndiffuseBase+=mix(info.diffuse*shadow,toonNdl*info.diffuse,info.isToon);\n#elif defined(IGNORE_DIFFUSE_WHEN_TOON_TEXTURE_DISABLED)\ndiffuseBase+=info.diffuse;\n#else\ndiffuseBase+=(info.diffuse*shadow);\n#endif\n"),
                  (e.CUSTOM_FRAGMENT_BEFORE_FOG =
                    "\n#if defined(NORMAL) && defined(SPHERE_TEXTURE)\nvec3 viewSpaceNormal=normalize(mat3(view)*vNormalW);vec2 sphereUV=viewSpaceNormal.xy*0.5+0.5;vec4 sphereReflectionColor=texture2D(sphereSampler,sphereUV);\n#ifdef SPHERE_TEXTURE_COLOR\nsphereReflectionColor*=sphereTextureColor;\n#endif\nsphereReflectionColor.rgb*=diffuseBase;\n#ifdef SPHERE_TEXTURE_BLEND_MODE_MULTIPLY\ncolor*=sphereReflectionColor;\n#elif defined(SPHERE_TEXTURE_BLEND_MODE_ADD)\ncolor+=vec4(sphereReflectionColor.rgb,sphereReflectionColor.a*alpha);\n#endif\n#endif\n"),
                  e
                );
              }
              return null;
            }
            prepareDefines(e, t, n) {
              if (this._isEnabled) {
                const i = t.texturesEnabled;
                (e.SPHERE_TEXTURE = null !== this._sphereTexture && i),
                  (e.SPHERE_TEXTURE_BLEND_MODE_MULTIPLY = this._sphereTextureBlendMode === q.Multiply),
                  (e.SPHERE_TEXTURE_BLEND_MODE_ADD = this._sphereTextureBlendMode === q.Add),
                  (e.TOON_TEXTURE = null !== this._toonTexture && i),
                  (e.IGNORE_DIFFUSE_WHEN_TOON_TEXTURE_DISABLED = this._ignoreDiffuseWhenToonTextureIsNull),
                  (e.TEXTURE_COLOR = this._useTextureColor),
                  (e.SPHERE_TEXTURE_COLOR = this._useSphereTextureColor),
                  (e.TOON_TEXTURE_COLOR = this._useToonTextureColor),
                  (e.SDEF =
                    n.useBones &&
                    n.computeBonesUsingShaders &&
                    !!n.skeleton &&
                    n.isVerticesDataPresent(m.MatricesSdefCKind));
              } else
                (e.SPHERE_TEXTURE = !1),
                  (e.SPHERE_TEXTURE_BLEND_MODE_MULTIPLY = !1),
                  (e.SPHERE_TEXTURE_BLEND_MODE_ADD = !1),
                  (e.TOON_TEXTURE = !1),
                  (e.IGNORE_DIFFUSE_WHEN_TOON_TEXTURE_DISABLED = !1),
                  (e.TEXTURE_COLOR = !1),
                  (e.SPHERE_TEXTURE_COLOR = !1),
                  (e.TOON_TEXTURE_COLOR = !1),
                  (e.SDEF = !1);
            }
            hasTexture(e) {
              return this._sphereTexture === e || this._toonTexture === e;
            }
            getActiveTextures(e) {
              this._sphereTexture && e.push(this._sphereTexture), this._toonTexture && e.push(this._toonTexture);
            }
            getAnimatables(e) {
              this._sphereTexture &&
                this._sphereTexture.animations &&
                0 < this._sphereTexture.animations.length &&
                e.push(this._sphereTexture),
                this._toonTexture &&
                  this._toonTexture.animations &&
                  0 < this._toonTexture.animations.length &&
                  e.push(this._toonTexture);
            }
            getSamplers(e) {
              e.push("sphereSampler", "toonSampler");
            }
            getAttributes(e, t, n) {
              this._isEnabled &&
                n.useBones &&
                n.computeBonesUsingShaders &&
                n.skeleton &&
                n.isVerticesDataPresent(m.MatricesSdefCKind) &&
                (e.push(m.MatricesSdefCKind), e.push(m.MatricesSdefR0Kind), e.push(m.MatricesSdefR1Kind));
            }
            getUniforms() {
              return {
                ubo: [
                  { name: "textureColor", size: 4, type: "vec4" },
                  { name: "sphereTextureColor", size: 4, type: "vec4" },
                  { name: "toonTextureColor", size: 4, type: "vec4" },
                ],
                fragment:
                  "\n#if defined(DIFFUSE) && defined(TEXTURE_COLOR)\nuniform vec4 textureColor;\n#endif\n#if defined(SPHERE_TEXTURE) && defined(SPHERE_TEXTURE_COLOR)\nuniform vec4 sphereTextureColor;\n#endif\n#if defined(TOON_TEXTURE) && defined(TOON_TEXTURE_COLOR)\nuniform vec4 toonTextureColor;\n#endif\n",
              };
            }
            getClassName() {
              return "MmdPluginMaterial";
            }
            _escapeRegExp(e) {
              return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            }
          }
          class te extends $.StandardMaterial {
            _pluginMaterial;
            renderOutline = !1;
            outlineWidth = 0.01;
            outlineColor = new D.Color3(0, 0, 0);
            outlineAlpha = 1;
            constructor(e, t) {
              super(e, t), (this.specularColor = new D.Color3(0, 0, 0));
              const n = (this._pluginMaterial = new ee(this));
              (n.isEnabled = !0), (n.ignoreDiffuseWhenToonTextureIsNull = !0);
            }
            get sphereTexture() {
              return this._pluginMaterial.sphereTexture;
            }
            set sphereTexture(e) {
              this._pluginMaterial.sphereTexture = e;
            }
            get sphereTextureBlendMode() {
              return this._pluginMaterial.sphereTextureBlendMode;
            }
            set sphereTextureBlendMode(e) {
              this._pluginMaterial.sphereTextureBlendMode = e;
            }
            get toonTexture() {
              return this._pluginMaterial.toonTexture;
            }
            set toonTexture(e) {
              this._pluginMaterial.toonTexture = e;
            }
            get ignoreDiffuseWhenToonTextureIsNull() {
              return this._pluginMaterial.ignoreDiffuseWhenToonTextureIsNull;
            }
            set ignoreDiffuseWhenToonTextureIsNull(e) {
              this._pluginMaterial.ignoreDiffuseWhenToonTextureIsNull = e;
            }
            get textureColor() {
              return (this._pluginMaterial.useTextureColor = !0), this._pluginMaterial.textureColor;
            }
            set textureColor(e) {
              (this._pluginMaterial.useTextureColor = !0), (this._pluginMaterial.textureColor = e);
            }
            get sphereTextureColor() {
              return (this._pluginMaterial.useSphereTextureColor = !0), this._pluginMaterial.sphereTextureColor;
            }
            set sphereTextureColor(e) {
              (this._pluginMaterial.useSphereTextureColor = !0), (this._pluginMaterial.sphereTextureColor = e);
            }
            get toonTextureColor() {
              return (this._pluginMaterial.useToonTextureColor = !0), this._pluginMaterial.toonTextureColor;
            }
            set toonTextureColor(e) {
              (this._pluginMaterial.useToonTextureColor = !0), (this._pluginMaterial.toonTextureColor = e);
            }
          }
          class ne {
            files;
            _fileRootId;
            _fileMap = new Map();
            constructor(e, t, n) {
              if (((t = z(t)), (this.files = e), (this._fileRootId = n), 0 !== e.length))
                if (e[0] instanceof File)
                  for (const i of e) {
                    const e = z(i.webkitRelativePath);
                    if (!e.startsWith(t)) continue;
                    const o = n + z(e.slice(t.length));
                    this._fileMap.set(z(o).toUpperCase(), i);
                  }
                else
                  for (const t of e) {
                    const e = n + z(t.relativePath);
                    this._fileMap.set(z(e).toUpperCase(), t);
                  }
            }
            createFullPath(e) {
              return this._fileRootId + z(e);
            }
            resolve(e) {
              const t = z(e);
              return this._fileMap.get(t.toUpperCase());
            }
          }
          var ie,
            oe,
            re = H(6837),
            ae = H(5918);
          !(function (e) {
            (e[(e.Opaque = N.Material.MATERIAL_OPAQUE)] = "Opaque"),
              (e[(e.AlphaTest = N.Material.MATERIAL_ALPHATEST)] = "AlphaTest"),
              (e[(e.AlphaBlend = N.Material.MATERIAL_ALPHABLEND)] = "AlphaBlend");
          })(ie || (ie = {}));
          class se {
            _scene;
            _renderTargetTexture;
            _resultPixelsBuffer;
            constructor(e, t = 512) {
              this._scene = e;
              const n = e.getEngine(),
                i = (this._renderTargetTexture = new ae.RenderTargetTexture("texture_alpha_checker", t, e, {
                  generateDepthBuffer: !1,
                  generateStencilBuffer: !1,
                  generateMipMaps: !1,
                  type: r.Constants.TEXTURETYPE_UNSIGNED_BYTE,
                  format: n.isWebGPU || n.version > 1 ? r.Constants.TEXTUREFORMAT_RED : r.Constants.TEXTUREFORMAT_RGBA,
                  doNotChangeAspectRatio: !0,
                }));
              (i.noPrePassRenderer = !0),
                (i.anisotropicFilteringLevel = 1),
                (i.renderParticles = !1),
                (i.optimizeUVAllocation = !0),
                (i.ignoreCameraViewport = !0),
                (i.clearColor = new D.Color4(0, 0, 0, 1)),
                (this._resultPixelsBuffer = new Uint8Array(t * t * 4));
            }
            _blockRendering = !1;
            _taskQueue = [];
            async textureHasAlphaOnGeometry(e, t, n, i) {
              if (!e.isReady()) throw new Error("Texture is not ready");
              this._blockRendering &&
                (await new Promise((e) => {
                  this._taskQueue.push(e);
                }));
              const o = se._GetShader(this._scene);
              o.setTexture("textureSampler", e);
              const r = this._renderTargetTexture;
              (r.renderList = [t]), r.setMaterialForRendering(t, o);
              const a = t._internalAbstractMeshDataInfo._currentLODIsUpToDate,
                s = t._internalAbstractMeshDataInfo._currentLOD;
              (t._internalAbstractMeshDataInfo._currentLODIsUpToDate = !0),
                (t._internalAbstractMeshDataInfo._currentLOD = t);
              const l = t._nodeDataStorage._isEnabled,
                h = t._nodeDataStorage._isParentEnabled;
              (t._nodeDataStorage._isEnabled = !0),
                (t._nodeDataStorage._isParentEnabled = !0),
                r.render(!1, !1),
                (t._nodeDataStorage._isParentEnabled = h),
                (t._nodeDataStorage._isEnabled = l),
                (t._internalAbstractMeshDataInfo._currentLOD = s),
                (t._internalAbstractMeshDataInfo._currentLODIsUpToDate = a);
              const d = o.getEffect();
              t.geometry._releaseVertexArrayObject(d);
              const c = t.subMeshes;
              for (let e = 0, t = c.length; e < t; ++e) c[e]._removeDrawWrapper(r.renderPassId, !0);
              const m = this._resultPixelsBuffer;
              (this._blockRendering = !0), await r.readPixels(void 0, void 0, m), (this._blockRendering = !1);
              const u = this._taskQueue.shift();
              void 0 !== u && u();
              let p = 0,
                g = 0,
                f = 0;
              const _ = r.getRenderWidth(),
                b = r.getRenderHeight();
              for (let e = 0; e < _; ++e)
                for (let t = 0; t < b; ++t) {
                  const n = m[4 * (e * _ + t)];
                  (p = Math.max(p, n)), 0 < n && n < 255 && ((g += n), (f += 1));
                }
              return 0 !== f && (g /= f), p < n ? ie.Opaque : g + i < p ? ie.AlphaTest : ie.AlphaBlend;
            }
            dispose() {
              this._renderTargetTexture.dispose();
            }
            static _GetShader(e) {
              if (!e._textureAlphaCheckerShader) {
                const t = new re.ShaderMaterial(
                  "textureAlphaCheckerShader",
                  e,
                  {
                    vertexSource:
                      "\nprecision highp float;attribute vec2 uv;varying vec2 vUv;void main() {vUv=uv;gl_Position=vec4(mod(uv,1.0)*2.0-1.0,0.0,1.0);}\n",
                    fragmentSource:
                      "\nprecision highp float;uniform sampler2D textureSampler;varying vec2 vUv;void main() {gl_FragColor=vec4(vec3(1.0)-vec3(texture2D(textureSampler,vUv).a),1.0);}\n",
                  },
                  {
                    needAlphaBlending: !1,
                    needAlphaTesting: !1,
                    attributes: ["uv"],
                    uniforms: [],
                    samplers: ["textureSampler"],
                    shaderLanguage: u.ShaderLanguage.GLSL,
                  }
                );
                (t.backFaceCulling = !1),
                  (t.alphaMode = r.Constants.ALPHA_DISABLE),
                  e.onDisposeObservable.add(() => {
                    e._textureAlphaCheckerShader?.dispose(), (e._textureAlphaCheckerShader = null);
                  }),
                  (e._textureAlphaCheckerShader = t);
              }
              return e._textureAlphaCheckerShader;
            }
            static DisposeShader(e) {
              e._textureAlphaCheckerShader?.dispose(), (e._textureAlphaCheckerShader = null);
            }
          }
          class le {
            alphaThreshold = 195;
            alphaBlendThreshold = 100;
            useAlphaEvaluation = !0;
            alphaEvaluationResolution = 512;
            deleteTextureBufferAfterLoad = !0;
            _textureLoader = new Q();
            buildMaterials(e, t, n, i, o, r, a, s, l, h, d, c, m, u) {
              const p = s.blockMaterialDirtyMechanism;
              s._forceBlockMaterialDirtyMechanism(!0);
              let g = null;
              const f = () =>
                  null !== g ? g : this.useAlphaEvaluation ? (g = new se(s, this.alphaEvaluationResolution)) : null,
                _ = new ne(r, i, o),
                b = [],
                y = { lengthComputable: !0, loaded: 0, total: 3 * t.length },
                A = () => {
                  (y.loaded += 1), m?.(y);
                },
                M = [];
              for (let o = 0; o < t.length; ++o) {
                const r = t[o];
                s._blockEntityCollection = !!l;
                const d = new te(r.name, s);
                (d._parentContainer = l), (s._blockEntityCollection = !1), l?.materials.push(d);
                {
                  const t = [],
                    m = this.loadGeneralScalarProperties(d, r);
                  void 0 !== m && t.push(m);
                  const u = this.loadDiffuseTexture(e, d, r, n, a[r.textureIndex] ?? null, s, l, i, _, h[o], c, f, A);
                  void 0 !== u && t.push(u);
                  const p = this.loadSphereTexture(e, d, r, n, a[r.sphereTextureIndex] ?? null, s, l, i, _, c, A);
                  void 0 !== p && t.push(p);
                  const g = this.loadToonTexture(e, d, r, n, a[r.toonTextureIndex] ?? null, s, l, i, _, c, A);
                  void 0 !== g && t.push(g);
                  const y = this.loadOutlineRenderingProperties(d, r, c);
                  void 0 !== y && t.push(y),
                    b.push(...t),
                    Promise.all(t).then(() => {
                      this.afterBuildSingleMaterial(d, o, r, n, a, s, i);
                    });
                }
                M.push(d);
              }
              this._textureLoader.loadModelTexturesEnd(e);
              const T = this._textureLoader.onModelTextureLoadedObservable.get(e);
              return (
                void 0 !== T
                  ? T.addOnce(() => {
                      Promise.all(b).then(() => {
                        g?.dispose(),
                          s._forceBlockMaterialDirtyMechanism(p),
                          null !== d && this._buildTextureNameMap(t, M, n, a, d),
                          u?.();
                      });
                    })
                  : Promise.all(b).then(() => {
                      g?.dispose(),
                        s._forceBlockMaterialDirtyMechanism(p),
                        null !== d && this._buildTextureNameMap(t, M, n, a, d),
                        u?.();
                    }),
                M
              );
            }
            _buildTextureNameMap(e, t, n, i, o) {
              for (let r = 0; r < e.length; ++r) {
                const a = e[r],
                  s = t[r],
                  l = n[i[a.textureIndex]?.imagePathIndex];
                if (void 0 !== l) {
                  const e = s.diffuseTexture;
                  null !== e && o.set(e, l);
                }
                const h = n[i[a.sphereTextureIndex]?.imagePathIndex];
                if (void 0 !== h) {
                  const e = s.sphereTexture;
                  null !== e && o.set(e, h);
                }
                const d = n[i[a.toonTextureIndex]?.imagePathIndex];
                if (void 0 !== d) {
                  const e = s.toonTexture;
                  null !== e && o.set(e, d);
                }
              }
            }
            loadGeneralScalarProperties = (e, t) => {
              const n = t.diffuse;
              e.diffuseColor = new D.Color3(n[0], n[1], n[2]);
              const i = t.specular;
              e.specularColor = new D.Color3(i[0], i[1], i[2]);
              const o = t.ambient;
              e.ambientColor = new D.Color3(o[0], o[1], o[2]);
              const r = t.diffuse[3];
              (e.alpha = r), (e.specularPower = t.shininess);
            };
            loadDiffuseTexture = async (e, t, n, i, o, r, a, s, l, h, d, c, m) => {
              t.backFaceCulling = !(n.flag & y.Material.Flag.IsDoubleSided);
              const u = i[o?.imagePathIndex ?? -1];
              if (void 0 !== u) {
                const i = l.createFullPath(u);
                let p;
                const g = l.resolve(i);
                p =
                  void 0 !== g
                    ? await this._textureLoader.loadTextureFromBufferAsync(e, i, g instanceof File ? g : g.data, r, a, {
                        ...o,
                        deleteBuffer: this.deleteTextureBufferAfterLoad,
                        mimeType: g instanceof File ? g.type : g.mimeType,
                      })
                    : await this._textureLoader.loadTextureAsync(e, s, u, r, a, {
                        ...o,
                        deleteBuffer: this.deleteTextureBufferAfterLoad,
                      });
                const f = p;
                if (null !== f) {
                  t.diffuseTexture = f;
                  let e = Number.MAX_SAFE_INTEGER;
                  const i = n.evauatedTransparency;
                  if (void 0 !== i && -1 !== i) e = i;
                  else {
                    const t = c();
                    null !== t &&
                      (e = await t.textureHasAlphaOnGeometry(f, h, this.alphaThreshold, this.alphaBlendThreshold));
                  }
                  if (e !== Number.MAX_SAFE_INTEGER) {
                    const n = e !== N.Material.MATERIAL_OPAQUE;
                    n && (f.hasAlpha = !0),
                      (t.useAlphaFromDiffuseTexture = n),
                      (t.transparencyMode = e),
                      n && (t.backFaceCulling = !1);
                  }
                  m?.();
                } else d.error(`Failed to load diffuse texture: ${i}`), m?.();
              } else m?.();
            };
            loadSphereTexture = async (e, t, n, i, o, r, a, s, l, h, d) => {
              if (n.sphereTextureMode !== y.Material.SphereTextureMode.Off) {
                const c = i[o?.imagePathIndex ?? -1];
                if (void 0 !== c) {
                  const i = l.createFullPath(c);
                  let m;
                  const u = l.resolve(i);
                  (m =
                    void 0 !== u
                      ? await this._textureLoader.loadTextureFromBufferAsync(
                          e,
                          i,
                          u instanceof File ? u : u.data,
                          r,
                          a,
                          {
                            ...o,
                            deleteBuffer: this.deleteTextureBufferAfterLoad,
                            mimeType: u instanceof File ? u.type : u.mimeType,
                          }
                        )
                      : await this._textureLoader.loadTextureAsync(e, s, c, r, a, {
                          ...o,
                          deleteBuffer: this.deleteTextureBufferAfterLoad,
                        })),
                    null !== m
                      ? ((t.sphereTexture = m), (t.sphereTextureBlendMode = n.sphereTextureMode))
                      : h.error(`Failed to load sphere texture: ${i}`),
                    d?.();
                } else d?.();
              } else d?.();
            };
            loadToonTexture = async (e, t, n, i, o, r, a, s, l, h, d) => {
              let c;
              if (((c = n.isSharedToonTexture ? n.toonTextureIndex : i[o?.imagePathIndex ?? -1]), void 0 !== c)) {
                const n = l.createFullPath(c.toString());
                let i;
                const m = "string" == typeof c ? l.resolve(n) : void 0;
                (i =
                  void 0 !== m
                    ? await this._textureLoader.loadTextureFromBufferAsync(e, n, m instanceof File ? m : m.data, r, a, {
                        ...o,
                        deleteBuffer: this.deleteTextureBufferAfterLoad,
                        mimeType: m instanceof File ? m.type : m.mimeType,
                      })
                    : await this._textureLoader.loadTextureAsync(e, s, c, r, a, {
                        ...o,
                        deleteBuffer: this.deleteTextureBufferAfterLoad,
                      })),
                  null !== i ? (t.toonTexture = i) : h.error(`Failed to load toon texture: ${n}`),
                  d?.();
              } else d?.();
            };
            loadOutlineRenderingProperties = (e, t, n) => {
              if (t.flag & y.Material.Flag.EnabledToonEdge) {
                void 0 === d.Scene.prototype.getMmdOutlineRenderer &&
                  n.warn(
                    'MMD Outline Renderer is not available. Please import "babylon-mmd/esm/Loader/mmdOutlineRenderer".'
                  ),
                  (e.renderOutline = !0),
                  (e.outlineWidth = t.edgeSize);
                const i = t.edgeColor;
                (e.outlineColor = new D.Color3(i[0], i[1], i[2])), (e.outlineAlpha = i[3]);
              }
            };
            afterBuildSingleMaterial = () => {};
          }
          class he {
            lengthComputable;
            total;
            _onProgress;
            _unprocessedTasks;
            _processingTasks;
            _endedTaskNames;
            _endedTasksTotal;
            constructor(e, t, n) {
              this.lengthComputable = e;
              let i = 0;
              for (let e = 0; e < t.length; ++e) i += t[e].cost;
              (this.total = i), (this._onProgress = n);
              const o = (this._unprocessedTasks = new Map());
              for (let e = 0; e < t.length; ++e) {
                if (o.has(t[e].name)) throw new Error(`Duplicated task name: ${t[e].name}`);
                o.set(t[e].name, t[e]);
              }
              (this._processingTasks = new Map()), (this._endedTaskNames = new Set()), (this._endedTasksTotal = 0);
            }
            _getTaskState(e) {
              let t = this._processingTasks.get(e);
              if (void 0 === t) {
                const n = this._unprocessedTasks.get(e);
                if (void 0 === n) {
                  if (this._endedTaskNames.has(e)) return null;
                  throw new Error(`Task not found: ${e}`);
                }
                (t = { name: n.name, cost: n.cost, progress: 0 }),
                  this._processingTasks.set(e, t),
                  this._unprocessedTasks.delete(e);
              }
              return t;
            }
            processTask(e, t) {
              const n = this._getTaskState(e);
              null !== n &&
                ((n.progress += t),
                n.progress >= n.cost &&
                  (this._processingTasks.delete(e), this._endedTaskNames.add(e), (this._endedTasksTotal += n.cost)));
            }
            setTaskProgress(e, t) {
              const n = this._getTaskState(e);
              return (
                null !== n &&
                ((n.progress = t),
                n.progress >= n.cost &&
                  (this._processingTasks.delete(e), this._endedTaskNames.add(e), (this._endedTasksTotal += n.cost)),
                !0)
              );
            }
            setTaskProgressRatio(e, t, n) {
              const i = this._getTaskState(e);
              return (
                null !== i &&
                ((i.progress = n ? Math.floor(i.cost * t) : i.cost * t),
                i.progress >= i.cost &&
                  (this._processingTasks.delete(e), this._endedTaskNames.add(e), (this._endedTasksTotal += i.cost)),
                !0)
              );
            }
            endTask(e) {
              const t = this._getTaskState(e);
              null !== t &&
                (this._processingTasks.delete(e), this._endedTaskNames.add(e), (this._endedTasksTotal += t.cost));
            }
            invokeProgressEvent() {
              null !== this._onProgress &&
                this._onProgress({ lengthComputable: this.lengthComputable, loaded: this.loaded, total: this.total });
            }
            get loaded() {
              let e = this._endedTasksTotal;
              for (const [t, n] of this._processingTasks) e += n.progress;
              return e;
            }
          }
          class de {
            name;
            extensions;
            materialBuilder;
            useSdef;
            buildSkeleton;
            buildMorph;
            boundingBoxMargin;
            preserveSerializationData;
            _loggingEnabled;
            log;
            warn;
            error;
            constructor(e, t) {
              (this.name = e),
                (this.extensions = t),
                (this.materialBuilder = new le()),
                (this.useSdef = !0),
                (this.buildSkeleton = !0),
                (this.buildMorph = !0),
                (this.boundingBoxMargin = 10),
                (this.preserveSerializationData = !1),
                (this._loggingEnabled = !1),
                (this.log = this._logDisabled),
                (this.warn = this._warnDisabled),
                (this.error = this._errorDisabled);
            }
            importMeshAsync(e, t, n, i, o, r) {
              return this._loadAsyncInternal(t, null, n, i, o);
            }
            loadAsync(e, t, n, i, o) {
              return this._loadAsyncInternal(e, null, t, n, i).then(() => {});
            }
            loadAssetContainerAsync(e, t, n, i, o) {
              const r = new F.AssetContainer(e);
              return this._loadAsyncInternal(e, r, t, n, i).then(() => r);
            }
            async _loadAsyncInternal(e, t, n, i, o) {
              const r = await this._parseFileAsync(n.arrayBuffer),
                a = new he(!0, this._getProgressTaskCosts(n, r), o ?? null);
              a.endTask("Parse"), a.invokeProgressEvent(), (e._blockEntityCollection = !!t);
              const s = new I.Mesh(r.header.modelName, e);
              (s._parentContainer = t), (e._blockEntityCollection = !1), s.setEnabled(!1);
              const l = await this._buildGeometryAsync(n, r, s, e, t, a),
                h = n.preserveSerializationData ? new Map() : null,
                { materials: d, textureLoadPromise: c } = await this._buildMaterialAsync(
                  n,
                  r,
                  s,
                  l.meshes,
                  h,
                  e,
                  t,
                  i,
                  a
                ),
                m = [];
              let u = null;
              n.buildSkeleton
                ? (u = await this._buildSkeletonAsync(n, r, l.meshes, e, t, m, a))
                : a.endTask("Build Skeleton");
              const p = [];
              let g = null;
              if (
                (n.buildMorph && (g = await this._buildMorphAsync(n, r, l, e, t, p, a)),
                0 !== n.boundingBoxMargin && this._applyBoundingBoxMargin(l.meshes, n.boundingBoxMargin),
                (s.metadata = {
                  isMmdModel: !0,
                  header: {
                    modelName: r.header.modelName,
                    englishModelName: r.header.englishModelName,
                    comment: r.header.comment,
                    englishComment: r.header.englishComment,
                  },
                  bones: m,
                  morphs: p,
                  rigidBodies: r.rigidBodies,
                  joints: r.joints,
                  meshes: l.meshes,
                  materials: d,
                  skeleton: u,
                }),
                n.preserveSerializationData)
              ) {
                const e = [],
                  t = r.materials;
                for (let n = 0; n < t.length; ++n) {
                  const i = t[n];
                  e.push({
                    englishName: i.englishName,
                    comment: i.comment,
                    isDoubleSided: 0 != (i.flag & y.Material.Flag.IsDoubleSided),
                  });
                }
                s.metadata = {
                  ...s.metadata,
                  containsSerializationData: !0,
                  textureNameMap: h,
                  materialsMetadata: e,
                  displayFrames: r.displayFrames,
                };
              }
              return (
                a.invokeProgressEvent(),
                await c,
                a.endTask("Texture Load"),
                a.invokeProgressEvent(),
                s.setEnabled(!0),
                null !== t &&
                  (t.rootNodes.push(s),
                  t.meshes.push(s, ...l.meshes),
                  t.geometries.push(...l.geometries),
                  t.materials.push(...d),
                  null !== u && t.skeletons.push(u),
                  null !== g && t.morphTargetManagers.push(...g)),
                {
                  meshes: [s, ...l.meshes],
                  particleSystems: [],
                  skeletons: null !== u ? [u] : [],
                  animationGroups: [],
                  transformNodes: [],
                  geometries: l.geometries,
                  lights: [],
                  spriteManagers: [],
                }
              );
            }
            _getProgressTaskCosts(e, t) {
              return [
                { name: "Parse", cost: Math.floor(e.arrayBuffer.byteLength / 100) },
                { name: "Build Material", cost: 100 * t.materials.length },
                { name: "Build Skeleton", cost: e.buildSkeleton ? 100 * t.bones.length : 0 },
                { name: "Texture Load", cost: 3e4 * t.textures.length },
              ];
            }
            async _buildSkeletonAsync(e, t, n, i, o, r, a) {
              const s = e.preserveSerializationData;
              i._blockEntityCollection = !!o;
              const l = new S.Skeleton(t.header.modelName, t.header.modelName + "_skeleton", i);
              (l._parentContainer = o), (i._blockEntityCollection = !1);
              {
                const e = t.bones,
                  n = [],
                  i = [];
                for (let t = 0; t < e.length; ++t) {
                  const o = e[t];
                  let a = !1;
                  if (0 <= o.parentBoneIndex && o.parentBoneIndex < e.length) {
                    let n = o.parentBoneIndex;
                    for (; -1 !== n; ) {
                      if (n === t) {
                        (a = !0), this.warn(`Bone loop detected. Ignore Parenting. Bone index: ${t}`);
                        break;
                      }
                      n = e[n].parentBoneIndex;
                    }
                    t <= o.parentBoneIndex &&
                      this.warn(
                        `Parent bone index is greater equal than child bone index. Bone index: ${t} Parent bone index: ${o.parentBoneIndex}`
                      );
                  } else
                    -1 !== o.parentBoneIndex &&
                      this.error(
                        `Parent bone index is out of range. Bone index: ${t} Parent bone index: ${o.parentBoneIndex}`
                      );
                  const h = o.position,
                    d = new E.Vector3(h[0], h[1], h[2]);
                  if (0 <= o.parentBoneIndex && o.parentBoneIndex < e.length && !a) {
                    const t = e[o.parentBoneIndex];
                    (d.x -= t.position[0]), (d.y -= t.position[1]), (d.z -= t.position[2]);
                  }
                  const c = E.Matrix.Identity().setTranslation(d),
                    m = new R.Bone(o.name, l, void 0, c, void 0, void 0, t);
                  n.push(m), i.push(a);
                  const u = {
                    name: o.name,
                    englishName: o.englishName,
                    parentBoneIndex: o.parentBoneIndex,
                    transformOrder: o.transformOrder,
                    flag: o.flag,
                    appendTransform: o.appendTransform,
                    ik: o.ik,
                    ...(s
                      ? {
                          tailPosition: o.tailPosition,
                          axisLimit: o.axisLimit,
                          localVector: o.localVector,
                          externalParentTransform: o.externalParentTransform,
                        }
                      : void 0),
                  };
                  r.push(u);
                }
                for (let t = 0; t < n.length; ++t) {
                  const o = e[t],
                    r = n[t];
                  0 <= o.parentBoneIndex &&
                    o.parentBoneIndex < n.length &&
                    !i[t] &&
                    r.setParent(n[o.parentBoneIndex], !1);
                }
                for (let e = 0; e < n.length; ++e) {
                  const t = n[e];
                  null === t.getParent() && t._updateAbsoluteBindMatrices();
                }
              }
              a.endTask("Build Skeleton"), a.invokeProgressEvent();
              for (let e = 0; e < n.length; ++e) n[e].skeleton = l;
              return l;
            }
            _applyBoundingBoxMargin(e, t) {
              for (let n = 0; n < e.length; ++n) {
                const i = e[n];
                if (void 0 === i.subMeshes) continue;
                const o = i.subMeshes;
                for (let e = 0; e < o.length; ++e) {
                  const n = o[e],
                    i = n.getBoundingInfo();
                  n.setBoundingInfo(
                    new C.BoundingInfo(
                      new E.Vector3().setAll(-t).addInPlace(i.minimum),
                      new E.Vector3().setAll(t).addInPlace(i.maximum)
                    )
                  );
                }
                const r = i.getBoundingInfo();
                i.setBoundingInfo(
                  new C.BoundingInfo(
                    new E.Vector3().setAll(-t).addInPlace(r.minimum),
                    new E.Vector3().setAll(t).addInPlace(r.maximum)
                  )
                ),
                  i._updateBoundingInfo();
              }
            }
            get loggingEnabled() {
              return this._loggingEnabled;
            }
            set loggingEnabled(e) {
              (this._loggingEnabled = e),
                e
                  ? ((this.log = this._logEnabled), (this.warn = this._warnEnabled), (this.error = this._errorEnabled))
                  : ((this.log = this._logDisabled),
                    (this.warn = this._warnDisabled),
                    (this.error = this._errorDisabled));
            }
            _logEnabled(e) {
              k.Logger.Log(e);
            }
            _logDisabled() {}
            _warnEnabled(e) {
              k.Logger.Warn(e);
            }
            _warnDisabled() {}
            _errorEnabled(e) {
              k.Logger.Error(e);
            }
            _errorDisabled() {}
          }
          class ce {
            static _IdMap = new WeakMap();
            static _NextId = 0;
            constructor() {}
            static GetId(e) {
              let t = this._IdMap.get(e);
              return void 0 === t && ((t = this._NextId), (this._NextId += 1), this._IdMap.set(e, t)), t;
            }
          }
          class me extends I.Mesh {
            applySkeleton(e) {
              if (!this.geometry) return this;
              if (this.geometry._softwareSkinningFrameId === this.getScene().getFrameId()) return this;
              if (
                ((this.geometry._softwareSkinningFrameId = this.getScene().getFrameId()),
                !this.isVerticesDataPresent(o.VertexBuffer.PositionKind))
              )
                return this;
              if (!this.isVerticesDataPresent(o.VertexBuffer.MatricesIndicesKind)) return this;
              if (!this.isVerticesDataPresent(o.VertexBuffer.MatricesWeightsKind)) return this;
              const t = this.isVerticesDataPresent(o.VertexBuffer.NormalKind),
                n = this._internalMeshDataInfo;
              if (!n._sourcePositions) {
                const e = this.subMeshes.slice();
                this.setPositionsForCPUSkinning(), (this.subMeshes = e);
              }
              t && !n._sourceNormals && this.setNormalsForCPUSkinning();
              let i = this.getVerticesData(o.VertexBuffer.PositionKind);
              if (!i) return this;
              i instanceof Float32Array || (i = new Float32Array(i));
              let r = this.getVerticesData(o.VertexBuffer.NormalKind);
              if (t) {
                if (!r) return this;
                r instanceof Float32Array || (r = new Float32Array(r));
              }
              const a = this.isVerticesDataPresent(m.MatricesSdefCKind);
              let s = null,
                l = null,
                h = null;
              a &&
                ((s = this.getVerticesData(m.MatricesSdefCKind)),
                (l = this.getVerticesData(m.MatricesSdefR0Kind)),
                (h = this.getVerticesData(m.MatricesSdefR1Kind)));
              const d = this.getVerticesData(o.VertexBuffer.MatricesIndicesKind),
                c = this.getVerticesData(o.VertexBuffer.MatricesWeightsKind);
              if (!c || !d) return this;
              const u = this.numBoneInfluencers > 4,
                p = u ? this.getVerticesData(o.VertexBuffer.MatricesIndicesExtraKind) : null,
                g = u ? this.getVerticesData(o.VertexBuffer.MatricesWeightsExtraKind) : null,
                f = e.getTransformMatrices(this),
                _ = E.Vector3.Zero(),
                b = new E.Matrix(),
                y = new E.Matrix(),
                A = new E.Matrix(),
                M = new E.Matrix(),
                T = new E.Quaternion(),
                w = new E.Quaternion(),
                x = new E.Vector3(),
                I = n._sourcePositions,
                v = n._sourceNormals;
              let B,
                P = 0;
              for (let e = 0; e < i.length; e += 3, P += 4) {
                let n = 0;
                if ((a && (n = l[e]), 0 === n)) {
                  let n;
                  for (B = 0; B < 4; B++)
                    (n = c[P + B]),
                      n > 0 &&
                        (E.Matrix.FromFloat32ArrayToRefScaled(f, Math.floor(16 * d[P + B]), n, y), b.addToSelf(y));
                  if (u)
                    for (B = 0; B < 4; B++)
                      (n = g[P + B]),
                        n > 0 &&
                          (E.Matrix.FromFloat32ArrayToRefScaled(f, Math.floor(16 * p[P + B]), n, y), b.addToSelf(y));
                  E.Vector3.TransformCoordinatesFromFloatsToRef(I[e], I[e + 1], I[e + 2], b, _),
                    _.toArray(i, e),
                    t && (E.Vector3.TransformNormalFromFloatsToRef(v[e], v[e + 1], v[e + 2], b, _), _.toArray(r, e)),
                    b.reset();
                } else {
                  const n = c[P + 0],
                    o = c[P + 1];
                  E.Matrix.FromArrayToRef(f, Math.floor(16 * d[P + 0]), A),
                    E.Matrix.FromArrayToRef(f, Math.floor(16 * d[P + 1]), M),
                    E.Quaternion.FromRotationMatrixToRef(A, T),
                    E.Quaternion.FromRotationMatrixToRef(M, w),
                    E.Matrix.FromQuaternionToRef(E.Quaternion.SlerpToRef(T, w, o, T), y),
                    E.Vector3.TransformCoordinatesFromFloatsToRef(
                      I[e] - s[e],
                      I[e + 1] - s[e + 1],
                      I[e + 2] - s[e + 2],
                      y,
                      x
                    ),
                    E.Vector3.TransformCoordinatesFromFloatsToRef(l[e], l[e + 1], l[e + 2], A, _).scaleAndAddToRef(
                      n,
                      x
                    ),
                    E.Vector3.TransformCoordinatesFromFloatsToRef(h[e], h[e + 1], h[e + 2], M, _).scaleAndAddToRef(
                      o,
                      x
                    ),
                    x.toArray(i, e),
                    t && (E.Vector3.TransformNormalFromFloatsToRef(v[e], v[e + 1], v[e + 2], y, x), x.toArray(r, e));
                }
              }
              return (
                this.updateVerticesData(o.VertexBuffer.PositionKind, i),
                t && this.updateVerticesData(o.VertexBuffer.NormalKind, r),
                this
              );
            }
          }
          class ue extends de {
            referenceFiles;
            constructor(e, t) {
              super(e, t), (this.referenceFiles = []);
            }
            loadFile(e, t, n, i, o, r, a) {
              const s = this.materialBuilder,
                l = this.useSdef,
                h = this.buildSkeleton,
                d = this.buildMorph,
                c = this.boundingBoxMargin,
                m = this.referenceFiles,
                u = this.preserveSerializationData;
              return e._loadFile(
                t,
                (e, n) => {
                  const o = {
                    arrayBuffer: e,
                    pmFileId: t instanceof File ? ce.GetId(t).toString() : t,
                    materialBuilder: s,
                    useSdef: l,
                    buildSkeleton: h,
                    buildMorph: d,
                    boundingBoxMargin: c,
                    referenceFiles: m,
                    preserveSerializationData: u,
                  };
                  i(o, n);
                },
                o,
                !0,
                r,
                a
              );
            }
            _getProgressTaskCosts(e, t) {
              const n = super._getProgressTaskCosts(e, t);
              if ((n.push({ name: "Build Geometry", cost: t.indices.length }), e.buildMorph)) {
                let e = 0;
                const i = t.morphs;
                for (let t = 0; t < i.length; ++t) {
                  const n = i[t];
                  (n.type !== y.Morph.Type.VertexMorph &&
                    n.type !== y.Morph.Type.UvMorph &&
                    n.type !== y.Morph.Type.AdditionalUvMorph1 &&
                    n.type !== y.Morph.Type.AdditionalUvMorph2 &&
                    n.type !== y.Morph.Type.AdditionalUvMorph3 &&
                    n.type !== y.Morph.Type.AdditionalUvMorph4) ||
                    (e += n.indices.length);
                }
                n.push({ name: "Build Morph", cost: e });
              }
              return n;
            }
            async _buildGeometryAsync(e, t, n, i, o, r) {
              const a = [],
                s = [];
              let l;
              const h = [];
              {
                l =
                  t.indices instanceof Uint8Array || t.indices instanceof Uint16Array
                    ? new Uint16Array(t.indices.length)
                    : new Uint32Array(t.indices.length);
                {
                  const e = t.indices;
                  for (let t = 0; t < l.length; t += 3)
                    (l[t + 0] = e[t + 0]), (l[t + 1] = e[t + 2]), (l[t + 2] = e[t + 1]);
                }
                const d = t.materials;
                let c = 0;
                for (let u = 0; u < d.length; ++u) {
                  const p = d[u],
                    g = new Uint8Array(t.vertices.length);
                  let f = 0;
                  {
                    const e = p.indexCount;
                    for (let t = 0; t < e; ++t) {
                      const e = l[c + t];
                      0 === g[e] && ((g[e] = 1), (f += 1));
                    }
                    g.fill(0);
                  }
                  const _ = new v.VertexData(),
                    b = [];
                  if (e.preserveSerializationData)
                    for (let e = 0; e < t.header.additionalVec4Count; ++e) b.push(new Float32Array(4 * f));
                  let A = null,
                    M = null,
                    T = null;
                  e.buildSkeleton &&
                    e.useSdef &&
                    ((A = new Float32Array(3 * f)), (M = new Float32Array(3 * f)), (T = new Float32Array(3 * f)));
                  let w = !1,
                    P = null;
                  e.preserveSerializationData && (P = new Float32Array(f));
                  const O = new t.indices.constructor(t.vertices.length);
                  {
                    const n = new Float32Array(3 * f),
                      i = new Float32Array(3 * f),
                      o = new Float32Array(2 * f),
                      a = new l.constructor(p.indexCount);
                    let s = null,
                      h = null;
                    e.buildSkeleton && ((s = new Float32Array(4 * f)), (h = new Float32Array(4 * f)));
                    let d = performance.now(),
                      m = 0,
                      u = 0;
                    const x = p.indexCount;
                    for (let p = 0; p < x; ++p) {
                      const f = l[c + p];
                      if (0 === g[f]) {
                        g[f] = 1;
                        const r = t.vertices[f];
                        (n[3 * m + 0] = r.position[0]),
                          (n[3 * m + 1] = r.position[1]),
                          (n[3 * m + 2] = r.position[2]),
                          (i[3 * m + 0] = r.normal[0]),
                          (i[3 * m + 1] = r.normal[1]),
                          (i[3 * m + 2] = r.normal[2]),
                          (o[2 * m + 0] = r.uv[0]),
                          (o[2 * m + 1] = 1 - r.uv[1]);
                        const l = r.additionalVec4;
                        for (let e = 0; e < b.length; ++e)
                          (b[e][4 * m + 0] = l[e][0]),
                            (b[e][4 * m + 1] = l[e][1]),
                            (b[e][4 * m + 2] = l[e][2]),
                            (b[e][4 * m + 3] = l[e][3]);
                        if (e.buildSkeleton)
                          switch (r.weightType) {
                            case y.Vertex.BoneWeightType.Bdef1:
                              {
                                const e = r.boneWeight;
                                (s[4 * m + 0] = e.boneIndices),
                                  (s[4 * m + 1] = 0),
                                  (s[4 * m + 2] = 0),
                                  (s[4 * m + 3] = 0),
                                  (h[4 * m + 0] = 1),
                                  (h[4 * m + 1] = 0),
                                  (h[4 * m + 2] = 0),
                                  (h[4 * m + 3] = 0);
                              }
                              break;
                            case y.Vertex.BoneWeightType.Bdef2:
                              {
                                const e = r.boneWeight;
                                (s[4 * m + 0] = e.boneIndices[0]),
                                  (s[4 * m + 1] = e.boneIndices[1]),
                                  (s[4 * m + 2] = 0),
                                  (s[4 * m + 3] = 0),
                                  (h[4 * m + 0] = e.boneWeights),
                                  (h[4 * m + 1] = 1 - e.boneWeights),
                                  (h[4 * m + 2] = 0),
                                  (h[4 * m + 3] = 0);
                              }
                              break;
                            case y.Vertex.BoneWeightType.Bdef4:
                            case y.Vertex.BoneWeightType.Qdef:
                              {
                                const e = r.boneWeight;
                                (s[4 * m + 0] = e.boneIndices[0]),
                                  (s[4 * m + 1] = e.boneIndices[1]),
                                  (s[4 * m + 2] = e.boneIndices[2]),
                                  (s[4 * m + 3] = e.boneIndices[3]),
                                  (h[4 * m + 0] = e.boneWeights[0]),
                                  (h[4 * m + 1] = e.boneWeights[1]),
                                  (h[4 * m + 2] = e.boneWeights[2]),
                                  (h[4 * m + 3] = e.boneWeights[3]);
                              }
                              break;
                            case y.Vertex.BoneWeightType.Sdef: {
                              const t = r.boneWeight;
                              (s[4 * m + 0] = t.boneIndices[0]),
                                (s[4 * m + 1] = t.boneIndices[1]),
                                (s[4 * m + 2] = 0),
                                (s[4 * m + 3] = 0);
                              const n = t.boneWeights,
                                i = n.boneWeight0,
                                o = 1 - i;
                              if (
                                ((h[4 * m + 0] = i),
                                (h[4 * m + 1] = o),
                                (h[4 * m + 2] = 0),
                                (h[4 * m + 3] = 0),
                                e.useSdef)
                              ) {
                                const e = n.c[0],
                                  t = n.c[1],
                                  r = n.c[2];
                                let a = n.r0[0],
                                  s = n.r0[1],
                                  l = n.r0[2],
                                  h = n.r1[0],
                                  d = n.r1[1],
                                  c = n.r1[2];
                                const u = a * i + h * o,
                                  p = s * i + d * o,
                                  g = l * i + c * o;
                                (a = e + a - u),
                                  (s = t + s - p),
                                  (l = r + l - g),
                                  (h = e + h - u),
                                  (d = t + d - p),
                                  (c = r + c - g);
                                const f = 0.5 * (e + a),
                                  _ = 0.5 * (t + s),
                                  b = 0.5 * (r + l),
                                  y = 0.5 * (e + h),
                                  x = 0.5 * (t + d),
                                  I = 0.5 * (r + c);
                                (A[3 * m + 0] = e),
                                  (A[3 * m + 1] = t),
                                  (A[3 * m + 2] = r),
                                  (M[3 * m + 0] = f),
                                  (M[3 * m + 1] = _),
                                  (M[3 * m + 2] = b),
                                  (T[3 * m + 0] = y),
                                  (T[3 * m + 1] = x),
                                  (T[3 * m + 2] = I),
                                  (w = !0);
                              }
                            }
                          }
                        e.preserveSerializationData && (P[m] = r.edgeScale), (a[u] = m), (O[f] = m), (u += 1), (m += 1);
                      } else (a[u] = O[f]), (u += 1);
                      (c + p) % 1e4 == 0 &&
                        100 < performance.now() - d &&
                        (r.setTaskProgress("Build Geometry", c + p),
                        r.invokeProgressEvent(),
                        await B.Tools.DelayAsync(0),
                        (d = performance.now()));
                    }
                    (_.positions = n),
                      (_.normals = i),
                      (_.uvs = o),
                      (_.indices = a),
                      (_.matricesIndices = s),
                      (_.matricesWeights = h);
                  }
                  i._blockEntityCollection = !!o;
                  const F = new (e.useSdef && w ? me : I.Mesh)(p.name, i);
                  (F._parentContainer = o),
                    (i._blockEntityCollection = !1),
                    F.setParent(n),
                    a.push(F),
                    (i._blockEntityCollection = !!o);
                  const R = new x.Geometry(t.header.modelName, i, _, !1);
                  (R._parentContainer = o),
                    (i._blockEntityCollection = !1),
                    e.preserveSerializationData &&
                      (1 <= b.length && R.setVerticesData(m.AdditionalUV1Kind, b[0], !1, 4),
                      2 <= b.length && R.setVerticesData(m.AdditionalUV2Kind, b[1], !1, 4),
                      3 <= b.length && R.setVerticesData(m.AdditionalUV3Kind, b[2], !1, 4),
                      4 <= b.length && R.setVerticesData(m.AdditionalUV4Kind, b[3], !1, 4)),
                    e.useSdef &&
                      w &&
                      (R.setVerticesData(m.MatricesSdefCKind, A, !1, 3),
                      R.setVerticesData(m.MatricesSdefR0Kind, M, !1, 3),
                      R.setVerticesData(m.MatricesSdefR1Kind, T, !1, 3)),
                    e.preserveSerializationData && R.setVerticesData(m.EdgeScaleKind, P, !1, 1),
                    R.applyToMesh(F),
                    s.push(R),
                    h.push({ map: O, isReferencedVertex: g }),
                    (c += p.indexCount);
                }
              }
              return (
                r.endTask("Build Geometry"),
                r.invokeProgressEvent(),
                { meshes: a, geometries: s, indices: l, indexToSubmehIndexMaps: h }
              );
            }
            async _buildMaterialAsync(e, t, n, i, o, r, a, s, l) {
              let h;
              const d = new Array(t.textures.length);
              for (let e = 0; e < d.length; ++e)
                d[e] = { noMipmap: !1, invertY: !0, samplingMode: void 0, imagePathIndex: e };
              const c = new Promise((c) => {
                  h = e.materialBuilder.buildMaterials(
                    n.uniqueId,
                    t.materials,
                    t.textures,
                    s,
                    "file:" + e.pmFileId + "_",
                    e.referenceFiles,
                    d,
                    r,
                    a,
                    i,
                    o,
                    this,
                    (e) => {
                      e.lengthComputable &&
                        (l.setTaskProgressRatio("Texture Load", e.loaded / e.total, !0), l.invokeProgressEvent());
                    },
                    () => c()
                  );
                }),
                m = Array.isArray(h) ? h : await h;
              for (let e = 0; e < m.length; ++e) i[e].material = m[e];
              return l.endTask("Build Material"), l.invokeProgressEvent(), { materials: m, textureLoadPromise: c };
            }
            async _buildMorphAsync(e, t, n, i, r, a, s) {
              const l = e.preserveSerializationData,
                h = new Int32Array(t.vertices.length).fill(-1),
                d = new Map(),
                c = n.indices;
              {
                const e = t.materials;
                let n = 0;
                for (let t = 0; t < e.length; ++t) {
                  const i = e[t].indexCount;
                  for (let e = 0; e < i; ++e) {
                    const i = c[n + e];
                    if (-1 === h[i]) h[i] = t;
                    else if (-2 === h[i]) {
                      const e = d.get(i);
                      e.includes(t) || e.push(t);
                    } else h[i] !== t && (d.set(i, [h[i], t]), (h[i] = -2));
                  }
                  n += i;
                }
              }
              const m = n.indexToSubmehIndexMaps,
                u = t.morphs,
                p = n.geometries,
                g = new Array(p.length);
              for (let e = 0; e < g.length; ++e) g[e] = [];
              let f = 0,
                _ = performance.now();
              for (let e = 0; e < u.length; ++e) {
                const t = u[e],
                  n = [],
                  r = [];
                switch (t.type) {
                  case y.Morph.Type.GroupMorph:
                  case y.Morph.Type.BoneMorph:
                  case y.Morph.Type.MaterialMorph:
                    a.push(t);
                    break;
                  case y.Morph.Type.VertexMorph:
                  case y.Morph.Type.UvMorph:
                  case y.Morph.Type.AdditionalUvMorph1:
                  case y.Morph.Type.AdditionalUvMorph2:
                  case y.Morph.Type.AdditionalUvMorph3:
                  case y.Morph.Type.AdditionalUvMorph4:
                    a.push({
                      name: t.name,
                      englishName: t.englishName,
                      category: t.category,
                      type: t.type,
                      morphTargets: n,
                      ...(l ? { elements: r } : void 0),
                    });
                    break;
                  default:
                    this.warn(`Unsupported morph type: ${t.type}`);
                }
                if (
                  t.type !== y.Morph.Type.VertexMorph &&
                  t.type !== y.Morph.Type.UvMorph &&
                  t.type !== y.Morph.Type.AdditionalUvMorph1 &&
                  t.type !== y.Morph.Type.AdditionalUvMorph2 &&
                  t.type !== y.Morph.Type.AdditionalUvMorph3 &&
                  t.type !== y.Morph.Type.AdditionalUvMorph4
                )
                  continue;
                const c = [];
                {
                  const e = t.indices;
                  for (let t = 0; t < e.length; ++t) {
                    const n = e[t],
                      i = h[n];
                    if (-1 !== i)
                      if (-2 === i) {
                        const e = d.get(n);
                        for (let t = 0; t < e.length; ++t) {
                          const n = e[t];
                          c.includes(n) || c.push(n);
                        }
                      } else c.includes(i) || c.push(i);
                  }
                  if (
                    t.type !== y.Morph.Type.AdditionalUvMorph1 &&
                    t.type !== y.Morph.Type.AdditionalUvMorph2 &&
                    t.type !== y.Morph.Type.AdditionalUvMorph3 &&
                    t.type !== y.Morph.Type.AdditionalUvMorph4
                  )
                    for (let e = 0; e < c.length; ++e) {
                      const o = new P.MorphTarget(t.name, 0, i);
                      n.push(o), g[c[e]].push(o);
                    }
                }
                if (t.type === y.Morph.Type.VertexMorph)
                  for (let e = 0; e < c.length; ++e) {
                    const i = c[e],
                      a = p[i],
                      s = new Float32Array(a.getVerticesData(o.VertexBuffer.PositionKind)),
                      h = t.indices,
                      d = t.positions,
                      u = m[i].map,
                      g = m[i].isReferencedVertex;
                    if (l) {
                      let e = 0;
                      for (let t = 0; t < h.length; ++t) {
                        if (0 === g[h[t]]) continue;
                        const n = u[h[t]];
                        (s[3 * n + 0] += d[3 * t + 0]),
                          (s[3 * n + 1] += d[3 * t + 1]),
                          (s[3 * n + 2] += d[3 * t + 2]),
                          (e += 1);
                      }
                      const t = new Int32Array(e),
                        n = new Float32Array(3 * e);
                      for (let e = 0, i = 0; e < h.length; ++e) {
                        if (0 === g[h[e]]) continue;
                        const o = u[h[e]];
                        (t[i] = o),
                          (n[3 * i + 0] = d[3 * e + 0]),
                          (n[3 * i + 1] = d[3 * e + 1]),
                          (n[3 * i + 2] = d[3 * e + 2]),
                          (i += 1);
                      }
                      r.push({ meshIndex: i, indices: t, offsets: n });
                    } else
                      for (let e = 0; e < h.length; ++e) {
                        if (0 === g[h[e]]) continue;
                        const t = u[h[e]];
                        (s[3 * t + 0] += d[3 * e + 0]), (s[3 * t + 1] += d[3 * e + 1]), (s[3 * t + 2] += d[3 * e + 2]);
                      }
                    n[e].setPositions(s);
                  }
                else if (t.type === y.Morph.Type.UvMorph)
                  for (let e = 0; e < c.length; ++e) {
                    const i = c[e],
                      a = p[i],
                      s = new Float32Array(a.getVerticesData(o.VertexBuffer.UVKind)),
                      h = t.indices,
                      d = t.offsets,
                      u = m[i].map,
                      g = m[i].isReferencedVertex;
                    if (l) {
                      let e = 0;
                      for (let t = 0; t < h.length; ++t) {
                        if (0 === g[h[t]]) continue;
                        const n = u[h[t]];
                        (s[2 * n + 0] += d[4 * t + 0]), (s[2 * n + 1] -= d[4 * t + 1]), (e += 1);
                      }
                      const t = new Int32Array(e),
                        n = new Float32Array(4 * e);
                      for (let e = 0, i = 0; e < h.length; ++e) {
                        if (0 === g[h[e]]) continue;
                        const o = u[h[e]];
                        (t[i] = o),
                          (n[4 * i + 0] = d[4 * e + 0]),
                          (n[4 * i + 1] = -d[4 * e + 1]),
                          (n[4 * i + 2] = d[4 * e + 2]),
                          (n[4 * i + 3] = d[4 * e + 3]),
                          (i += 1);
                      }
                      r.push({ meshIndex: i, indices: t, offsets: n });
                    } else
                      for (let e = 0; e < h.length; ++e) {
                        if (0 === g[h[e]]) continue;
                        const t = u[h[e]];
                        (s[2 * t + 0] += d[4 * e + 0]), (s[2 * t + 1] -= d[4 * e + 1]);
                      }
                    const f = n[e];
                    f.setPositions(a.getVerticesData(o.VertexBuffer.PositionKind)), f.setUVs(s);
                  }
                else if (l)
                  for (let e = 0; e < c.length; ++e) {
                    const n = c[e],
                      i = m[n].map,
                      o = m[n].isReferencedVertex,
                      a = t.indices,
                      s = t.offsets;
                    let l = 0;
                    for (let e = 0; e < a.length; ++e) 0 !== o[a[e]] && (l += 1);
                    const h = new Int32Array(l),
                      d = new Float32Array(4 * l);
                    for (let e = 0, t = 0; e < a.length; ++e) {
                      if (0 === o[a[e]]) continue;
                      const n = i[a[e]];
                      (h[t] = n),
                        (d[4 * t + 0] = s[4 * e + 0]),
                        (d[4 * t + 1] = s[4 * e + 1]),
                        (d[4 * t + 2] = s[4 * e + 2]),
                        (d[4 * t + 3] = s[4 * e + 3]),
                        (t += 1);
                    }
                    r.push({ meshIndex: n, indices: h, offsets: d });
                  }
                (f += t.indices.length),
                  100 < performance.now() - _ &&
                    (s.setTaskProgress("Build Morph", f),
                    s.invokeProgressEvent(),
                    await B.Tools.DelayAsync(0),
                    (_ = performance.now()));
              }
              s.endTask("Build Morph");
              const b = [],
                A = n.meshes;
              for (let e = 0; e < g.length; ++e) {
                const t = g[e];
                if (0 === t.length) continue;
                i._blockEntityCollection = !!r;
                const n = new O.MorphTargetManager(i);
                (n._parentContainer = r),
                  (i._blockEntityCollection = !1),
                  (n.enableNormalMorphing = !1),
                  (n.enableTangentMorphing = !1),
                  (n.enableUVMorphing = !1),
                  (n.areUpdatesFrozen = !0);
                for (let e = 0; e < t.length; ++e) {
                  const i = t[e];
                  n.addTarget(i), i.hasUVs && (n.enableUVMorphing = !0);
                }
                (n.areUpdatesFrozen = !1), b.push(n), (A[e].morphTargetManager = n);
              }
              return b;
            }
          }
          class pe extends ue {
            constructor() {
              super("pmd", { ".pmd": { isBinary: !0 } });
            }
            async _parseFileAsync(e) {
              return await w.ParseAsync(e, this).catch((e) => Promise.reject(e));
            }
          }
          A.SceneLoader && A.SceneLoader.RegisterPlugin(new pe());
          class ge {
            _vertexIndexSize;
            _textureIndexSize;
            _materialIndexSize;
            _boneIndexSize;
            _morphIndexSize;
            _rigidBodyIndexSize;
            constructor(e, t, n, i, o, r) {
              (this._vertexIndexSize = e),
                (this._textureIndexSize = t),
                (this._materialIndexSize = n),
                (this._boneIndexSize = i),
                (this._morphIndexSize = o),
                (this._rigidBodyIndexSize = r);
            }
            getVertexIndex(e) {
              switch (this._vertexIndexSize) {
                case 1:
                  return e.getUint8();
                case 2:
                  return e.getUint16();
                case 4:
                  return e.getInt32();
                default:
                  throw new Error(`Invalid vertexIndexSize: ${this._vertexIndexSize}`);
              }
            }
            _getNonVertexIndex(e, t) {
              switch (t) {
                case 1:
                  return e.getInt8();
                case 2:
                  return e.getInt16();
                case 4:
                  return e.getInt32();
                default:
                  throw new Error(`Invalid indexSize: ${t}`);
              }
            }
            getTextureIndex(e) {
              return this._getNonVertexIndex(e, this._textureIndexSize);
            }
            getMaterialIndex(e) {
              return this._getNonVertexIndex(e, this._materialIndexSize);
            }
            getBoneIndex(e) {
              return this._getNonVertexIndex(e, this._boneIndexSize);
            }
            getMorphIndex(e) {
              return this._getNonVertexIndex(e, this._morphIndexSize);
            }
            getRigidBodyIndex(e) {
              return this._getNonVertexIndex(e, this._rigidBodyIndexSize);
            }
          }
          class fe {
            constructor() {}
            static async ParseAsync(e, t = new M()) {
              const n = new T(e),
                i = this._ParseHeader(n, t),
                o = new ge(
                  i.vertexIndexSize,
                  i.textureIndexSize,
                  i.materialIndexSize,
                  i.boneIndexSize,
                  i.morphIndexSize,
                  i.rigidBodyIndexSize
                ),
                r = await this._ParseVerticesAsync(n, o, i),
                a = this._ParseIndices(n, o, i),
                s = this._ParseTextures(n),
                l = this._ParseMaterials(n, o),
                h = this._ParseBones(n, o),
                d = this._ParseMorphs(n, o),
                c = this._ParseDisplayFrames(n, o),
                m = this._ParseRigidBodies(n, o),
                u = this._ParseJoints(n, o),
                p = i.version <= 2 ? [] : this._ParseSoftBodies(n, o, i);
              return (
                n.bytesAvailable > 0 && t.warn(`There are ${n.bytesAvailable} bytes left after parsing`),
                {
                  header: i,
                  vertices: r,
                  indices: a,
                  textures: s,
                  materials: l,
                  bones: h,
                  morphs: d,
                  displayFrames: c,
                  rigidBodies: m,
                  joints: u,
                  softBodies: p,
                }
              );
            }
            static _ParseHeader(e, t) {
              if (e.bytesAvailable < 17) throw new RangeError("is not pmx file");
              const n = e.getSignatureString(3);
              if ("PMX" !== n) throw new RangeError("is not pmx file");
              e.getInt8();
              const i = e.getFloat32(),
                o = e.getUint8(),
                r = e.getUint8();
              e.initializeTextDecoder(r === y.Header.Encoding.Utf8 ? "utf-8" : "utf-16le");
              const a = e.getUint8(),
                s = e.getUint8(),
                l = e.getUint8(),
                h = e.getUint8(),
                d = e.getUint8(),
                c = e.getUint8(),
                m = e.getUint8();
              if (o < 8) throw new Error(`Invalid globalsCount: ${o}`);
              if (8 < o) {
                t.warn(`globalsCount is greater than 8: ${o} files may be corrupted or higher version`);
                for (let t = 8; t < o; ++t) e.getUint8();
              }
              return {
                signature: n,
                version: i,
                encoding: r,
                additionalVec4Count: a,
                vertexIndexSize: s,
                textureIndexSize: l,
                materialIndexSize: h,
                boneIndexSize: d,
                morphIndexSize: c,
                rigidBodyIndexSize: m,
                modelName: e.getDecoderString(e.getInt32(), !1),
                englishModelName: e.getDecoderString(e.getInt32(), !1),
                comment: e.getDecoderString(e.getInt32(), !1),
                englishComment: e.getDecoderString(e.getInt32(), !1),
              };
            }
            static async _ParseVerticesAsync(e, t, n) {
              const i = e.getInt32(),
                o = [];
              let r = performance.now();
              for (let a = 0; a < i; ++a) {
                const i = e.getFloat32Tuple(3),
                  s = e.getFloat32Tuple(3),
                  l = e.getFloat32Tuple(2),
                  h = [];
                for (let t = 0; t < n.additionalVec4Count; ++t) h.push(e.getFloat32Tuple(4));
                const d = e.getUint8();
                let c;
                switch (d) {
                  case y.Vertex.BoneWeightType.Bdef1:
                    c = { boneIndices: t.getBoneIndex(e), boneWeights: null };
                    break;
                  case y.Vertex.BoneWeightType.Bdef2:
                    c = { boneIndices: [t.getBoneIndex(e), t.getBoneIndex(e)], boneWeights: e.getFloat32() };
                    break;
                  case y.Vertex.BoneWeightType.Bdef4:
                    c = {
                      boneIndices: [t.getBoneIndex(e), t.getBoneIndex(e), t.getBoneIndex(e), t.getBoneIndex(e)],
                      boneWeights: [e.getFloat32(), e.getFloat32(), e.getFloat32(), e.getFloat32()],
                    };
                    break;
                  case y.Vertex.BoneWeightType.Sdef:
                    c = {
                      boneIndices: [t.getBoneIndex(e), t.getBoneIndex(e)],
                      boneWeights: {
                        boneWeight0: e.getFloat32(),
                        c: e.getFloat32Tuple(3),
                        r0: e.getFloat32Tuple(3),
                        r1: e.getFloat32Tuple(3),
                      },
                    };
                    break;
                  case y.Vertex.BoneWeightType.Qdef:
                    c = {
                      boneIndices: [t.getBoneIndex(e), t.getBoneIndex(e), t.getBoneIndex(e), t.getBoneIndex(e)],
                      boneWeights: [e.getFloat32(), e.getFloat32(), e.getFloat32(), e.getFloat32()],
                    };
                    break;
                  default:
                    throw new Error(`Invalid weightType: ${d}`);
                }
                const m = e.getFloat32();
                o.push({
                  position: i,
                  normal: s,
                  uv: l,
                  additionalVec4: h,
                  weightType: d,
                  boneWeight: c,
                  edgeScale: m,
                }),
                  a % 1e4 == 0 &&
                    100 < performance.now() - r &&
                    (await new Promise((e) => setTimeout(e, 0)), (r = performance.now()));
              }
              return o;
            }
            static _ParseIndices(e, t, n) {
              const i = e.getInt32(),
                o = new ArrayBuffer(i * n.vertexIndexSize);
              let r;
              switch (n.vertexIndexSize) {
                case 1:
                  r = new Uint8Array(o);
                  break;
                case 2:
                  r = new Uint16Array(o);
                  break;
                case 4:
                  r = new Int32Array(o);
                  break;
                default:
                  throw new Error(`Invalid vertexIndexSize: ${n.vertexIndexSize}`);
              }
              for (let n = 0; n < i; ++n) r[n] = t.getVertexIndex(e);
              return r;
            }
            static _ParseTextures(e) {
              const t = e.getInt32(),
                n = [];
              for (let i = 0; i < t; ++i) {
                const t = e.getDecoderString(e.getInt32(), !1);
                n.push(t);
              }
              return n;
            }
            static _ParseMaterials(e, t) {
              const n = e.getInt32(),
                i = [];
              for (let o = 0; o < n; ++o) {
                const n = e.getDecoderString(e.getInt32(), !1),
                  o = e.getDecoderString(e.getInt32(), !1),
                  r = e.getFloat32Tuple(4),
                  a = e.getFloat32Tuple(3),
                  s = e.getFloat32(),
                  l = e.getFloat32Tuple(3),
                  h = e.getUint8(),
                  d = e.getFloat32Tuple(4),
                  c = e.getFloat32(),
                  m = t.getTextureIndex(e),
                  u = t.getTextureIndex(e),
                  p = e.getUint8(),
                  g = 1 === e.getUint8(),
                  f = {
                    name: n,
                    englishName: o,
                    diffuse: r,
                    specular: a,
                    shininess: s,
                    ambient: l,
                    flag: h,
                    edgeColor: d,
                    edgeSize: c,
                    textureIndex: m,
                    sphereTextureIndex: u,
                    sphereTextureMode: p,
                    isSharedToonTexture: g,
                    toonTextureIndex: g ? e.getUint8() : t.getTextureIndex(e),
                    comment: e.getDecoderString(e.getInt32(), !1),
                    indexCount: e.getInt32(),
                  };
                i.push(f);
              }
              return i;
            }
            static _ParseBones(e, t) {
              const n = e.getInt32(),
                i = [];
              for (let o = 0; o < n; ++o) {
                const n = e.getDecoderString(e.getInt32(), !1),
                  o = e.getDecoderString(e.getInt32(), !1),
                  r = e.getFloat32Tuple(3),
                  a = t.getBoneIndex(e),
                  s = e.getInt32(),
                  l = e.getUint16();
                let h, d, c, m, u, p;
                if (
                  ((h = l & y.Bone.Flag.UseBoneIndexAsTailPosition ? t.getBoneIndex(e) : e.getFloat32Tuple(3)),
                  (l & y.Bone.Flag.HasAppendMove || l & y.Bone.Flag.HasAppendRotate) &&
                    (d = { parentIndex: t.getBoneIndex(e), ratio: e.getFloat32() }),
                  l & y.Bone.Flag.HasAxisLimit && (c = e.getFloat32Tuple(3)),
                  l & y.Bone.Flag.HasLocalVector && (m = { x: e.getFloat32Tuple(3), z: e.getFloat32Tuple(3) }),
                  l & y.Bone.Flag.IsExternalParentTransformed && (u = e.getInt32()),
                  l & y.Bone.Flag.IsIkEnabled)
                ) {
                  const n = t.getBoneIndex(e),
                    i = e.getInt32(),
                    o = e.getFloat32(),
                    r = [],
                    a = e.getInt32();
                  for (let n = 0; n < a; ++n) {
                    const n = {
                      target: t.getBoneIndex(e),
                      limitation:
                        1 === e.getUint8()
                          ? { minimumAngle: e.getFloat32Tuple(3), maximumAngle: e.getFloat32Tuple(3) }
                          : void 0,
                    };
                    r.push(n);
                  }
                  p = { target: n, iteration: i, rotationConstraint: o, links: r };
                }
                const g = {
                  name: n,
                  englishName: o,
                  position: r,
                  parentBoneIndex: a,
                  transformOrder: s,
                  flag: l,
                  tailPosition: h,
                  appendTransform: d,
                  axisLimit: c,
                  localVector: m,
                  externalParentTransform: u,
                  ik: p,
                };
                i.push(g);
              }
              return i;
            }
            static _ParseMorphs(e, t) {
              const n = e.getInt32(),
                i = [];
              for (let o = 0; o < n; ++o) {
                const n = e.getDecoderString(e.getInt32(), !1),
                  o = e.getDecoderString(e.getInt32(), !1),
                  r = e.getInt8(),
                  a = e.getInt8();
                let s = { name: n, englishName: o, category: r, type: a };
                const l = e.getInt32();
                switch (a) {
                  case y.Morph.Type.GroupMorph:
                    {
                      const n = new Int32Array(l),
                        i = new Float32Array(l);
                      for (let o = 0; o < l; ++o) (n[o] = t.getMorphIndex(e)), (i[o] = e.getFloat32());
                      s = { ...s, indices: n, ratios: i };
                    }
                    break;
                  case y.Morph.Type.VertexMorph:
                    {
                      const n = new Int32Array(l),
                        i = new Float32Array(3 * l);
                      for (let o = 0; o < l; ++o)
                        (n[o] = t.getVertexIndex(e)),
                          (i[3 * o + 0] = e.getFloat32()),
                          (i[3 * o + 1] = e.getFloat32()),
                          (i[3 * o + 2] = e.getFloat32());
                      s = { ...s, indices: n, positions: i };
                    }
                    break;
                  case y.Morph.Type.BoneMorph:
                    {
                      const n = new Int32Array(l),
                        i = new Float32Array(3 * l),
                        o = new Float32Array(4 * l);
                      for (let r = 0; r < l; ++r)
                        (n[r] = t.getBoneIndex(e)),
                          (i[3 * r + 0] = e.getFloat32()),
                          (i[3 * r + 1] = e.getFloat32()),
                          (i[3 * r + 2] = e.getFloat32()),
                          (o[4 * r + 0] = e.getFloat32()),
                          (o[4 * r + 1] = e.getFloat32()),
                          (o[4 * r + 2] = e.getFloat32()),
                          (o[4 * r + 3] = e.getFloat32());
                      s = { ...s, indices: n, positions: i, rotations: o };
                    }
                    break;
                  case y.Morph.Type.UvMorph:
                  case y.Morph.Type.AdditionalUvMorph1:
                  case y.Morph.Type.AdditionalUvMorph2:
                  case y.Morph.Type.AdditionalUvMorph3:
                  case y.Morph.Type.AdditionalUvMorph4:
                    {
                      const n = new Int32Array(l),
                        i = new Float32Array(4 * l);
                      for (let o = 0; o < l; ++o)
                        (n[o] = t.getVertexIndex(e)),
                          (i[4 * o + 0] = e.getFloat32()),
                          (i[4 * o + 1] = e.getFloat32()),
                          (i[4 * o + 2] = e.getFloat32()),
                          (i[4 * o + 3] = e.getFloat32());
                      s = { ...s, indices: n, offsets: i };
                    }
                    break;
                  case y.Morph.Type.MaterialMorph:
                    {
                      const n = [];
                      for (let i = 0; i < l; ++i) {
                        const i = {
                          index: t.getMaterialIndex(e),
                          type: e.getUint8(),
                          diffuse: e.getFloat32Tuple(4),
                          specular: e.getFloat32Tuple(3),
                          shininess: e.getFloat32(),
                          ambient: e.getFloat32Tuple(3),
                          edgeColor: e.getFloat32Tuple(4),
                          edgeSize: e.getFloat32(),
                          textureColor: e.getFloat32Tuple(4),
                          sphereTextureColor: e.getFloat32Tuple(4),
                          toonTextureColor: e.getFloat32Tuple(4),
                        };
                        n.push(i);
                      }
                      s = { ...s, elements: n };
                    }
                    break;
                  case y.Morph.Type.FlipMorph:
                    {
                      const n = new Int32Array(l),
                        i = new Float32Array(l);
                      for (let o = 0; o < l; ++o) (n[o] = t.getMorphIndex(e)), (i[o] = e.getFloat32());
                      s = { ...s, indices: n, ratios: i };
                    }
                    break;
                  case y.Morph.Type.ImpulseMorph:
                    {
                      const n = new Int32Array(l),
                        i = new Array(l),
                        o = new Float32Array(3 * l),
                        r = new Float32Array(3 * l);
                      for (let a = 0; a < l; ++a)
                        (n[a] = t.getRigidBodyIndex(e)),
                          (i[a] = 1 === e.getUint8()),
                          (o[3 * a + 0] = e.getFloat32()),
                          (o[3 * a + 1] = e.getFloat32()),
                          (o[3 * a + 2] = e.getFloat32()),
                          (r[3 * a + 0] = e.getFloat32()),
                          (r[3 * a + 1] = e.getFloat32()),
                          (r[3 * a + 2] = e.getFloat32());
                      s = { ...s, indices: n, isLocals: i, velocities: o, torques: r };
                    }
                    break;
                  default:
                    throw new Error(`Unknown morph type: ${a}`);
                }
                i.push(s);
              }
              return i;
            }
            static _ParseDisplayFrames(e, t) {
              const n = e.getInt32(),
                i = [];
              for (let o = 0; o < n; ++o) {
                const n = e.getDecoderString(e.getInt32(), !1),
                  o = e.getDecoderString(e.getInt32(), !1),
                  r = 1 === e.getUint8(),
                  a = e.getInt32(),
                  s = [];
                for (let n = 0; n < a; ++n) {
                  const n = e.getUint8(),
                    i = {
                      type: n,
                      index: n === y.DisplayFrame.FrameData.FrameType.Bone ? t.getBoneIndex(e) : t.getMorphIndex(e),
                    };
                  s.push(i);
                }
                const l = { name: n, englishName: o, isSpecialFrame: r, frames: s };
                i.push(l);
              }
              return i;
            }
            static _ParseRigidBodies(e, t) {
              const n = e.getInt32(),
                i = [];
              for (let o = 0; o < n; ++o) {
                const n = {
                  name: e.getDecoderString(e.getInt32(), !1),
                  englishName: e.getDecoderString(e.getInt32(), !1),
                  boneIndex: t.getBoneIndex(e),
                  collisionGroup: e.getUint8(),
                  collisionMask: e.getUint16(),
                  shapeType: e.getUint8(),
                  shapeSize: e.getFloat32Tuple(3),
                  shapePosition: e.getFloat32Tuple(3),
                  shapeRotation: e.getFloat32Tuple(3),
                  mass: e.getFloat32(),
                  linearDamping: e.getFloat32(),
                  angularDamping: e.getFloat32(),
                  repulsion: e.getFloat32(),
                  friction: e.getFloat32(),
                  physicsMode: e.getUint8(),
                };
                i.push(n);
              }
              return i;
            }
            static _ParseJoints(e, t) {
              const n = e.getInt32(),
                i = [];
              for (let o = 0; o < n; ++o) {
                const n = {
                  name: e.getDecoderString(e.getInt32(), !1),
                  englishName: e.getDecoderString(e.getInt32(), !1),
                  type: e.getUint8(),
                  rigidbodyIndexA: t.getRigidBodyIndex(e),
                  rigidbodyIndexB: t.getRigidBodyIndex(e),
                  position: e.getFloat32Tuple(3),
                  rotation: e.getFloat32Tuple(3),
                  positionMin: e.getFloat32Tuple(3),
                  positionMax: e.getFloat32Tuple(3),
                  rotationMin: e.getFloat32Tuple(3),
                  rotationMax: e.getFloat32Tuple(3),
                  springPosition: e.getFloat32Tuple(3),
                  springRotation: e.getFloat32Tuple(3),
                };
                i.push(n);
              }
              return i;
            }
            static _ParseSoftBodies(e, t, n) {
              const i = e.getInt32(),
                o = [];
              for (let r = 0; r < i; ++r) {
                const i = e.getDecoderString(e.getInt32(), !1),
                  r = e.getDecoderString(e.getInt32(), !1),
                  a = e.getUint8(),
                  s = t.getMaterialIndex(e),
                  l = e.getUint8(),
                  h = e.getUint16(),
                  d = e.getUint8(),
                  c = e.getInt32(),
                  m = e.getInt32(),
                  u = e.getFloat32(),
                  p = e.getFloat32(),
                  g = e.getInt32(),
                  f = {
                    vcf: e.getFloat32(),
                    dp: e.getFloat32(),
                    dg: e.getFloat32(),
                    lf: e.getFloat32(),
                    pr: e.getFloat32(),
                    vc: e.getFloat32(),
                    df: e.getFloat32(),
                    mt: e.getFloat32(),
                    chr: e.getFloat32(),
                    khr: e.getFloat32(),
                    shr: e.getFloat32(),
                    ahr: e.getFloat32(),
                  },
                  _ = {
                    srhrCl: e.getFloat32(),
                    skhrCl: e.getFloat32(),
                    sshrCl: e.getFloat32(),
                    srSpltCl: e.getFloat32(),
                    skSpltCl: e.getFloat32(),
                    ssSpltCl: e.getFloat32(),
                  },
                  b = { vIt: e.getInt32(), pIt: e.getInt32(), dIt: e.getInt32(), cIt: e.getInt32() },
                  y = { lst: e.getInt32(), ast: e.getInt32(), vst: e.getInt32() },
                  A = e.getInt32(),
                  M = [];
                for (let n = 0; n < A; ++n) {
                  const n = {
                    rigidbodyIndex: t.getRigidBodyIndex(e),
                    vertexIndex: t.getVertexIndex(e),
                    isNearMode: 0 !== e.getUint8(),
                  };
                  M.push(n);
                }
                const T = e.getInt32(),
                  w = new ArrayBuffer(T * n.vertexIndexSize);
                let x;
                switch (n.vertexIndexSize) {
                  case 1:
                    x = new Uint8Array(w);
                    break;
                  case 2:
                    x = new Uint16Array(w);
                    break;
                  case 4:
                    x = new Int32Array(w);
                    break;
                  default:
                    throw new Error(`Invalid vertexIndexSize: ${n.vertexIndexSize}`);
                }
                for (let n = 0; n < T; ++n) x[n] = t.getVertexIndex(e);
                const I = {
                  name: i,
                  englishName: r,
                  type: a,
                  materialIndex: s,
                  collisionGroup: l,
                  collisionMask: h,
                  flags: d,
                  bLinkDistance: c,
                  clusterCount: m,
                  totalMass: u,
                  collisionMargin: p,
                  aeroModel: g,
                  config: f,
                  cluster: _,
                  iteration: b,
                  material: y,
                  anchors: M,
                  vertexPins: x,
                };
                o.push(I);
              }
              return o;
            }
          }
          class _e extends ue {
            constructor() {
              super("pmx", { ".pmx": { isBinary: !0 } });
            }
            async _parseFileAsync(e) {
              return await fe.ParseAsync(e, this).catch((e) => Promise.reject(e));
            }
          }
          A.SceneLoader && A.SceneLoader.RegisterPlugin(new _e()),
            (function (e) {
              let t, n, i;
              !(function (e) {
                let t, n, i;
                !(function (e) {
                  e[(e.IsSkinnedMesh = 1)] = "IsSkinnedMesh";
                })((t = e.MeshType || (e.MeshType = {}))),
                  (function (e) {
                    (e[(e.HasSdef = 1)] = "HasSdef"),
                      (e[(e.IsIndexed = 2)] = "IsIndexed"),
                      (e[(e.HasEdgeScale = 4)] = "HasEdgeScale");
                  })((n = e.GeometryType || (e.GeometryType = {}))),
                  (function (e) {
                    (e[(e.Int32 = 0)] = "Int32"), (e[(e.Uint32 = 1)] = "Uint32"), (e[(e.Uint16 = 2)] = "Uint16");
                  })((i = e.IndexElementType || (e.IndexElementType = {})));
              })((t = e.Geometry || (e.Geometry = {}))),
                (function (e) {
                  let t;
                  !(function (e) {
                    e[(e.HasMimeType = 1)] = "HasMimeType";
                  })((t = e.Flag || (e.Flag = {})));
                })((n = e.Image || (e.Image = {}))),
                (function (e) {
                  let t;
                  !(function (e) {
                    (e[(e.NoMipmap = 1)] = "NoMipmap"), (e[(e.InvertY = 2)] = "InvertY");
                  })((t = e.Flag || (e.Flag = {})));
                })((i = e.Texture || (e.Texture = {})));
            })(oe || (oe = {}));
          var be = H(4232);
          class ye {
            constructor() {}
            static async ParseAsync(e, t = new M()) {
              const n = new T(e);
              n.initializeTextDecoder("utf-8");
              const i = this._ParseHeader(n),
                o = 1 === n.getUint8(),
                r = await this._ParseGeometriesAsync(n, o),
                a = await this._ParseImagesAsync(n),
                s = this._ParseTexturesAsync(n),
                l = this._ParseMaterials(n),
                h = o ? this._ParseBones(n) : [],
                d = this._ParseMorphs(n),
                c = this._ParseDisplayFrames(n),
                m = this._ParseRigidBodies(n),
                u = this._ParseJoints(n);
              return (
                n.bytesAvailable > 0 && t.warn(`There are ${n.bytesAvailable} bytes left after parsing`),
                {
                  header: i,
                  geometries: r,
                  images: a,
                  textures: s,
                  materials: l,
                  bones: h,
                  morphs: d,
                  displayFrames: c,
                  rigidBodies: m,
                  joints: u,
                }
              );
            }
            static _ParseHeader(e) {
              if (e.bytesAvailable < 7) throw new RangeError("is not bpmx file");
              const t = e.getDecoderString(4, !1);
              if ("BPMX" !== t) throw new RangeError("is not bpmx file");
              const n = [e.getInt8(), e.getInt8(), e.getInt8()];
              if (2 !== n[0] || 0 !== n[1] || 0 !== n[2])
                throw new be.LoadFileError(`BPMX version ${n[0]}.${n[1]}.${n[2]} is not supported.`);
              return {
                signature: t,
                version: n,
                modelName: e.getDecoderString(e.getUint32(), !1),
                englishModelName: e.getDecoderString(e.getUint32(), !1),
                comment: e.getDecoderString(e.getUint32(), !1),
                englishComment: e.getDecoderString(e.getUint32(), !1),
              };
            }
            static async _ParseGeometriesAsync(e, t) {
              let n = performance.now();
              const i = [],
                o = e.getUint32();
              for (let r = 0; r < o; ++r) {
                const o = e.getDecoderString(e.getUint32(), !1),
                  r = e.getInt32(),
                  a = e.getUint32(),
                  s = new Float32Array(3 * a);
                e.getFloat32Array(s),
                  100 < performance.now() - n && (await new Promise((e) => setTimeout(e, 0)), (n = performance.now()));
                const l = new Float32Array(3 * a);
                e.getFloat32Array(l),
                  100 < performance.now() - n && (await new Promise((e) => setTimeout(e, 0)), (n = performance.now()));
                const h = new Float32Array(2 * a);
                e.getFloat32Array(h);
                const d = [],
                  c = e.getUint8();
                for (let t = 0; t < c; ++t) {
                  const t = new Float32Array(4 * a);
                  e.getFloat32Array(t), d.push(t);
                }
                100 < performance.now() - n && (await new Promise((e) => setTimeout(e, 0)), (n = performance.now()));
                const m = e.getUint8();
                let u, p, g;
                if (0 != (m & oe.Geometry.GeometryType.IsIndexed)) {
                  const t = e.getUint8(),
                    i = e.getUint32();
                  t === oe.Geometry.IndexElementType.Int32
                    ? ((u = new Int32Array(i)), e.getInt32Array(u))
                    : t === oe.Geometry.IndexElementType.Uint32
                    ? ((u = new Uint32Array(i)), e.getUint32Array(u))
                    : ((u = new Uint16Array(i)), e.getUint16Array(u)),
                    100 < performance.now() - n &&
                      (await new Promise((e) => setTimeout(e, 0)), (n = performance.now()));
                }
                if (t) {
                  const t = new Float32Array(4 * a);
                  e.getFloat32Array(t);
                  const i = new Float32Array(4 * a);
                  let o;
                  if (
                    (e.getFloat32Array(i),
                    100 < performance.now() - n &&
                      (await new Promise((e) => setTimeout(e, 0)), (n = performance.now())),
                    0 != (m & oe.Geometry.GeometryType.HasSdef))
                  ) {
                    const t = new Float32Array(3 * a),
                      i = new Float32Array(3 * a),
                      r = new Float32Array(3 * a);
                    e.getFloat32Array(t),
                      e.getFloat32Array(i),
                      e.getFloat32Array(r),
                      (o = { c: t, r0: i, r1: r }),
                      100 < performance.now() - n &&
                        (await new Promise((e) => setTimeout(e, 0)), (n = performance.now()));
                  }
                  p = { matricesIndices: t, matricesWeights: i, sdef: o };
                }
                0 != (m & oe.Geometry.GeometryType.HasEdgeScale) && ((g = new Float32Array(a)), e.getFloat32Array(g));
                const f = {
                  name: o,
                  materialIndex: r,
                  positions: s,
                  normals: l,
                  uvs: h,
                  additionalUvs: d,
                  indices: u,
                  skinning: p,
                  edgeScale: g,
                };
                i.push(f);
              }
              return i;
            }
            static async _ParseImagesAsync(e) {
              const t = e.getUint32();
              let n = performance.now();
              const i = [];
              for (let o = 0; o < t; ++o) {
                const t = e.getDecoderString(e.getUint32(), !1),
                  o = 0 != (e.getUint8() & oe.Image.Flag.HasMimeType) ? e.getDecoderString(e.getUint32(), !1) : void 0,
                  r = e.getUint32(),
                  a = new ArrayBuffer(r);
                e.getUint8Array(new Uint8Array(a)),
                  i.push({ relativePath: t, mimeType: o, data: a }),
                  100 < performance.now() - n && (await new Promise((e) => setTimeout(e, 0)), (n = performance.now()));
              }
              return i;
            }
            static _ParseTexturesAsync(e) {
              const t = e.getUint32(),
                n = [];
              for (let i = 0; i < t; ++i) {
                const t = e.getUint8(),
                  i = e.getUint8(),
                  o = e.getInt32();
                n.push({ flag: t, samplingMode: i, imageIndex: o });
              }
              return n;
            }
            static _ParseMaterials(e) {
              const t = e.getUint32(),
                n = [];
              for (let i = 0; i < t; ++i) {
                const t = {
                  name: e.getDecoderString(e.getUint32(), !1),
                  englishName: e.getDecoderString(e.getUint32(), !1),
                  diffuse: e.getFloat32Tuple(4),
                  specular: e.getFloat32Tuple(3),
                  shininess: e.getFloat32(),
                  ambient: e.getFloat32Tuple(3),
                  evauatedTransparency: e.getInt8(),
                  flag: e.getUint8(),
                  edgeColor: e.getFloat32Tuple(4),
                  edgeSize: e.getFloat32(),
                  textureIndex: e.getInt32(),
                  sphereTextureIndex: e.getInt32(),
                  sphereTextureMode: e.getUint8(),
                  isSharedToonTexture: 1 === e.getUint8(),
                  toonTextureIndex: e.getInt32(),
                  comment: e.getDecoderString(e.getUint32(), !1),
                };
                n.push(t);
              }
              return n;
            }
            static _ParseBones(e) {
              const t = e.getUint32(),
                n = [];
              for (let i = 0; i < t; ++i) {
                const t = e.getDecoderString(e.getUint32(), !1),
                  i = e.getDecoderString(e.getUint32(), !1),
                  o = e.getFloat32Tuple(3),
                  r = e.getInt32(),
                  a = e.getInt32(),
                  s = e.getUint16();
                let l, h, d, c, m, u;
                if (
                  ((l = s & y.Bone.Flag.UseBoneIndexAsTailPosition ? e.getInt32() : e.getFloat32Tuple(3)),
                  (s & y.Bone.Flag.HasAppendMove || s & y.Bone.Flag.HasAppendRotate) &&
                    (h = { parentIndex: e.getInt32(), ratio: e.getFloat32() }),
                  s & y.Bone.Flag.HasAxisLimit && (d = e.getFloat32Tuple(3)),
                  s & y.Bone.Flag.HasLocalVector && (c = { x: e.getFloat32Tuple(3), z: e.getFloat32Tuple(3) }),
                  s & y.Bone.Flag.IsExternalParentTransformed && (m = e.getInt32()),
                  s & y.Bone.Flag.IsIkEnabled)
                ) {
                  const t = e.getInt32(),
                    n = e.getInt32(),
                    i = e.getFloat32(),
                    o = [],
                    r = e.getInt32();
                  for (let t = 0; t < r; ++t) {
                    const t = {
                      target: e.getInt32(),
                      limitation:
                        1 === e.getUint8()
                          ? { minimumAngle: e.getFloat32Tuple(3), maximumAngle: e.getFloat32Tuple(3) }
                          : void 0,
                    };
                    o.push(t);
                  }
                  u = { target: t, iteration: n, rotationConstraint: i, links: o };
                }
                const p = {
                  name: t,
                  englishName: i,
                  position: o,
                  parentBoneIndex: r,
                  transformOrder: a,
                  flag: s,
                  tailPosition: l,
                  appendTransform: h,
                  axisLimit: d,
                  localVector: c,
                  externalParentTransform: m,
                  ik: u,
                };
                n.push(p);
              }
              return n;
            }
            static _ParseMorphs(e) {
              const t = e.getUint32(),
                n = [];
              for (let i = 0; i < t; ++i) {
                const t = e.getDecoderString(e.getUint32(), !1),
                  i = e.getDecoderString(e.getUint32(), !1),
                  o = e.getUint8(),
                  r = e.getUint8();
                let a = { name: t, englishName: i, category: o, type: r };
                switch (r) {
                  case y.Morph.Type.GroupMorph:
                    {
                      const t = e.getUint32(),
                        n = new Int32Array(t);
                      e.getInt32Array(n);
                      const i = new Float32Array(t);
                      e.getFloat32Array(i), (a = { ...a, indices: n, ratios: i });
                    }
                    break;
                  case y.Morph.Type.VertexMorph:
                    {
                      const t = e.getUint32(),
                        n = [];
                      for (let i = 0; i < t; ++i) {
                        const t = e.getUint32(),
                          i = e.getUint32(),
                          o = new Int32Array(i);
                        e.getInt32Array(o);
                        const r = new Float32Array(3 * i);
                        e.getFloat32Array(r);
                        const a = { meshIndex: t, indices: o, offsets: r };
                        n.push(a);
                      }
                      a = { ...a, elements: n };
                    }
                    break;
                  case y.Morph.Type.BoneMorph:
                    {
                      const t = e.getUint32(),
                        n = new Int32Array(t);
                      e.getInt32Array(n);
                      const i = new Float32Array(3 * t);
                      e.getFloat32Array(i);
                      const o = new Float32Array(4 * t);
                      e.getFloat32Array(o), (a = { ...a, indices: n, positions: i, rotations: o });
                    }
                    break;
                  case y.Morph.Type.UvMorph:
                  case y.Morph.Type.AdditionalUvMorph1:
                  case y.Morph.Type.AdditionalUvMorph2:
                  case y.Morph.Type.AdditionalUvMorph3:
                  case y.Morph.Type.AdditionalUvMorph4:
                    {
                      const t = e.getUint32(),
                        n = [];
                      for (let i = 0; i < t; ++i) {
                        const t = e.getUint32(),
                          i = e.getUint32(),
                          o = new Int32Array(i);
                        e.getInt32Array(o);
                        const r = new Float32Array(4 * i);
                        e.getFloat32Array(r);
                        const a = { meshIndex: t, indices: o, offsets: r };
                        n.push(a);
                      }
                      a = { ...a, elements: n };
                    }
                    break;
                  case y.Morph.Type.MaterialMorph:
                    {
                      const t = e.getUint32(),
                        n = [];
                      for (let i = 0; i < t; ++i) {
                        const t = {
                          index: e.getInt32(),
                          type: e.getUint8(),
                          diffuse: e.getFloat32Tuple(4),
                          specular: e.getFloat32Tuple(3),
                          shininess: e.getFloat32(),
                          ambient: e.getFloat32Tuple(3),
                          edgeColor: e.getFloat32Tuple(4),
                          edgeSize: e.getFloat32(),
                          textureColor: e.getFloat32Tuple(4),
                          sphereTextureColor: e.getFloat32Tuple(4),
                          toonTextureColor: e.getFloat32Tuple(4),
                        };
                        n.push(t);
                      }
                      a = { ...a, elements: n };
                    }
                    break;
                  default:
                    throw new Error(`Unknown morph type: ${r}`);
                }
                n.push(a);
              }
              return n;
            }
            static _ParseDisplayFrames(e) {
              const t = e.getUint32(),
                n = [];
              for (let i = 0; i < t; ++i) {
                const t = e.getDecoderString(e.getUint32(), !1),
                  i = e.getDecoderString(e.getUint32(), !1),
                  o = 1 === e.getUint8(),
                  r = e.getUint32(),
                  a = [];
                for (let t = 0; t < r; ++t) {
                  const t = { type: e.getUint8(), index: e.getInt32() };
                  a.push(t);
                }
                const s = { name: t, englishName: i, isSpecialFrame: o, frames: a };
                n.push(s);
              }
              return n;
            }
            static _ParseRigidBodies(e) {
              const t = e.getUint32(),
                n = [];
              for (let i = 0; i < t; ++i) {
                const t = {
                  name: e.getDecoderString(e.getUint32(), !1),
                  englishName: e.getDecoderString(e.getUint32(), !1),
                  boneIndex: e.getInt32(),
                  collisionGroup: e.getUint8(),
                  collisionMask: e.getUint16(),
                  shapeType: e.getUint8(),
                  shapeSize: e.getFloat32Tuple(3),
                  shapePosition: e.getFloat32Tuple(3),
                  shapeRotation: e.getFloat32Tuple(3),
                  mass: e.getFloat32(),
                  linearDamping: e.getFloat32(),
                  angularDamping: e.getFloat32(),
                  repulsion: e.getFloat32(),
                  friction: e.getFloat32(),
                  physicsMode: e.getUint8(),
                };
                n.push(t);
              }
              return n;
            }
            static _ParseJoints(e) {
              const t = e.getUint32(),
                n = [];
              for (let i = 0; i < t; ++i) {
                const t = {
                  name: e.getDecoderString(e.getUint32(), !1),
                  englishName: e.getDecoderString(e.getUint32(), !1),
                  type: e.getUint8(),
                  rigidbodyIndexA: e.getInt32(),
                  rigidbodyIndexB: e.getInt32(),
                  position: e.getFloat32Tuple(3),
                  rotation: e.getFloat32Tuple(3),
                  positionMin: e.getFloat32Tuple(3),
                  positionMax: e.getFloat32Tuple(3),
                  rotationMin: e.getFloat32Tuple(3),
                  rotationMax: e.getFloat32Tuple(3),
                  springPosition: e.getFloat32Tuple(3),
                  springRotation: e.getFloat32Tuple(3),
                };
                n.push(t);
              }
              return n;
            }
          }
          class Ae extends de {
            constructor() {
              super("bpmx", { ".bpmx": { isBinary: !0 } });
            }
            loadFile(e, t, n, i, o, r, a) {
              const s = this.materialBuilder,
                l = this.useSdef,
                h = this.buildSkeleton,
                d = this.buildMorph,
                c = this.boundingBoxMargin,
                m = this.preserveSerializationData;
              return e._loadFile(
                t,
                (e, n) => {
                  const o = {
                    arrayBuffer: e,
                    pmFileId: t instanceof File ? ce.GetId(t).toString() : t,
                    materialBuilder: s,
                    useSdef: l,
                    buildSkeleton: h,
                    buildMorph: d,
                    boundingBoxMargin: c,
                    preserveSerializationData: m,
                  };
                  i(o, n);
                },
                o,
                !0,
                r,
                a
              );
            }
            async _parseFileAsync(e) {
              return await ye.ParseAsync(e, this).catch((e) => Promise.reject(e));
            }
            _getProgressTaskCosts(e, t) {
              const n = super._getProgressTaskCosts(e, t);
              let i = 0;
              for (let e = 0; e < t.geometries.length; ++e) i += t.geometries[e].positions.length;
              if ((n.push({ name: "Build Geometry", cost: i }), e.buildMorph)) {
                let e = 0;
                const i = t.morphs;
                for (let t = 0; t < i.length; ++t) {
                  const n = i[t];
                  if (n.type !== y.Morph.Type.VertexMorph && n.type !== y.Morph.Type.UvMorph) continue;
                  const o = n.elements;
                  for (let t = 0; t < o.length; ++t) e += o[t].indices.length;
                }
                n.push({ name: "Build Morph", cost: e });
              }
              return n;
            }
            async _buildGeometryAsync(e, t, n, i, o, r) {
              const a = [],
                s = [];
              let l = performance.now(),
                h = 0;
              const d = t.geometries;
              for (let c = 0; c < d.length; ++c) {
                const u = d[c],
                  p = u.skinning,
                  g = new v.VertexData();
                (g.positions = u.positions),
                  (g.normals = u.normals),
                  (g.uvs = u.uvs),
                  void 0 !== u.indices && (g.indices = u.indices),
                  e.buildSkeleton &&
                    void 0 !== p &&
                    ((g.matricesIndices = p.matricesIndices), (g.matricesWeights = p.matricesWeights));
                let f = null,
                  _ = null,
                  b = null;
                if (e.buildSkeleton && e.useSdef && void 0 !== p?.sdef) {
                  const e = u.positions.length / 3,
                    t = p.matricesWeights;
                  (f = p.sdef.c), (_ = p.sdef.r0), (b = p.sdef.r1);
                  for (let n = 0; n < e; ++n) {
                    const e = t[4 * n + 0],
                      i = t[4 * n + 1],
                      o = f[3 * n + 0],
                      r = f[3 * n + 1],
                      a = f[3 * n + 2];
                    let s = _[3 * n + 0],
                      l = _[3 * n + 1],
                      h = _[3 * n + 2],
                      d = b[3 * n + 0],
                      c = b[3 * n + 1],
                      m = b[3 * n + 2];
                    const u = s * e + d * i,
                      p = l * e + c * i,
                      g = h * e + m * i;
                    (s = o + s - u),
                      (l = r + l - p),
                      (h = a + h - g),
                      (d = o + d - u),
                      (c = r + c - p),
                      (m = a + m - g);
                    const y = 0.5 * (o + s),
                      A = 0.5 * (r + l),
                      M = 0.5 * (a + h),
                      T = 0.5 * (o + d),
                      w = 0.5 * (r + c),
                      x = 0.5 * (a + m);
                    (f[3 * n + 0] = o),
                      (f[3 * n + 1] = r),
                      (f[3 * n + 2] = a),
                      (_[3 * n + 0] = y),
                      (_[3 * n + 1] = A),
                      (_[3 * n + 2] = M),
                      (b[3 * n + 0] = T),
                      (b[3 * n + 1] = w),
                      (b[3 * n + 2] = x);
                  }
                }
                i._blockEntityCollection = !!o;
                const y = new (null !== f ? me : I.Mesh)(u.name, i);
                (y._parentContainer = o),
                  (i._blockEntityCollection = !1),
                  void 0 === u.indices && (y.isUnIndexed = !0),
                  y.setParent(n),
                  a.push(y),
                  (i._blockEntityCollection = !!o);
                const A = new x.Geometry(t.header.modelName, i, g, !1);
                if (
                  ((A._parentContainer = o),
                  (i._blockEntityCollection = !1),
                  e.preserveSerializationData && void 0 !== u.additionalUvs)
                ) {
                  const e = [m.AdditionalUV1Kind, m.AdditionalUV2Kind, m.AdditionalUV3Kind, m.AdditionalUV4Kind];
                  for (let t = 0; t < u.additionalUvs.length; ++t) A.setVerticesData(e[t], u.additionalUvs[t], !1, 4);
                }
                null !== f &&
                  (A.setVerticesData(m.MatricesSdefCKind, f, !1, 3),
                  A.setVerticesData(m.MatricesSdefR0Kind, _, !1, 3),
                  A.setVerticesData(m.MatricesSdefR1Kind, b, !1, 3)),
                  e.preserveSerializationData &&
                    void 0 !== u.edgeScale &&
                    A.setVerticesData(m.EdgeScaleKind, u.edgeScale, !1, 1),
                  A.applyToMesh(y),
                  s.push(A),
                  (h += u.positions.length),
                  h % 1e4 == 0 &&
                    100 < performance.now() - l &&
                    (r.setTaskProgress("Build Geometry", h),
                    r.invokeProgressEvent(),
                    await B.Tools.DelayAsync(0),
                    (l = performance.now()));
              }
              return r.endTask("Build Geometry"), r.invokeProgressEvent(), { meshes: a, geometries: s };
            }
            async _buildMaterialAsync(e, t, n, i, o, r, a, s, l) {
              let h;
              const d = new Array(t.images.length);
              for (let e = 0; e < t.images.length; ++e) d[e] = t.images[e].relativePath;
              const c = new Array(t.textures.length);
              for (let e = 0; e < t.textures.length; ++e) {
                const n = t.textures[e];
                c[e] = {
                  noMipmap: 0 != (n.flag & oe.Texture.Flag.NoMipmap),
                  invertY: 0 != (n.flag & oe.Texture.Flag.InvertY),
                  samplingMode: n.samplingMode,
                  imagePathIndex: n.imageIndex,
                };
              }
              const m = new Promise((m) => {
                  h = e.materialBuilder.buildMaterials(
                    n.uniqueId,
                    t.materials,
                    d,
                    s,
                    "file:" + e.pmFileId + "_",
                    t.images,
                    c,
                    r,
                    a,
                    i,
                    o,
                    this,
                    (e) => {
                      e.lengthComputable &&
                        (l.setTaskProgressRatio("Texture Load", e.loaded / e.total, !0), l.invokeProgressEvent());
                    },
                    () => m()
                  );
                }),
                u = Array.isArray(h) ? h : await h,
                p = t.geometries;
              for (let e = 0; e < i.length; ++e) {
                const t = i[e],
                  n = p[e].materialIndex;
                if (-1 === n) continue;
                const o = u[n];
                t.material = o;
              }
              return l.endTask("Build Material"), l.invokeProgressEvent(), { materials: u, textureLoadPromise: m };
            }
            _buildSkeletonAsync(e, t, n, i, o, r, a) {
              return 0 === t.bones.length
                ? (a.endTask("Build Skeleton"), Promise.resolve(null))
                : super._buildSkeletonAsync(e, t, n, i, o, r, a);
            }
            async _buildMorphAsync(e, t, n, i, o, r, a) {
              const s = e.preserveSerializationData,
                l = t.morphs,
                h = new Array(t.geometries.length);
              for (let e = 0; e < h.length; ++e) h[e] = [];
              let d = 0,
                c = performance.now();
              for (let e = 0; e < l.length; ++e) {
                const n = l[e],
                  o = [];
                switch (n.type) {
                  case y.Morph.Type.GroupMorph:
                  case y.Morph.Type.BoneMorph:
                  case y.Morph.Type.MaterialMorph:
                    r.push(n);
                    break;
                  case y.Morph.Type.VertexMorph:
                  case y.Morph.Type.UvMorph:
                  case y.Morph.Type.AdditionalUvMorph1:
                  case y.Morph.Type.AdditionalUvMorph2:
                  case y.Morph.Type.AdditionalUvMorph3:
                  case y.Morph.Type.AdditionalUvMorph4:
                    r.push({
                      name: n.name,
                      englishName: n.englishName,
                      category: n.category,
                      type: n.type,
                      morphTargets: o,
                      ...(s ? { elements: n.elements } : void 0),
                    });
                }
                if (
                  n.type === y.Morph.Type.VertexMorph ||
                  n.type === y.Morph.Type.UvMorph ||
                  n.type === y.Morph.Type.AdditionalUvMorph1 ||
                  n.type === y.Morph.Type.AdditionalUvMorph2 ||
                  n.type === y.Morph.Type.AdditionalUvMorph3 ||
                  n.type === y.Morph.Type.AdditionalUvMorph4
                ) {
                  if (
                    n.type !== y.Morph.Type.AdditionalUvMorph1 &&
                    n.type !== y.Morph.Type.AdditionalUvMorph2 &&
                    n.type !== y.Morph.Type.AdditionalUvMorph3 &&
                    n.type !== y.Morph.Type.AdditionalUvMorph4
                  ) {
                    const e = n.elements;
                    for (let t = 0; t < e.length; ++t) {
                      const r = new P.MorphTarget(n.name, 0, i);
                      o.push(r), h[e[t].meshIndex].push(r), (d += e[t].indices.length);
                    }
                    const r = t.geometries;
                    if (n.type === y.Morph.Type.VertexMorph)
                      for (let t = 0; t < e.length; ++t) {
                        const n = e[t],
                          i = r[n.meshIndex],
                          a = new Float32Array(i.positions.length);
                        a.set(i.positions);
                        const s = n.indices,
                          l = n.offsets;
                        for (let e = 0; e < s.length; ++e) {
                          const t = s[e];
                          (a[3 * t + 0] += l[3 * e + 0]),
                            (a[3 * t + 1] += l[3 * e + 1]),
                            (a[3 * t + 2] += l[3 * e + 2]);
                        }
                        o[t].setPositions(a);
                      }
                    else
                      for (let t = 0; t < e.length; ++t) {
                        const n = e[t],
                          i = r[n.meshIndex],
                          a = new Float32Array(i.uvs.length);
                        a.set(i.uvs);
                        const s = n.indices,
                          l = n.offsets;
                        for (let e = 0; e < s.length; ++e) {
                          const t = s[e];
                          (a[2 * t + 0] += l[4 * e + 0]), (a[2 * t + 1] += l[4 * e + 1]);
                        }
                        const h = o[t];
                        h.setPositions(i.positions), h.setUVs(a);
                      }
                  }
                  100 < performance.now() - c &&
                    (a.setTaskProgress("Build Morph", d),
                    a.invokeProgressEvent(),
                    await B.Tools.DelayAsync(0),
                    (c = performance.now()));
                }
              }
              a.endTask("Build Morph");
              const m = [],
                u = n.meshes;
              for (let e = 0; e < h.length; ++e) {
                const t = h[e];
                if (0 === t.length) continue;
                i._blockEntityCollection = !!o;
                const n = new O.MorphTargetManager(i);
                (n._parentContainer = o),
                  (i._blockEntityCollection = !1),
                  (n.enableNormalMorphing = !1),
                  (n.enableTangentMorphing = !1),
                  (n.enableUVMorphing = !1),
                  (n.areUpdatesFrozen = !0);
                for (let e = 0; e < t.length; ++e) {
                  const i = t[e];
                  n.addTarget(i), i.hasUVs && (n.enableUVMorphing = !0);
                }
                (n.areUpdatesFrozen = !1), m.push(n), (u[e].morphTargetManager = n);
              }
              return m;
            }
          }
          A.SceneLoader && A.SceneLoader.RegisterPlugin(new Ae());
          class Me {
            animation;
            startFrame;
            endFrame;
            offset;
            weight;
            easingFunction;
            easeInFrameTime;
            easeOutFrameTime;
            constructor(e, t, n, i, o) {
              (this.animation = e),
                (this.startFrame = t ?? e.startFrame),
                (this.endFrame = n ?? e.endFrame),
                (this.offset = i ?? 0),
                (this.weight = o ?? 1),
                (this.easingFunction = null),
                (this.easeInFrameTime = 0),
                (this.easeOutFrameTime = 0);
            }
            get name() {
              return this.animation.name;
            }
            isInSpan(e) {
              return this.startFrame + this.offset <= e && e <= this.endFrame + this.offset;
            }
            getFrameTime(e) {
              return e - this.offset;
            }
            getEasedWeight(e) {
              const t = this.startFrame,
                n = this.endFrame,
                i = this.easeInFrameTime,
                o = this.easeOutFrameTime;
              if (Math.abs(e - t) < Math.abs(e - n)) {
                if (t + i <= e) return this.weight;
                if (e <= t) return 0;
                {
                  const n = e - t;
                  return this.weight * (this.easingFunction?.ease(n / i) ?? n / i);
                }
              }
              if (e <= n - o) return this.weight;
              if (n <= e) return 0;
              {
                const t = e - n + o;
                return this.weight * (1 - (this.easingFunction?.ease(t / o) ?? t / o));
              }
            }
          }
          class Te {
            onSpanAddedObservable;
            onSpanRemovedObservable;
            name;
            _startFrame;
            _endFrame;
            _spans;
            constructor(e) {
              (this.onSpanAddedObservable = new U.Observable()),
                (this.onSpanRemovedObservable = new U.Observable()),
                (this.name = e),
                (this._startFrame = 0),
                (this._endFrame = 0),
                (this._spans = []);
            }
            addSpan(e) {
              (this._startFrame =
                0 === this._spans.length
                  ? e.startFrame + e.offset
                  : Math.min(this.startFrame, e.startFrame + e.offset)),
                (this._endFrame = Math.max(this.endFrame, e.endFrame + e.offset)),
                this._spans.push(e),
                this.onSpanAddedObservable.notifyObservers(e);
            }
            removeSpan(e) {
              const t = this._spans.indexOf(e);
              this.removeSpanFromIndex(t);
            }
            removeSpanFromIndex(e) {
              const t = this._spans;
              if (!(e < 0 || t.length <= e)) {
                if ((t.splice(e, 1), 0 === t.length)) (this._startFrame = 0), (this._endFrame = 0);
                else {
                  let e = t[0].startFrame + t[0].offset,
                    n = t[0].endFrame + t[0].offset;
                  for (let i = 1; i < t.length; i++) {
                    const o = t[i];
                    (e = Math.min(e, o.startFrame + o.offset)), (n = Math.max(n, o.endFrame + o.offset));
                  }
                  (this._startFrame = e), (this._endFrame = n);
                }
                this.onSpanRemovedObservable.notifyObservers(e);
              }
            }
            get startFrame() {
              return this._startFrame;
            }
            get endFrame() {
              return this._endFrame;
            }
            get spans() {
              return this._spans;
            }
          }
          class we {
            animation;
            _camera;
            _runtimeAnimations;
            _onSpanAdded;
            _onSpanRemoved;
            constructor(e, t, n, i, o) {
              (this.animation = e),
                (this._camera = t),
                (this._runtimeAnimations = n),
                (this._onSpanAdded = i),
                (this._onSpanRemoved = o),
                e.onSpanAddedObservable.add(i),
                e.onSpanRemovedObservable.add(o);
            }
            static _ActiveAnimationSpans = [];
            static _ActiveRuntimeAnimations = [];
            static _CameraPosition = new E.Vector3();
            static _CameraRotation = new E.Vector3();
            animate(e) {
              e = Math.max(this.animation.startFrame, Math.min(this.animation.endFrame, e));
              const t = this.animation.spans,
                n = this._runtimeAnimations,
                i = we._ActiveAnimationSpans,
                o = we._ActiveRuntimeAnimations;
              for (let r = 0; r < t.length; ++r) {
                const a = t[r],
                  s = n[r];
                null !== s && 0 < a.weight && a.isInSpan(e) && (i.push(a), o.push(s));
              }
              let r = 0;
              for (let t = 0; t < i.length; ++t) r += i[t].getEasedWeight(i[t].getFrameTime(e));
              const a = this._camera;
              if (0 === r) return (i.length = 0), void (o.length = 0);
              if (1 === r && 1 === i.length) {
                const t = i[0];
                return o[0].animate(t.getFrameTime(e)), (i.length = 0), void (o.length = 0);
              }
              const s = r < 1 ? 1 : 1 / r,
                l = we._CameraPosition.setAll(0),
                h = we._CameraRotation.setAll(0);
              let d = 0,
                c = 0;
              for (let t = 0; t < i.length; ++t) {
                const n = i[t],
                  r = o[t],
                  m = n.getFrameTime(e);
                r.animate(m);
                const u = n.getEasedWeight(m) * s;
                a.position.scaleAndAddToRef(u, l),
                  a.rotation.scaleAndAddToRef(u, h),
                  (d += a.distance * u),
                  (c += a.fov * u);
              }
              a.position.copyFrom(l),
                a.rotation.copyFrom(h),
                (a.distance = d),
                (a.fov = c),
                (i.length = 0),
                (o.length = 0);
            }
            dispose() {
              null !== this._onSpanAdded &&
                (this.animation.onSpanAddedObservable.removeCallback(this._onSpanAdded),
                this.animation.onSpanRemovedObservable.removeCallback(this._onSpanRemoved),
                (this._onSpanAdded = null),
                (this._onSpanRemoved = null));
            }
            static Create(e, t) {
              const n = new Array(e.spans.length).fill(null),
                i = e.spans;
              for (let e = 0; e < i.length; ++e) {
                const o = i[e].animation;
                if (void 0 !== o.createRuntimeCameraAnimation) {
                  const i = o.createRuntimeCameraAnimation(t);
                  n[e] = i;
                } else if (void 0 === o.createRuntimeModelAnimation)
                  throw new Error(
                    `animation ${o.name} is not bindable. are you missing import "babylon-mmd/esm/Runtime/Animation/mmdRuntimeCameraAnimation" or "babylon-mmd/esm/Runtime/Animation/mmdRuntimeCameraAnimationGroup"?`
                  );
              }
              return new we(
                e,
                t,
                n,
                (e) => {
                  const i = e.animation;
                  if (void 0 !== i.createRuntimeCameraAnimation) {
                    const e = i.createRuntimeCameraAnimation(t);
                    n.push(e);
                  } else {
                    if (void 0 === i.createRuntimeModelAnimation)
                      throw new Error(
                        `animation ${i.name} is not bindable. are you missing import "babylon-mmd/esm/Runtime/Animation/mmdRuntimeCameraAnimation" or "babylon-mmd/esm/Runtime/Animation/mmdRuntimeCameraAnimationGroup"?`
                      );
                    n.push(null);
                  }
                },
                (e) => {
                  n.splice(e, 1);
                }
              );
            }
          }
          function xe(e, t, n, i) {
            let o = !1,
              r = !1,
              a = !1;
            const s = new Set(),
              l = (t) => {
                const n = t.materialElements;
                for (let t = 0; t < n.length; ++t) {
                  const i = n[t];
                  if (null !== i.textureColor && !o) {
                    const t = i.index;
                    if (-1 === i.index) {
                      for (let t = 0; t < e.length; ++t) e[t].textureColor;
                      o = !0;
                    } else e[t].textureColor, s.add(t.toString());
                  }
                  if (null !== i.sphereTextureColor && !r) {
                    const t = i.index;
                    if (-1 === i.index) {
                      for (let t = 0; t < e.length; ++t) e[t].sphereTextureColor;
                      r = !0;
                    } else e[t].sphereTextureColor, s.add(t.toString());
                  }
                  if (null !== i.toonTextureColor && !a) {
                    const t = i.index;
                    if (-1 === i.index) {
                      for (let t = 0; t < e.length; ++t) e[t].toonTextureColor;
                      a = !0;
                    } else e[t].toonTextureColor, s.add(t.toString());
                  }
                }
              },
              h = new Uint8Array(t.morphs.length);
            for (let e = 0; e < n.length; ++e) {
              const i = n[e];
              if (null !== i) {
                for (let e = 0; e < i.length; ++e) {
                  const n = i[e];
                  if (1 === h[n]) continue;
                  h[n] = 1;
                  const o = t.morphs[n];
                  switch (o.type) {
                    case y.Morph.Type.GroupMorph:
                      t.groupMorphFlatForeach(o, (e) => {
                        if (1 === h[e]) return;
                        h[e] = 1;
                        const n = t.morphs[e];
                        n.type === y.Morph.Type.MaterialMorph && l(n);
                      });
                      break;
                    case y.Morph.Type.MaterialMorph:
                      l(o);
                  }
                }
                if (o && r && a) break;
              }
            }
            o || r || a
              ? i?.log("All materials could be recompiled for morph animation")
              : 0 < s.size && i?.log(`Materials ${Array.from(s).join(", ")} could be recompiled for morph animation`);
          }
          function Ie(e, t) {
            const n = e.morphTargetManagers,
              i = new Array(n.length),
              o = new Array(n.length);
            for (let e = 0; e < n.length; ++e) {
              const t = (i[e] = new Set()),
                r = (o[e] = new Set()),
                a = n[e],
                s = a.numTargets;
              for (let e = 0; e < s; ++e) {
                const n = a.getTarget(e);
                t.add(n), 0 !== n.influence && r.add(n);
              }
            }
            {
              const t = e.morphs;
              for (let e = 0; e < t.length; ++e) {
                const n = t[e];
                switch (n.type) {
                  case y.Morph.Type.VertexMorph:
                  case y.Morph.Type.UvMorph: {
                    const e = n.elements;
                    for (let t = 0; t < e.length; ++t) {
                      const n = e[t];
                      for (let e = 0; e < o.length; ++e) o[e].delete(n);
                    }
                  }
                }
              }
            }
            const r = (e) => {
                const t = e.elements;
                for (let e = 0; e < t.length; ++e) {
                  const r = t[e];
                  for (let e = 0; e < n.length; ++e) i[e].has(r) && o[e].add(r);
                }
              },
              a = new Uint8Array(e.morphs.length);
            for (let n = 0; n < t.length; ++n) {
              const i = t[n];
              if (null !== i)
                for (let t = 0; t < i.length; ++t) {
                  const n = i[t];
                  if (1 === a[n]) continue;
                  a[n] = 1;
                  const o = e.morphs[n];
                  switch (o.type) {
                    case y.Morph.Type.GroupMorph:
                      e.groupMorphFlatForeach(o, (t) => {
                        if (1 === a[t]) return;
                        a[t] = 1;
                        const n = e.morphs[t];
                        switch (n.type) {
                          case y.Morph.Type.VertexMorph:
                          case y.Morph.Type.UvMorph:
                            r(n);
                        }
                      });
                      break;
                    case y.Morph.Type.VertexMorph:
                    case y.Morph.Type.UvMorph:
                      r(o);
                  }
                }
            }
            for (let e = 0; e < n.length; ++e) n[e].numMaxInfluencers = o[e].size;
          }
          Te.prototype.createRuntimeCameraAnimation = function (e) {
            return we.Create(this, e);
          };
          class ve {
            animation;
            _ikSolverStates;
            _morphController;
            _meshes;
            _runtimeAnimations;
            _onSpanAdded;
            _onSpanRemoved;
            constructor(e, t, n, i, o, r, a) {
              (this.animation = e),
                (this._ikSolverStates = t),
                (this._morphController = n),
                (this._meshes = i),
                (this._runtimeAnimations = o),
                (this._onSpanAdded = r),
                (this._onSpanRemoved = a),
                e.onSpanAddedObservable.add(r),
                e.onSpanRemovedObservable.add(a);
            }
            static _RuntimeAnimationIdMap = new WeakMap();
            static _RuntimeAnimationIdCounter = 0;
            static _GetRuntimeAnimationId(e) {
              let t = ve._RuntimeAnimationIdMap.get(e);
              return void 0 === t && ((t = ve._RuntimeAnimationIdCounter += 1), ve._RuntimeAnimationIdMap.set(e, t)), t;
            }
            _boneResultMap = new Map();
            _movableBoneResultMap = new Map();
            _morphResultMap = new Map();
            _ikSolverResultMap = new Map();
            _activeAnimationSpans = [];
            _activeRuntimeAnimations = [];
            _activeRuntimeAnimationIds = [];
            _lastActiveRuntimeAnimationIds = [];
            _boneRestPosition = new E.Vector3();
            static _IdentityQuaternion = E.Quaternion.Identity();
            animate(e) {
              e = Math.max(this.animation.startFrame, Math.min(this.animation.endFrame, e));
              const t = this.animation.spans,
                n = this._runtimeAnimations,
                i = this._activeAnimationSpans,
                o = this._activeRuntimeAnimations,
                r = this._morphController;
              for (let r = 0; r < t.length; ++r) {
                const a = t[r],
                  s = n[r];
                null !== s && 0 < a.weight && a.isInSpan(e) && (i.push(a), o.push(s));
              }
              let a = 0;
              for (let t = 0; t < i.length; ++t) a += i[t].getEasedWeight(i[t].getFrameTime(e));
              const s = this._meshes,
                l = this._ikSolverStates,
                h = this._boneResultMap,
                d = this._movableBoneResultMap,
                c = this._morphResultMap,
                m = this._ikSolverResultMap;
              let u = !0;
              const p = this._activeRuntimeAnimationIds,
                g = this._lastActiveRuntimeAnimationIds;
              if (g.length !== o.length) {
                u = !1;
                for (let e = 0; e < o.length; ++e) p.push(ve._GetRuntimeAnimationId(o[e]));
              } else
                for (let e = 0; e < o.length; ++e) {
                  const t = ve._GetRuntimeAnimationId(o[e]);
                  p.push(t), g[e] !== t && (u = !1);
                }
              if (((this._lastActiveRuntimeAnimationIds = p), (this._activeRuntimeAnimationIds = g), (g.length = 0), u))
                if (0 === a) {
                  for (const [e, t] of h) e.rotationQuaternion.copyFromFloats(0, 0, 0, 1), (t[1] = 0), (t[2] = 0);
                  for (const [e, t] of d)
                    e.rotationQuaternion.copyFromFloats(0, 0, 0, 1),
                      e.getRestMatrix().getTranslationToRef(this._boneRestPosition),
                      t[0].copyFromFloats(0, 0, 0),
                      (t[2] = 0),
                      (t[3] = 0);
                  for (const [e, t] of c) r.setMorphWeightFromIndex(e, 0), c.set(e, 0);
                  for (let e = 0; e < s.length; ++e) s[e].visibility = 1;
                  for (const [e, t] of m) (l[e] = 0), m.set(e, !0);
                } else {
                  for (const [e, t] of h) (t[1] = 0), (t[2] = 0);
                  for (const [e, t] of d) t[0].copyFromFloats(0, 0, 0), (t[2] = 0), (t[3] = 0);
                  for (const [e, t] of c) c.set(e, 0);
                  for (const [e, t] of m) m.set(e, !0);
                }
              else {
                for (const [e, t] of h) e.rotationQuaternion.copyFromFloats(0, 0, 0, 1);
                for (const [e, t] of d)
                  e.rotationQuaternion.copyFromFloats(0, 0, 0, 1),
                    e.getRestMatrix().getTranslationToRef(this._boneRestPosition);
                for (const [e, t] of c) r.setMorphWeightFromIndex(e, 0);
                for (let e = 0; e < s.length; ++e) s[e].visibility = 1;
                for (const [e, t] of m) l[e] = 1;
                h.clear(), d.clear(), c.clear(), m.clear();
              }
              if (0 === a) return (i.length = 0), void (o.length = 0);
              if (1 === a && 1 === i.length) {
                const t = i[0],
                  n = o[0];
                n.animate(t.getFrameTime(e));
                const r = n.boneBindIndexMap;
                for (let e = 0; e < r.length; ++e) {
                  const t = r[e];
                  null !== t && void 0 === h.get(t) && h.set(t, [new E.Quaternion(), 0, 0]);
                }
                const a = n.movableBoneBindIndexMap;
                for (let e = 0; e < a.length; ++e) {
                  const t = a[e];
                  null !== t && void 0 === d.get(t) && d.set(t, [new E.Vector3(), new E.Quaternion(), 0, 0]);
                }
                const s = n.morphBindIndexMap;
                for (let e = 0; e < s.length; ++e) {
                  const t = s[e];
                  if (null !== t)
                    for (let e = 0; e < t.length; ++e) {
                      const n = t[e];
                      void 0 === c.get(n) && c.set(n, 0);
                    }
                }
                const l = n.ikSolverBindIndexMap;
                for (let e = 0; e < l.length; ++e) {
                  const t = l[e];
                  null !== t && void 0 === m.get(t) && m.set(t, !0);
                }
                return (i.length = 0), void (o.length = 0);
              }
              let f, _;
              a < 1 ? ((f = 1), (_ = 1 - a)) : ((f = 1 / a), (_ = 0));
              for (let t = 0; t < i.length; ++t) {
                const n = i[t],
                  a = o[t];
                0 !== s.length && (s[0].visibility = 1);
                const u = n.getFrameTime(e);
                a.animate(u);
                const p = n.getEasedWeight(u) * f,
                  g = a.boneBindIndexMap;
                for (let e = 0; e < g.length; ++e) {
                  const t = g[e];
                  if (null !== t) {
                    const e = h.get(t);
                    void 0 === e
                      ? h.set(t, [t.rotationQuaternion.clone(), p, 1])
                      : (0 === e[2]
                          ? (e[0].copyFrom(t.rotationQuaternion), (e[1] = p))
                          : (E.Quaternion.SlerpToRef(e[0], t.rotationQuaternion, p / (e[1] + p), e[0]), (e[1] += p)),
                        (e[2] += 1));
                  }
                }
                const b = a.movableBoneBindIndexMap;
                for (let e = 0; e < b.length; ++e) {
                  const t = b[e];
                  if (null !== t) {
                    const e = t.getRestMatrix().getTranslationToRef(this._boneRestPosition),
                      n = d.get(t);
                    void 0 === n
                      ? d.set(t, [
                          t.position.clone().subtractInPlace(e).scaleInPlace(p),
                          t.rotationQuaternion.clone(),
                          p,
                          1,
                        ])
                      : (t.position.subtractInPlace(e).scaleAndAddToRef(p, n[0]),
                        0 === n[3]
                          ? (n[1].copyFrom(t.rotationQuaternion), (n[2] = p))
                          : (E.Quaternion.SlerpToRef(n[1], t.rotationQuaternion, p / (n[2] + p), n[1]), (n[2] += p)),
                        (n[3] += 1));
                  }
                }
                const y = a.morphBindIndexMap;
                for (let e = 0; e < y.length; ++e) {
                  const t = y[e];
                  if (null !== t)
                    for (let e = 0; e < t.length; ++e) {
                      const n = t[e],
                        i = c.get(n);
                      void 0 === i
                        ? c.set(n, r.getMorphWeightFromIndex(n) * p)
                        : c.set(n, i + r.getMorphWeightFromIndex(n) * p);
                    }
                }
                const A = a.ikSolverBindIndexMap;
                for (let e = 0; e < A.length; ++e) {
                  const t = A[e];
                  if (-1 !== t) {
                    const e = m.get(t);
                    void 0 === e ? m.set(t, 0 !== l[t]) : m.set(t, e && 0 !== l[t]);
                  }
                }
                0 !== s.length && (_ += s[0].visibility * p);
              }
              for (const [e, t] of h)
                a < 1
                  ? E.Quaternion.SlerpToRef(ve._IdentityQuaternion, t[0], t[1], e.rotationQuaternion)
                  : e.rotationQuaternion.copyFrom(t[0]);
              for (const [e, t] of d)
                e.getRestMatrix().getTranslationToRef(e.position).addInPlace(t[0]),
                  a < 1
                    ? E.Quaternion.SlerpToRef(ve._IdentityQuaternion, t[1], t[2], e.rotationQuaternion)
                    : e.rotationQuaternion.copyFrom(t[1]);
              for (const [e, t] of c) r.setMorphWeightFromIndex(e, t);
              if (Math.abs(_ - 1) < 1e-6) for (let e = 0; e < s.length; ++e) s[e].visibility = 1;
              else for (let e = 0; e < s.length; ++e) s[e].visibility = _;
              for (const [e, t] of m) l[e] = t ? 1 : 0;
              (i.length = 0), (o.length = 0);
            }
            induceMaterialRecompile(e, t) {
              const n = this._runtimeAnimations;
              for (let e = 0; e < n.length; ++e) n[e]?.induceMaterialRecompile(!1, t);
              if (e) {
                const e = [];
                for (let t = 0; t < n.length; ++t) {
                  const i = n[t];
                  if (null !== i) {
                    const t = i.morphBindIndexMap;
                    e.push(...t);
                  }
                }
                Ie(this._morphController, e);
              }
            }
            dispose() {
              null !== this._onSpanAdded &&
                (this.animation.onSpanAddedObservable.removeCallback(this._onSpanAdded),
                this.animation.onSpanRemovedObservable.removeCallback(this._onSpanRemoved),
                (this._onSpanAdded = null),
                (this._onSpanRemoved = null));
            }
            static Create(e, t, n, i) {
              const o = new Array(e.spans.length).fill(null),
                r = e.spans;
              for (let e = 0; e < r.length; ++e) {
                const a = r[e].animation;
                if (void 0 !== a.createRuntimeModelAnimation) {
                  const r = a.createRuntimeModelAnimation(t, n, i);
                  o[e] = r;
                } else if (void 0 === a.createRuntimeModelAnimation)
                  throw new Error(
                    `animation ${a.name} is not bindable. are you missing import "babylon-mmd/esm/Runtime/Animation/mmdRuntimeModelAnimation" or "babylon-mmd/esm/Runtime/Animation/mmdRuntimeModelAnimationGroup"?`
                  );
              }
              return new ve(
                e,
                t.ikSolverStates,
                t.morph,
                t.mesh.metadata.meshes,
                o,
                (e) => {
                  const r = e.animation;
                  if (void 0 !== r.createRuntimeModelAnimation) {
                    const e = r.createRuntimeModelAnimation(t, n, i);
                    o.push(e);
                  } else {
                    if (void 0 === r.createRuntimeModelAnimation)
                      throw new Error(
                        `animation ${r.name} is not bindable. are you missing import "babylon-mmd/esm/Runtime/Animation/mmdRuntimeModelAnimation" or "babylon-mmd/esm/Runtime/Animation/mmdRuntimeModelAnimationGroup"?`
                      );
                    o.push(null);
                  }
                },
                (e) => {
                  o.splice(e, 1);
                }
              );
            }
          }
          Te.prototype.createRuntimeModelAnimation = function (e, t, n) {
            return ve.Create(this, e, t, n);
          };
          class Be {
            name;
            boneTracks;
            movableBoneTracks;
            morphTracks;
            propertyTrack;
            cameraTrack;
            startFrame;
            endFrame;
            constructor(e, t, n, i, o, r) {
              (this.name = e),
                (this.boneTracks = t),
                (this.movableBoneTracks = n),
                (this.morphTracks = i),
                (this.propertyTrack = o),
                (this.cameraTrack = r);
              let a = Number.MAX_SAFE_INTEGER,
                s = Number.MIN_SAFE_INTEGER;
              for (let e = 0; e < t.length; ++e) {
                const n = t[e];
                (a = Math.min(a, n.startFrame)), (s = Math.max(s, n.endFrame));
              }
              for (let e = 0; e < n.length; ++e) {
                const t = n[e];
                (a = Math.min(a, t.startFrame)), (s = Math.max(s, t.endFrame));
              }
              for (let e = 0; e < i.length; ++e) {
                const t = i[e];
                (a = Math.min(a, t.startFrame)), (s = Math.max(s, t.endFrame));
              }
              (a = Math.min(a, o.startFrame)),
                (s = Math.max(s, o.endFrame)),
                (a = Math.min(a, r.startFrame)),
                (s = Math.max(s, r.endFrame)),
                (this.startFrame = a),
                (this.endFrame = s);
            }
          }
          class Pe {
            static Interpolate(e, t, n, i, o) {
              let r = 0.5,
                a = r,
                s = 1 - a;
              const l = Math;
              let h, d, c;
              for (let n = 0; n < 15; ++n) {
                (h = 3 * s * s * a), (d = 3 * s * a * a), (c = a * a * a);
                const n = h * e + d * t + c - o;
                if (l.abs(n) < 1e-5) break;
                (r *= 0.5), (a += n < 0 ? r : -r), (s = 1 - a);
              }
              return h * n + d * i + c;
            }
          }
          class Oe {
            _lastResults = new Map();
            _upperBoundFrameIndex(e, t) {
              const n = t.frameNumbers;
              let i = this._lastResults.get(t);
              void 0 === i && ((i = [Number.NEGATIVE_INFINITY, 0]), this._lastResults.set(t, i));
              const o = e - i[0];
              if (Math.abs(o) < 6) {
                let t = i[1];
                for (; 0 < t && e < n[t - 1]; ) t -= 1;
                for (; t < n.length && n[t] <= e; ) t += 1;
                return (i[0] = e), (i[1] = t), t;
              }
              {
                let t = 0,
                  o = n.length;
                for (; t < o; ) {
                  const i = t + ((o - t) >> 1);
                  e < n[i] ? (o = i) : (t = i + 1);
                }
                return (i[0] = e), (i[1] = t), t;
              }
            }
          }
          class Fe extends Oe {
            animation;
            _camera;
            constructor(e, t) {
              super(), (this.animation = e.cameraTrack), (this._camera = t);
            }
            static _CameraPositionA = new E.Vector3();
            static _CameraPositionB = new E.Vector3();
            static _CameraRotationA = new E.Vector3();
            static _CameraRotationB = new E.Vector3();
            static _DegToRad = Math.PI / 180;
            animate(e) {
              const t = this.animation;
              if (0 === t.frameNumbers.length) return;
              const n = this._camera,
                i = Math.max(t.startFrame, Math.min(t.endFrame, e)),
                o = this._upperBoundFrameIndex(i, t),
                r = o - 1,
                a = t.frameNumbers[r],
                s = t.frameNumbers[o];
              if (void 0 === s || a + 1 === s) {
                const e = t.positions;
                n.position.set(e[3 * r], e[3 * r + 1], e[3 * r + 2]);
                const i = t.rotations;
                n.rotation.set(i[3 * r], i[3 * r + 1], i[3 * r + 2]),
                  (n.distance = t.distances[r]),
                  (n.fov = t.fovs[r] * Fe._DegToRad);
              } else {
                const e = (i - a) / (s - a),
                  l = t.positions,
                  h = t.positionInterpolations,
                  d = Fe._CameraPositionA.set(l[3 * r], l[3 * r + 1], l[3 * r + 2]),
                  c = Fe._CameraPositionB.set(l[3 * o], l[3 * o + 1], l[3 * o + 2]),
                  m = Pe.Interpolate(h[12 * o] / 127, h[12 * o + 1] / 127, h[12 * o + 2] / 127, h[12 * o + 3] / 127, e),
                  u = Pe.Interpolate(
                    h[12 * o + 4] / 127,
                    h[12 * o + 5] / 127,
                    h[12 * o + 6] / 127,
                    h[12 * o + 7] / 127,
                    e
                  ),
                  p = Pe.Interpolate(
                    h[12 * o + 8] / 127,
                    h[12 * o + 9] / 127,
                    h[12 * o + 10] / 127,
                    h[12 * o + 11] / 127,
                    e
                  );
                n.position.set(d.x + (c.x - d.x) * m, d.y + (c.y - d.y) * u, d.z + (c.z - d.z) * p);
                const g = t.rotations,
                  f = t.rotationInterpolations,
                  _ = Fe._CameraRotationA.set(g[3 * r], g[3 * r + 1], g[3 * r + 2]),
                  b = Fe._CameraRotationB.set(g[3 * o], g[3 * o + 1], g[3 * o + 2]),
                  y = Pe.Interpolate(f[4 * o] / 127, f[4 * o + 1] / 127, f[4 * o + 2] / 127, f[4 * o + 3] / 127, e),
                  A = 1 - y;
                n.rotation.set(_.x * A + b.x * y, _.y * A + b.y * y, _.z * A + b.z * y);
                const M = t.distances[r],
                  T = t.distances[o],
                  w = Pe.Interpolate(
                    t.distanceInterpolations[4 * o] / 127,
                    t.distanceInterpolations[4 * o + 1] / 127,
                    t.distanceInterpolations[4 * o + 2] / 127,
                    t.distanceInterpolations[4 * o + 3] / 127,
                    e
                  );
                n.distance = M + (T - M) * w;
                const x = t.fovs[r],
                  I = t.fovs[o],
                  v = Pe.Interpolate(
                    t.fovInterpolations[4 * o] / 127,
                    t.fovInterpolations[4 * o + 1] / 127,
                    t.fovInterpolations[4 * o + 2] / 127,
                    t.fovInterpolations[4 * o + 3] / 127,
                    e
                  );
                n.fov = (x + (I - x) * v) * Fe._DegToRad;
              }
            }
            static Create(e, t) {
              return new Fe(e, t);
            }
          }
          Be.prototype.createRuntimeCameraAnimation = function (e) {
            return Fe.Create(this, e);
          };
          var Re = H(4268),
            Se = H(1259),
            Ce = H(6871);
          class Ee extends Re.Animation {
            static ANIMATIONTYPE_SLERP_TANGENT_QUATERNION = 8;
            _interpolate(e, t, n = !1) {
              if (t.loopMode === Re.Animation.ANIMATIONLOOPMODE_CONSTANT && t.repeatCount > 0)
                return t.highLimitValue.clone ? t.highLimitValue.clone() : t.highLimitValue;
              const i = this._keys,
                o = i.length;
              let r = t.key;
              for (; r >= 0 && e < i[r].frame; ) r -= 1;
              for (; r + 1 <= o - 1 && e >= i[r + 1].frame; ) r += 1;
              if (((t.key = r), r < 0)) return n ? void 0 : this._getKeyValue(i[0].value);
              if (r + 1 > o - 1) return n ? void 0 : this._getKeyValue(i[o - 1].value);
              const a = i[r],
                s = i[r + 1];
              if (n && (e === a.frame || e === s.frame)) return;
              const l = this._getKeyValue(a.value),
                h = this._getKeyValue(s.value);
              if (a.interpolation === Ce.AnimationKeyInterpolation.STEP) return s.frame > e ? l : h;
              const d = void 0 !== a.outTangent && void 0 !== s.inTangent,
                c = s.frame - a.frame;
              let m = (e - a.frame) / c;
              const u = a.easingFunction || this.getEasingFunction();
              if ((null !== u && (m = u.ease(m)), a.interpolation === Ce.AnimationKeyInterpolation.NONE))
                switch (this.dataType) {
                  case Re.Animation.ANIMATIONTYPE_FLOAT: {
                    const e = d
                      ? this.floatInterpolateFunctionWithTangents(l, a.outTangent * c, h, s.inTangent * c, m)
                      : this.floatInterpolateFunction(l, h, m);
                    switch (t.loopMode) {
                      case Re.Animation.ANIMATIONLOOPMODE_CYCLE:
                      case Re.Animation.ANIMATIONLOOPMODE_CONSTANT:
                      case Re.Animation.ANIMATIONLOOPMODE_YOYO:
                        return e;
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE:
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
                        return (t.offsetValue ?? 0) * t.repeatCount + e;
                    }
                    break;
                  }
                  case Re.Animation.ANIMATIONTYPE_QUATERNION: {
                    const e = d
                      ? this.quaternionInterpolateFunctionWithTangents(
                          l,
                          a.outTangent.scale(c),
                          h,
                          s.inTangent.scale(c),
                          m
                        )
                      : this.quaternionInterpolateFunction(l, h, m);
                    switch (t.loopMode) {
                      case Re.Animation.ANIMATIONLOOPMODE_CYCLE:
                      case Re.Animation.ANIMATIONLOOPMODE_CONSTANT:
                      case Re.Animation.ANIMATIONLOOPMODE_YOYO:
                        return e;
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE:
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
                        return e.addInPlace((t.offsetValue || Re._staticOffsetValueQuaternion).scale(t.repeatCount));
                    }
                    return e;
                  }
                  case Re.Animation.ANIMATIONTYPE_VECTOR3: {
                    const e = d
                      ? this.vector3InterpolateFunctionWithTangents(
                          l,
                          a.outTangent.scale(c),
                          h,
                          s.inTangent.scale(c),
                          m
                        )
                      : this.vector3InterpolateFunction(l, h, m);
                    switch (t.loopMode) {
                      case Re.Animation.ANIMATIONLOOPMODE_CYCLE:
                      case Re.Animation.ANIMATIONLOOPMODE_CONSTANT:
                      case Re.Animation.ANIMATIONLOOPMODE_YOYO:
                        return e;
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE:
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
                        return e.add((t.offsetValue || Re._staticOffsetValueVector3).scale(t.repeatCount));
                    }
                    break;
                  }
                  case Re.Animation.ANIMATIONTYPE_VECTOR2: {
                    const e = d
                      ? this.vector2InterpolateFunctionWithTangents(
                          l,
                          a.outTangent.scale(c),
                          h,
                          s.inTangent.scale(c),
                          m
                        )
                      : this.vector2InterpolateFunction(l, h, m);
                    switch (t.loopMode) {
                      case Re.Animation.ANIMATIONLOOPMODE_CYCLE:
                      case Re.Animation.ANIMATIONLOOPMODE_CONSTANT:
                      case Re.Animation.ANIMATIONLOOPMODE_YOYO:
                        return e;
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE:
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
                        return e.add((t.offsetValue || Re._staticOffsetValueVector2).scale(t.repeatCount));
                    }
                    break;
                  }
                  case Re.Animation.ANIMATIONTYPE_SIZE:
                    switch (t.loopMode) {
                      case Re.Animation.ANIMATIONLOOPMODE_CYCLE:
                      case Re.Animation.ANIMATIONLOOPMODE_CONSTANT:
                      case Re.Animation.ANIMATIONLOOPMODE_YOYO:
                        return this.sizeInterpolateFunction(l, h, m);
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE:
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
                        return this.sizeInterpolateFunction(l, h, m).add(
                          (t.offsetValue || Re._staticOffsetValueSize).scale(t.repeatCount)
                        );
                    }
                    break;
                  case Re.Animation.ANIMATIONTYPE_COLOR3: {
                    const e = d
                      ? this.color3InterpolateFunctionWithTangents(l, a.outTangent.scale(c), h, s.inTangent.scale(c), m)
                      : this.color3InterpolateFunction(l, h, m);
                    switch (t.loopMode) {
                      case Re.Animation.ANIMATIONLOOPMODE_CYCLE:
                      case Re.Animation.ANIMATIONLOOPMODE_CONSTANT:
                      case Re.Animation.ANIMATIONLOOPMODE_YOYO:
                        return e;
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE:
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
                        return e.add((t.offsetValue || Re._staticOffsetValueColor3).scale(t.repeatCount));
                    }
                    break;
                  }
                  case Re.Animation.ANIMATIONTYPE_COLOR4: {
                    const e = d
                      ? this.color4InterpolateFunctionWithTangents(l, a.outTangent.scale(c), h, s.inTangent.scale(c), m)
                      : this.color4InterpolateFunction(l, h, m);
                    switch (t.loopMode) {
                      case Re.Animation.ANIMATIONLOOPMODE_CYCLE:
                      case Re.Animation.ANIMATIONLOOPMODE_CONSTANT:
                      case Re.Animation.ANIMATIONLOOPMODE_YOYO:
                        return e;
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE:
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
                        return e.add((t.offsetValue || Re._staticOffsetValueColor4).scale(t.repeatCount));
                    }
                    break;
                  }
                  case Re.Animation.ANIMATIONTYPE_MATRIX:
                    switch (t.loopMode) {
                      case Re.Animation.ANIMATIONLOOPMODE_CYCLE:
                      case Re.Animation.ANIMATIONLOOPMODE_CONSTANT:
                      case Re.Animation.ANIMATIONLOOPMODE_YOYO:
                        return Re.Animation.AllowMatricesInterpolation
                          ? this.matrixInterpolateFunction(l, h, m, t.workValue)
                          : l;
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE:
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
                        return l;
                    }
                }
              else
                switch (this.dataType) {
                  case Re.Animation.ANIMATIONTYPE_FLOAT: {
                    const e = d
                      ? this.floatInterpolateFunctionWithControlPoints(l, a.outTangent, h, s.inTangent, m)
                      : this.floatInterpolateFunction(l, h, m);
                    switch (t.loopMode) {
                      case Re.Animation.ANIMATIONLOOPMODE_CYCLE:
                      case Re.Animation.ANIMATIONLOOPMODE_CONSTANT:
                      case Re.Animation.ANIMATIONLOOPMODE_YOYO:
                        return e;
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE:
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
                        return (t.offsetValue ?? 0) * t.repeatCount + e;
                    }
                    break;
                  }
                  case Re.Animation.ANIMATIONTYPE_QUATERNION: {
                    const e = d
                      ? this.quaternionInterpolateFunctionWithControlPoints(l, a.outTangent, h, s.inTangent, m)
                      : this.quaternionInterpolateFunction(l, h, m);
                    switch (t.loopMode) {
                      case Re.Animation.ANIMATIONLOOPMODE_CYCLE:
                      case Re.Animation.ANIMATIONLOOPMODE_CONSTANT:
                      case Re.Animation.ANIMATIONLOOPMODE_YOYO:
                        return e;
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE:
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
                        return e.addInPlace((t.offsetValue || Re._staticOffsetValueQuaternion).scale(t.repeatCount));
                    }
                    return e;
                  }
                  case Ee.ANIMATIONTYPE_SLERP_TANGENT_QUATERNION: {
                    const e = d
                      ? this.quaternionInterpolateFunctionWithSlerpControlPoints(l, a.outTangent, h, s.inTangent, m)
                      : this.quaternionInterpolateFunction(l, h, m);
                    switch (t.loopMode) {
                      case Re.Animation.ANIMATIONLOOPMODE_CYCLE:
                      case Re.Animation.ANIMATIONLOOPMODE_CONSTANT:
                      case Re.Animation.ANIMATIONLOOPMODE_YOYO:
                        return e;
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE:
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
                        return e.addInPlace((t.offsetValue || Re._staticOffsetValueQuaternion).scale(t.repeatCount));
                    }
                    return e;
                  }
                  case Re.Animation.ANIMATIONTYPE_VECTOR3: {
                    const e = d
                      ? this.vector3InterpolateFunctionWithControlPoints(l, a.outTangent, h, s.inTangent, m)
                      : this.vector3InterpolateFunction(l, h, m);
                    switch (t.loopMode) {
                      case Re.Animation.ANIMATIONLOOPMODE_CYCLE:
                      case Re.Animation.ANIMATIONLOOPMODE_CONSTANT:
                      case Re.Animation.ANIMATIONLOOPMODE_YOYO:
                        return e;
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE:
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
                        return e.add((t.offsetValue || Re._staticOffsetValueVector3).scale(t.repeatCount));
                    }
                    break;
                  }
                  case Re.Animation.ANIMATIONTYPE_VECTOR2: {
                    const e = d
                      ? this.vector2InterpolateFunctionWithControlPoints(l, a.outTangent, h, s.inTangent, m)
                      : this.vector2InterpolateFunction(l, h, m);
                    switch (t.loopMode) {
                      case Re.Animation.ANIMATIONLOOPMODE_CYCLE:
                      case Re.Animation.ANIMATIONLOOPMODE_CONSTANT:
                      case Re.Animation.ANIMATIONLOOPMODE_YOYO:
                        return e;
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE:
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
                        return e.add((t.offsetValue || Re._staticOffsetValueVector2).scale(t.repeatCount));
                    }
                    break;
                  }
                  case Re.Animation.ANIMATIONTYPE_SIZE:
                    switch (t.loopMode) {
                      case Re.Animation.ANIMATIONLOOPMODE_CYCLE:
                      case Re.Animation.ANIMATIONLOOPMODE_CONSTANT:
                      case Re.Animation.ANIMATIONLOOPMODE_YOYO:
                        return this.sizeInterpolateFunction(l, h, m);
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE:
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
                        return this.sizeInterpolateFunction(l, h, m).add(
                          (t.offsetValue || Re._staticOffsetValueSize).scale(t.repeatCount)
                        );
                    }
                    break;
                  case Re.Animation.ANIMATIONTYPE_COLOR3: {
                    const e = d
                      ? this.color3InterpolateFunctionWithControlPoints(l, a.outTangent, h, s.inTangent, m)
                      : this.color3InterpolateFunction(l, h, m);
                    switch (t.loopMode) {
                      case Re.Animation.ANIMATIONLOOPMODE_CYCLE:
                      case Re.Animation.ANIMATIONLOOPMODE_CONSTANT:
                      case Re.Animation.ANIMATIONLOOPMODE_YOYO:
                        return e;
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE:
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
                        return e.add((t.offsetValue || Re._staticOffsetValueColor3).scale(t.repeatCount));
                    }
                    break;
                  }
                  case Re.Animation.ANIMATIONTYPE_COLOR4: {
                    const e = d
                      ? this.color4InterpolateFunctionWithControlPoints(l, a.outTangent, h, s.inTangent, m)
                      : this.color4InterpolateFunction(l, h, m);
                    switch (t.loopMode) {
                      case Re.Animation.ANIMATIONLOOPMODE_CYCLE:
                      case Re.Animation.ANIMATIONLOOPMODE_CONSTANT:
                      case Re.Animation.ANIMATIONLOOPMODE_YOYO:
                        return e;
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE:
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
                        return e.add((t.offsetValue || Re._staticOffsetValueColor4).scale(t.repeatCount));
                    }
                    break;
                  }
                  case Re.Animation.ANIMATIONTYPE_MATRIX:
                    switch (t.loopMode) {
                      case Re.Animation.ANIMATIONLOOPMODE_CYCLE:
                      case Re.Animation.ANIMATIONLOOPMODE_CONSTANT:
                      case Re.Animation.ANIMATIONLOOPMODE_YOYO:
                        return Re.Animation.AllowMatricesInterpolation
                          ? this.matrixInterpolateFunction(l, h, m, t.workValue)
                          : l;
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE:
                      case Re.Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
                        return l;
                    }
                }
              return 0;
            }
            floatInterpolateFunctionWithControlPoints(e, t, n, i, o) {
              const r = Pe.Interpolate(t.x, i.x, t.y, i.y, o);
              return e * (1 - r) + n * r;
            }
            quaternionInterpolateFunctionWithControlPoints(e, t, n, i, o) {
              const r = Pe.Interpolate(t[0].x, i[0].x, t[0].y, i[0].y, o),
                a = Pe.Interpolate(t[1].x, i[1].x, t[1].y, i[1].y, o),
                s = Pe.Interpolate(t[2].x, i[2].x, t[2].y, i[2].y, o),
                l = Pe.Interpolate(t[3].x, i[3].x, t[3].y, i[3].y, o);
              return new E.Quaternion(
                e.x * (1 - r) + n.x * r,
                e.y * (1 - a) + n.y * a,
                e.z * (1 - s) + n.z * s,
                e.w * (1 - l) + n.w * l
              );
            }
            quaternionInterpolateFunctionWithSlerpControlPoints(e, t, n, i, o) {
              const r = Pe.Interpolate(t.x, i.x, t.y, i.y, o);
              return E.Quaternion.Slerp(e, n, r);
            }
            vector3InterpolateFunctionWithControlPoints(e, t, n, i, o) {
              const r = Pe.Interpolate(t[0].x, i[0].x, t[0].y, i[0].y, o),
                a = Pe.Interpolate(t[1].x, i[1].x, t[1].y, i[1].y, o),
                s = Pe.Interpolate(t[2].x, i[2].x, t[2].y, i[2].y, o);
              return new E.Vector3(e.x * (1 - r) + n.x * r, e.y * (1 - a) + n.y * a, e.z * (1 - s) + n.z * s);
            }
            vector2InterpolateFunctionWithControlPoints(e, t, n, i, o) {
              const r = Pe.Interpolate(t[0].x, i[0].x, t[0].y, i[0].y, o),
                a = Pe.Interpolate(t[1].x, i[1].x, t[1].y, i[1].y, o);
              return new E.Vector2(e.x * (1 - r) + n.x * r, e.y * (1 - a) + n.y * a);
            }
            color3InterpolateFunctionWithControlPoints(e, t, n, i, o) {
              const r = Pe.Interpolate(t[0].x, i[0].x, t[0].y, i[0].y, o),
                a = Pe.Interpolate(t[1].x, i[1].x, t[1].y, i[1].y, o),
                s = Pe.Interpolate(t[2].x, i[2].x, t[2].y, i[2].y, o);
              return new D.Color3(e.r * (1 - r) + n.r * r, e.g * (1 - a) + n.g * a, e.b * (1 - s) + n.b * s);
            }
            color4InterpolateFunctionWithControlPoints(e, t, n, i, o) {
              const r = Pe.Interpolate(t.r, i.r, t.g, i.g, o),
                a = Pe.Interpolate(t.b, i.b, t.g, i.g, o),
                s = Pe.Interpolate(t.b, i.b, t.g, i.g, o),
                l = Pe.Interpolate(t.a, i.a, t.g, i.g, o);
              return new D.Color4(
                e.r * (1 - r) + n.r * r,
                e.g * (1 - a) + n.g * a,
                e.b * (1 - s) + n.b * s,
                e.a * (1 - l) + n.a * l
              );
            }
          }
          function ke(e, t, n, i) {
            let o;
            o =
              0 === i
                ? 0
                : 0 === n
                ? i < 0
                  ? -1 / 0
                  : 1 / 0
                : 0 === e && 0 === t
                ? i / n
                : 0 === e
                ? i < 0
                  ? -1 / 0
                  : 1 / 0
                : 0 === t
                ? 0
                : (t * i) / (e * n);
            const r = (3 * Math.abs(i)) / n;
            return Math.max(-r, Math.min(r, o));
          }
          class Ne {
            name;
            positionAnimation;
            rotationAnimation;
            distanceAnimation;
            fovAnimation;
            startFrame;
            endFrame;
            constructor(e, t) {
              const n = (this.name = e.name);
              (this.positionAnimation = t.createPositionAnimation(n, e.cameraTrack)),
                (this.rotationAnimation = t.createRotationAnimation(n, e.cameraTrack)),
                (this.distanceAnimation = t.createDistanceAnimation(n, e.cameraTrack)),
                (this.fovAnimation = t.createFovAnimation(n, e.cameraTrack)),
                (this.startFrame = e.startFrame),
                (this.endFrame = e.endFrame);
            }
            createAnimationGroup(e) {
              const t = new Se.AnimationGroup(this.name, e.getScene());
              return (
                t.addTargetedAnimation(this.positionAnimation, e),
                t.addTargetedAnimation(this.rotationAnimation, e),
                t.addTargetedAnimation(this.distanceAnimation, e),
                t.addTargetedAnimation(this.fovAnimation, e),
                t
              );
            }
          }
          class De {
            createPositionAnimation(e, t) {
              const n = new Re.Animation(
                  e + "_camera_position",
                  "position",
                  30,
                  Re.Animation.ANIMATIONTYPE_VECTOR3,
                  Re.Animation.ANIMATIONLOOPMODE_CYCLE
                ),
                i = t.frameNumbers,
                o = t.positions,
                r = t.positionInterpolations,
                a = new Array(i.length);
              for (let e = 0; e < i.length; ++e) {
                const t = i[e],
                  n = 0 < e,
                  s = e + 1 < i.length ? i[e + 1] : 1 / 0,
                  l = t - (0 < e ? i[e - 1] : -30),
                  h = s - t,
                  d = h < 1.0001 ? Ce.AnimationKeyInterpolation.STEP : Ce.AnimationKeyInterpolation.NONE;
                a[e] = {
                  frame: t,
                  value: new E.Vector3(o[3 * e], o[3 * e + 1], o[3 * e + 2]),
                  inTangent: n
                    ? new E.Vector3(
                        ke(1 - r[12 * e + 1] / 127, 1 - r[12 * e + 3] / 127, l, o[3 * e] - o[3 * (e - 1)]),
                        ke(1 - r[12 * e + 5] / 127, 1 - r[12 * e + 7] / 127, l, o[3 * e + 1] - o[3 * (e - 1) + 1]),
                        ke(1 - r[12 * e + 9] / 127, 1 - r[12 * e + 11] / 127, l, o[3 * e + 2] - o[3 * (e - 1) + 2])
                      )
                    : void 0,
                  outTangent:
                    s < 1 / 0
                      ? new E.Vector3(
                          ke(r[12 * (e + 1) + 0] / 127, r[12 * (e + 1) + 2] / 127, h, o[3 * (e + 1)] - o[3 * e]),
                          ke(
                            r[12 * (e + 1) + 4] / 127,
                            r[12 * (e + 1) + 6] / 127,
                            h,
                            o[3 * (e + 1) + 1] - o[3 * e + 1]
                          ),
                          ke(
                            r[12 * (e + 1) + 8] / 127,
                            r[12 * (e + 1) + 10] / 127,
                            h,
                            o[3 * (e + 1) + 2] - o[3 * e + 2]
                          )
                        )
                      : void 0,
                  interpolation: d,
                  lockedTangent: !1,
                };
              }
              return n.setKeys(a), n;
            }
            createRotationAnimation(e, t) {
              const n = new Re.Animation(
                  e + "_camera_rotation",
                  "rotation",
                  30,
                  Re.Animation.ANIMATIONTYPE_VECTOR3,
                  Re.Animation.ANIMATIONLOOPMODE_CYCLE
                ),
                i = t.frameNumbers,
                o = t.rotations,
                r = t.rotationInterpolations,
                a = new Array(i.length);
              for (let e = 0; e < i.length; ++e) {
                const t = i[e],
                  n = 0 < e,
                  s = e + 1 < i.length ? i[e + 1] : 1 / 0,
                  l = t - (0 < e ? i[e - 1] : -30),
                  h = s - t,
                  d = h < 1.0001 ? Ce.AnimationKeyInterpolation.STEP : Ce.AnimationKeyInterpolation.NONE;
                a[e] = {
                  frame: t,
                  value: new E.Vector3(o[3 * e], o[3 * e + 1], o[3 * e + 2]),
                  inTangent: n
                    ? new E.Vector3(
                        ke(1 - r[4 * e + 1] / 127, 1 - r[4 * e + 3] / 127, l, o[3 * e] - o[3 * (e - 1)]),
                        ke(1 - r[4 * e + 1] / 127, 1 - r[4 * e + 3] / 127, l, o[3 * e + 1] - o[3 * (e - 1) + 1]),
                        ke(1 - r[4 * e + 1] / 127, 1 - r[4 * e + 3] / 127, l, o[3 * e + 2] - o[3 * (e - 1) + 2])
                      )
                    : void 0,
                  outTangent:
                    s < 1 / 0
                      ? new E.Vector3(
                          ke(r[4 * (e + 1) + 0] / 127, r[4 * (e + 1) + 2] / 127, h, o[3 * (e + 1)] - o[3 * e]),
                          ke(r[4 * (e + 1) + 0] / 127, r[4 * (e + 1) + 2] / 127, h, o[3 * (e + 1) + 1] - o[3 * e + 1]),
                          ke(r[4 * (e + 1) + 0] / 127, r[4 * (e + 1) + 2] / 127, h, o[3 * (e + 1) + 2] - o[3 * e + 2])
                        )
                      : void 0,
                  interpolation: d,
                  lockedTangent: !1,
                };
              }
              return n.setKeys(a), n;
            }
            createDistanceAnimation(e, t) {
              const n = new Re.Animation(
                  e + "_camera_distance",
                  "distance",
                  30,
                  Re.Animation.ANIMATIONTYPE_FLOAT,
                  Re.Animation.ANIMATIONLOOPMODE_CYCLE
                ),
                i = t.frameNumbers,
                o = t.distances,
                r = t.distanceInterpolations,
                a = new Array(i.length);
              for (let e = 0; e < i.length; ++e) {
                const t = i[e],
                  n = 0 < e,
                  s = e + 1 < i.length ? i[e + 1] : 1 / 0,
                  l = t - (0 < e ? i[e - 1] : -30),
                  h = s - t,
                  d = h < 1.0001 ? Ce.AnimationKeyInterpolation.STEP : Ce.AnimationKeyInterpolation.NONE;
                a[e] = {
                  frame: t,
                  value: o[e],
                  inTangent: n ? ke(1 - r[4 * e + 1] / 127, 1 - r[4 * e + 3] / 127, l, o[e] - o[e - 1]) : void 0,
                  outTangent:
                    s < 1 / 0 ? ke(r[4 * (e + 1) + 0] / 127, r[4 * (e + 1) + 2] / 127, h, o[e + 1] - o[e]) : void 0,
                  interpolation: d,
                  lockedTangent: !1,
                };
              }
              return n.setKeys(a), n;
            }
            createFovAnimation(e, t) {
              const n = new Re.Animation(
                  e + "_camera_fov",
                  "fov",
                  30,
                  Re.Animation.ANIMATIONTYPE_FLOAT,
                  Re.Animation.ANIMATIONLOOPMODE_CYCLE
                ),
                i = t.frameNumbers,
                o = t.fovs,
                r = t.fovInterpolations,
                a = Math.PI / 180,
                s = new Array(i.length);
              for (let e = 0; e < i.length; ++e) {
                const t = i[e],
                  n = 0 < e,
                  l = e + 1 < i.length ? i[e + 1] : 1 / 0,
                  h = t - (0 < e ? i[e - 1] : -30),
                  d = l - t,
                  c = d < 1.0001 ? Ce.AnimationKeyInterpolation.STEP : Ce.AnimationKeyInterpolation.NONE;
                s[e] = {
                  frame: t,
                  value: o[e] * a,
                  inTangent: n
                    ? ke(1 - r[4 * e + 1] / 127, 1 - r[4 * e + 3] / 127, h, o[e] * a - o[e - 1] * a)
                    : void 0,
                  outTangent:
                    l < 1 / 0
                      ? ke(r[4 * (e + 1) + 0] / 127, r[4 * (e + 1) + 2] / 127, d, o[e + 1] * a - o[e] * a)
                      : void 0,
                  interpolation: c,
                  lockedTangent: !1,
                };
              }
              return n.setKeys(s), n;
            }
          }
          class Le {
            createPositionAnimation(e, t) {
              const n = new Re.Animation(
                  e + "_camera_position",
                  "position",
                  30,
                  Re.Animation.ANIMATIONTYPE_VECTOR3,
                  Re.Animation.ANIMATIONLOOPMODE_CYCLE
                ),
                i = t.frameNumbers,
                o = t.positions,
                r = t.positionInterpolations,
                a = new Array(t.endFrame);
              let s = 0;
              const l = new E.Vector3(o[0], o[1], o[2]);
              for (let e = 0; e < i.length; ++e) {
                const t = i[e];
                a[t] = {
                  frame: t,
                  value: new E.Vector3(o[3 * e], o[3 * e + 1], o[3 * e + 2]),
                  interpolation:
                    t + 1 === i[e + 1] ? Ce.AnimationKeyInterpolation.STEP : Ce.AnimationKeyInterpolation.NONE,
                };
                const n = r[12 * e + 0] / 127,
                  h = r[12 * e + 1] / 127,
                  d = r[12 * e + 2] / 127,
                  c = r[12 * e + 3] / 127,
                  m = r[12 * e + 4] / 127,
                  u = r[12 * e + 5] / 127,
                  p = r[12 * e + 6] / 127,
                  g = r[12 * e + 7] / 127,
                  f = r[12 * e + 8] / 127,
                  _ = r[12 * e + 9] / 127,
                  b = r[12 * e + 10] / 127,
                  y = r[12 * e + 11] / 127;
                for (let i = s + 1; i < t; ++i) {
                  const r = (i - s) / (t - s),
                    A = Pe.Interpolate(n, h, d, c, r),
                    M = Pe.Interpolate(m, u, p, g, r),
                    T = Pe.Interpolate(f, _, b, y, r);
                  a[i] = {
                    frame: i,
                    value: new E.Vector3(
                      l.x + (o[3 * e] - l.x) * A,
                      l.y + (o[3 * e + 1] - l.y) * M,
                      l.z + (o[3 * e + 2] - l.z) * T
                    ),
                    interpolation: Ce.AnimationKeyInterpolation.NONE,
                  };
                }
                (s = t), l.set(o[3 * e], o[3 * e + 1], o[3 * e + 2]);
              }
              return n.setKeys(a), n;
            }
            createRotationAnimation(e, t) {
              const n = new Re.Animation(
                  e + "_camera_rotation",
                  "rotation",
                  30,
                  Re.Animation.ANIMATIONTYPE_VECTOR3,
                  Re.Animation.ANIMATIONLOOPMODE_CYCLE
                ),
                i = t.frameNumbers,
                o = t.rotations,
                r = t.rotationInterpolations,
                a = new Array(t.endFrame);
              let s = 0;
              const l = new E.Vector3(o[0], o[1], o[2]);
              for (let e = 0; e < i.length; ++e) {
                const t = i[e];
                a[t] = {
                  frame: t,
                  value: new E.Vector3(o[3 * e], o[3 * e + 1], o[3 * e + 2]),
                  interpolation:
                    t + 1 === i[e + 1] ? Ce.AnimationKeyInterpolation.STEP : Ce.AnimationKeyInterpolation.NONE,
                };
                const n = r[4 * e + 0] / 127,
                  h = r[4 * e + 1] / 127,
                  d = r[4 * e + 2] / 127,
                  c = r[4 * e + 3] / 127;
                for (let i = s + 1; i < t; ++i) {
                  const r = (i - s) / (t - s),
                    m = Pe.Interpolate(n, h, d, c, r);
                  a[i] = {
                    frame: i,
                    value: new E.Vector3(
                      l.x + (o[3 * e] - l.x) * m,
                      l.y + (o[3 * e + 1] - l.y) * m,
                      l.z + (o[3 * e + 2] - l.z) * m
                    ),
                    interpolation: Ce.AnimationKeyInterpolation.NONE,
                  };
                }
                (s = t), l.set(o[3 * e], o[3 * e + 1], o[3 * e + 2]);
              }
              return n.setKeys(a), n;
            }
            createDistanceAnimation(e, t) {
              const n = new Re.Animation(
                  e + "_camera_distance",
                  "distance",
                  30,
                  Re.Animation.ANIMATIONTYPE_FLOAT,
                  Re.Animation.ANIMATIONLOOPMODE_CYCLE
                ),
                i = t.frameNumbers,
                o = t.distances,
                r = t.distanceInterpolations,
                a = new Array(t.endFrame);
              let s = 0,
                l = o[0];
              for (let e = 0; e < i.length; ++e) {
                const t = i[e];
                a[t] = {
                  frame: t,
                  value: o[e],
                  interpolation:
                    t + 1 === i[e + 1] ? Ce.AnimationKeyInterpolation.STEP : Ce.AnimationKeyInterpolation.NONE,
                };
                const n = r[4 * e + 0] / 127,
                  h = r[4 * e + 1] / 127,
                  d = r[4 * e + 2] / 127,
                  c = r[4 * e + 3] / 127;
                for (let i = s + 1; i < t; ++i) {
                  const r = (i - s) / (t - s),
                    m = Pe.Interpolate(n, h, d, c, r);
                  a[i] = { frame: i, value: l + (o[e] - l) * m, interpolation: Ce.AnimationKeyInterpolation.NONE };
                }
                (s = t), (l = o[e]);
              }
              return n.setKeys(a), n;
            }
            createFovAnimation(e, t) {
              const n = new Re.Animation(
                  e + "_camera_fov",
                  "fov",
                  30,
                  Re.Animation.ANIMATIONTYPE_FLOAT,
                  Re.Animation.ANIMATIONLOOPMODE_CYCLE
                ),
                i = t.frameNumbers,
                o = t.fovs,
                r = t.fovInterpolations,
                a = Math.PI / 180,
                s = new Array(t.endFrame);
              let l = 0,
                h = o[0] * a;
              for (let e = 0; e < i.length; ++e) {
                const t = i[e];
                s[t] = {
                  frame: t,
                  value: o[e] * a,
                  interpolation:
                    t + 1 === i[e + 1] ? Ce.AnimationKeyInterpolation.STEP : Ce.AnimationKeyInterpolation.NONE,
                };
                const n = r[4 * e + 0] / 127,
                  d = r[4 * e + 1] / 127,
                  c = r[4 * e + 2] / 127,
                  m = r[4 * e + 3] / 127;
                for (let i = l + 1; i < t; ++i) {
                  const r = (i - l) / (t - l),
                    u = Pe.Interpolate(n, d, c, m, r);
                  s[i] = { frame: i, value: h + (o[e] * a - h) * u, interpolation: Ce.AnimationKeyInterpolation.NONE };
                }
                (l = t), (h = o[e] * a);
              }
              return n.setKeys(s), n;
            }
          }
          class Ue {
            createPositionAnimation(e, t) {
              const n = new Ee(
                  e + "_camera_position",
                  "position",
                  30,
                  Re.Animation.ANIMATIONTYPE_VECTOR3,
                  Re.Animation.ANIMATIONLOOPMODE_CYCLE
                ),
                i = t.frameNumbers,
                o = t.positions,
                r = t.positionInterpolations,
                a = new Array(i.length);
              for (let e = 0; e < i.length; ++e) {
                const t = i[e],
                  n = 0 < e,
                  s = e + 1 < i.length ? i[e + 1] : 1 / 0,
                  l = s - t < 1.0001 ? Ce.AnimationKeyInterpolation.STEP : 2;
                a[e] = {
                  frame: t,
                  value: new E.Vector3(o[3 * e], o[3 * e + 1], o[3 * e + 2]),
                  inTangent: n
                    ? [
                        new E.Vector2(r[12 * e + 1] / 127, r[12 * e + 3] / 127),
                        new E.Vector2(r[12 * e + 5] / 127, r[12 * e + 7] / 127),
                        new E.Vector2(r[12 * e + 9] / 127, r[12 * e + 11] / 127),
                      ]
                    : void 0,
                  outTangent:
                    s < 1 / 0
                      ? [
                          new E.Vector2(r[12 * (e + 1) + 0] / 127, r[12 * (e + 1) + 2] / 127),
                          new E.Vector2(r[12 * (e + 1) + 4] / 127, r[12 * (e + 1) + 6] / 127),
                          new E.Vector2(r[12 * (e + 1) + 8] / 127, r[12 * (e + 1) + 10] / 127),
                        ]
                      : void 0,
                  interpolation: l,
                  lockedTangent: !1,
                };
              }
              return n.setKeys(a), n;
            }
            createRotationAnimation(e, t) {
              const n = new Ee(
                  e + "_camera_rotation",
                  "rotation",
                  30,
                  Re.Animation.ANIMATIONTYPE_VECTOR3,
                  Re.Animation.ANIMATIONLOOPMODE_CYCLE
                ),
                i = t.frameNumbers,
                o = t.rotations,
                r = t.rotationInterpolations,
                a = new Array(i.length);
              for (let e = 0; e < i.length; ++e) {
                const t = i[e],
                  n = 0 < e,
                  s = e + 1 < i.length ? i[e + 1] : 1 / 0,
                  l = s - t < 1.0001 ? Ce.AnimationKeyInterpolation.STEP : 2;
                a[e] = {
                  frame: t,
                  value: new E.Vector3(o[3 * e], o[3 * e + 1], o[3 * e + 2]),
                  inTangent: n
                    ? [
                        new E.Vector2(r[4 * e + 1] / 127, r[4 * e + 3] / 127),
                        new E.Vector2(r[4 * e + 1] / 127, r[4 * e + 3] / 127),
                        new E.Vector2(r[4 * e + 1] / 127, r[4 * e + 3] / 127),
                      ]
                    : void 0,
                  outTangent:
                    s < 1 / 0
                      ? [
                          new E.Vector2(r[4 * (e + 1) + 0] / 127, r[4 * (e + 1) + 2] / 127),
                          new E.Vector2(r[4 * (e + 1) + 0] / 127, r[4 * (e + 1) + 2] / 127),
                          new E.Vector2(r[4 * (e + 1) + 0] / 127, r[4 * (e + 1) + 2] / 127),
                        ]
                      : void 0,
                  interpolation: l,
                  lockedTangent: !1,
                };
              }
              return n.setKeys(a), n;
            }
            createDistanceAnimation(e, t) {
              const n = new Ee(
                  e + "_camera_distance",
                  "distance",
                  30,
                  Re.Animation.ANIMATIONTYPE_FLOAT,
                  Re.Animation.ANIMATIONLOOPMODE_CYCLE
                ),
                i = t.frameNumbers,
                o = t.distances,
                r = t.distanceInterpolations,
                a = new Array(i.length);
              for (let e = 0; e < i.length; ++e) {
                const t = i[e],
                  n = 0 < e,
                  s = e + 1 < i.length ? i[e + 1] : 1 / 0,
                  l = s - t < 1.0001 ? Ce.AnimationKeyInterpolation.STEP : 2;
                a[e] = {
                  frame: t,
                  value: o[e],
                  inTangent: n ? new E.Vector2(r[4 * e + 1] / 127, r[4 * e + 3] / 127) : void 0,
                  outTangent: s < 1 / 0 ? new E.Vector2(r[4 * (e + 1) + 0] / 127, r[4 * (e + 1) + 2] / 127) : void 0,
                  interpolation: l,
                  lockedTangent: !1,
                };
              }
              return n.setKeys(a), n;
            }
            createFovAnimation(e, t) {
              const n = new Ee(
                  e + "_camera_fov",
                  "fov",
                  30,
                  Re.Animation.ANIMATIONTYPE_FLOAT,
                  Re.Animation.ANIMATIONLOOPMODE_CYCLE
                ),
                i = t.frameNumbers,
                o = t.fovs,
                r = t.fovInterpolations,
                a = Math.PI / 180,
                s = new Array(i.length);
              for (let e = 0; e < i.length; ++e) {
                const t = i[e],
                  n = 0 < e,
                  l = e + 1 < i.length ? i[e + 1] : 1 / 0,
                  h = l - t < 1.0001 ? Ce.AnimationKeyInterpolation.STEP : 2;
                s[e] = {
                  frame: t,
                  value: o[e] * a,
                  inTangent: n ? new E.Vector2(r[4 * e + 1] / 127, r[4 * e + 3] / 127) : void 0,
                  outTangent: l < 1 / 0 ? new E.Vector2(r[4 * (e + 1) + 0] / 127, r[4 * (e + 1) + 2] / 127) : void 0,
                  interpolation: h,
                  lockedTangent: !1,
                };
              }
              return n.setKeys(s), n;
            }
          }
          function Ve() {
            return { key: 0, repeatCount: 0, loopMode: Re.Animation.ANIMATIONLOOPMODE_CONSTANT };
          }
          class We {
            animation;
            _positionAnimationState;
            _rotationAnimationState;
            _distanceAnimationState;
            _fovAnimationState;
            _camera;
            constructor(e, t) {
              (this.animation = e),
                (this._positionAnimationState = Ve()),
                (this._rotationAnimationState = Ve()),
                (this._distanceAnimationState = Ve()),
                (this._fovAnimationState = Ve()),
                (this._camera = t);
            }
            animate(e) {
              const t = this.animation,
                n = this._camera;
              n.position.copyFrom(t.positionAnimation._interpolate(e, this._positionAnimationState)),
                n.rotation.copyFrom(t.rotationAnimation._interpolate(e, this._rotationAnimationState)),
                (n.distance = t.distanceAnimation._interpolate(e, this._distanceAnimationState)),
                (n.fov = t.fovAnimation._interpolate(e, this._fovAnimationState));
            }
            static Create(e, t) {
              return new We(e, t);
            }
          }
          Ne.prototype.createRuntimeCameraAnimation = function (e) {
            return We.Create(this, e);
          };
          var ze = H(4619);
          class Ke extends Oe {
            animation;
            boneBindIndexMap;
            movableBoneBindIndexMap;
            _morphController;
            morphBindIndexMap;
            _meshes;
            ikSolverBindIndexMap;
            _ikSolverStates;
            _materialRecompileInduceInfo;
            constructor(e, t, n, i, o, r, a, s, l) {
              super(),
                (this.animation = e),
                (this.boneBindIndexMap = t),
                (this.movableBoneBindIndexMap = n),
                (this._morphController = i),
                (this.morphBindIndexMap = o),
                (this._meshes = r),
                (this.ikSolverBindIndexMap = a),
                (this._ikSolverStates = s),
                (this._materialRecompileInduceInfo = l);
            }
            static _BonePositionA = new E.Vector3();
            static _BonePositionB = new E.Vector3();
            static _BonePosition = new E.Vector3();
            static _BoneRotationA = new E.Quaternion();
            static _BoneRotationB = new E.Quaternion();
            animate(e) {
              const t = this.animation,
                n = t.boneTracks;
              if (0 < n.length) {
                const t = this.boneBindIndexMap;
                for (let i = 0; i < n.length; ++i) {
                  const o = t[i];
                  if (null === o) continue;
                  const r = n[i],
                    a = Math.max(r.startFrame, Math.min(r.endFrame, e)),
                    s = this._upperBoundFrameIndex(a, r),
                    l = s - 1,
                    h = r.frameNumbers[s];
                  if (void 0 === h) {
                    const e = r.rotations;
                    o.setRotationQuaternion(
                      Ke._BoneRotationB.set(e[4 * l], e[4 * l + 1], e[4 * l + 2], e[4 * l + 3]),
                      ze.Space.LOCAL
                    );
                  } else {
                    const e = r.frameNumbers[l],
                      t = (a - e) / (h - e),
                      n = r.rotations,
                      i = r.rotationInterpolations,
                      d = Ke._BoneRotationA.set(n[4 * l], n[4 * l + 1], n[4 * l + 2], n[4 * l + 3]),
                      c = Ke._BoneRotationB.set(n[4 * s], n[4 * s + 1], n[4 * s + 2], n[4 * s + 3]),
                      m = Pe.Interpolate(i[4 * s] / 127, i[4 * s + 1] / 127, i[4 * s + 2] / 127, i[4 * s + 3] / 127, t);
                    E.Quaternion.SlerpToRef(d, c, m, d), o.setRotationQuaternion(d, ze.Space.LOCAL);
                  }
                }
              }
              const i = t.movableBoneTracks;
              if (0 < i.length) {
                const t = this.movableBoneBindIndexMap;
                for (let n = 0; n < i.length; ++n) {
                  const o = t[n];
                  if (null === o) continue;
                  const r = i[n],
                    a = Math.max(r.startFrame, Math.min(r.endFrame, e)),
                    s = this._upperBoundFrameIndex(a, r),
                    l = s - 1,
                    h = r.frameNumbers[s];
                  if (void 0 === h) {
                    const e = r.positions;
                    o.getRestMatrix().getTranslationToRef(Ke._BonePosition),
                      (o.position = Ke._BonePosition.addInPlaceFromFloats(e[3 * l], e[3 * l + 1], e[3 * l + 2]));
                    const t = r.rotations;
                    o.setRotationQuaternion(
                      Ke._BoneRotationB.set(t[4 * l], t[4 * l + 1], t[4 * l + 2], t[4 * l + 3]),
                      ze.Space.LOCAL
                    );
                  } else {
                    const e = r.frameNumbers[l],
                      t = (a - e) / (h - e),
                      n = r.positions,
                      i = r.positionInterpolations,
                      d = Ke._BonePositionA.set(n[3 * l], n[3 * l + 1], n[3 * l + 2]),
                      c = Ke._BonePositionB.set(n[3 * s], n[3 * s + 1], n[3 * s + 2]),
                      m = Pe.Interpolate(
                        i[12 * s] / 127,
                        i[12 * s + 1] / 127,
                        i[12 * s + 2] / 127,
                        i[12 * s + 3] / 127,
                        t
                      ),
                      u = Pe.Interpolate(
                        i[12 * s + 4] / 127,
                        i[12 * s + 5] / 127,
                        i[12 * s + 6] / 127,
                        i[12 * s + 7] / 127,
                        t
                      ),
                      p = Pe.Interpolate(
                        i[12 * s + 8] / 127,
                        i[12 * s + 9] / 127,
                        i[12 * s + 10] / 127,
                        i[12 * s + 11] / 127,
                        t
                      );
                    (d.x += (c.x - d.x) * m),
                      (d.y += (c.y - d.y) * u),
                      (d.z += (c.z - d.z) * p),
                      o.getRestMatrix().getTranslationToRef(Ke._BonePosition),
                      (o.position = Ke._BonePosition.addInPlace(d));
                    const g = r.rotations,
                      f = r.rotationInterpolations,
                      _ = Ke._BoneRotationA.set(g[4 * l], g[4 * l + 1], g[4 * l + 2], g[4 * l + 3]),
                      b = Ke._BoneRotationB.set(g[4 * s], g[4 * s + 1], g[4 * s + 2], g[4 * s + 3]),
                      y = Pe.Interpolate(f[4 * s] / 127, f[4 * s + 1] / 127, f[4 * s + 2] / 127, f[4 * s + 3] / 127, t);
                    E.Quaternion.SlerpToRef(_, b, y, _), o.setRotationQuaternion(_, ze.Space.LOCAL);
                  }
                }
              }
              const o = t.morphTracks;
              if (0 < o.length) {
                const t = this._morphController,
                  n = this.morphBindIndexMap;
                for (let i = 0; i < o.length; ++i) {
                  const r = n[i];
                  if (null === r) continue;
                  const a = o[i],
                    s = Math.max(a.startFrame, Math.min(a.endFrame, e)),
                    l = this._upperBoundFrameIndex(s, a),
                    h = l - 1,
                    d = a.frameNumbers[l];
                  if (void 0 === d) {
                    const e = a.weights[h];
                    for (let n = 0; n < r.length; ++n) t.setMorphWeightFromIndex(r[n], e);
                  } else {
                    const e = a.frameNumbers[h],
                      n = (s - e) / (d - e),
                      i = a.weights[h],
                      o = i + (a.weights[l] - i) * n;
                    for (let e = 0; e < r.length; ++e) t.setMorphWeightFromIndex(r[e], o);
                  }
                }
              }
              if (0 < t.propertyTrack.frameNumbers.length) {
                const n = t.propertyTrack,
                  i = Math.max(n.startFrame, Math.min(n.endFrame, e)),
                  o = this._upperBoundFrameIndex(i, n) - 1,
                  r = n.visibles[o],
                  a = this._meshes;
                for (let e = 0; e < a.length; ++e) a[e].visibility = r;
                const s = this._ikSolverStates.ikSolverStates,
                  l = this.ikSolverBindIndexMap;
                for (let e = 0; e < l.length; ++e) {
                  const t = l[e];
                  if (-1 === t) continue;
                  const i = n.getIkState(e);
                  s[t] = i[o];
                }
              }
            }
            induceMaterialRecompile(e, t) {
              null !== this._materialRecompileInduceInfo &&
                (Ke.InduceMaterialRecompile(
                  this._materialRecompileInduceInfo,
                  this._morphController,
                  this.morphBindIndexMap,
                  t
                ),
                e && Ie(this._morphController, this.morphBindIndexMap),
                (this._materialRecompileInduceInfo = null));
            }
            static Create(e, t, n, i) {
              const o = t.skeleton.bones,
                r = new Map();
              if (void 0 === n) for (let e = 0; e < o.length; ++e) r.set(o[e].name, e);
              else for (let e = 0; e < o.length; ++e) r.set(n[o[e].name] ?? o[e].name, e);
              const a = new Array(e.boneTracks.length),
                s = e.boneTracks;
              for (let e = 0; e < s.length; ++e) {
                const t = s[e],
                  n = r.get(t.name);
                void 0 === n ? (i?.warn(`Binding failed: bone ${t.name} not found`), (a[e] = null)) : (a[e] = o[n]);
              }
              const l = new Array(e.movableBoneTracks.length),
                h = e.movableBoneTracks;
              for (let e = 0; e < h.length; ++e) {
                const t = h[e],
                  n = r.get(t.name);
                void 0 === n ? (i?.warn(`Binding failed: bone ${t.name} not found`), (l[e] = null)) : (l[e] = o[n]);
              }
              const d = t.morph,
                c = new Array(e.morphTracks.length),
                m = e.morphTracks;
              for (let e = 0; e < m.length; ++e) {
                const t = m[e],
                  o = n?.[t.name] ?? t.name,
                  r = d.getMorphIndices(o);
                void 0 === r ? (i?.warn(`Binding failed: morph ${o} not found`), (c[e] = null)) : (c[e] = r);
              }
              const u = t.runtimeBones,
                p = new Int32Array(e.propertyTrack.ikBoneNames.length),
                g = e.propertyTrack.ikBoneNames;
              for (let e = 0; e < g.length; ++e) {
                const t = g[e],
                  n = r.get(t);
                if (void 0 === n) i?.warn(`Binding failed: IK bone ${t} not found`), (p[e] = -1);
                else {
                  const o = u[n].ikSolverIndex;
                  -1 === o ? (i?.warn(`Binding failed: IK solver for bone ${t} not found`), (p[e] = -1)) : (p[e] = o);
                }
              }
              return new Ke(e, a, l, d, c, t.mesh.metadata.meshes, p, t, t.mesh.metadata.materials);
            }
            static InduceMaterialRecompile = xe;
          }
          Be.prototype.createRuntimeModelAnimation = function (e, t, n) {
            return Ke.Create(this, e, t, n);
          };
          class je {
            _morphController;
            _morphIndices;
            constructor(e, t) {
              (this._morphController = e), (this._morphIndices = t);
            }
            get influence() {
              return this._morphController.getMorphWeightFromIndex(this._morphIndices[0]);
            }
            set influence(e) {
              for (let t = 0; t < this._morphIndices.length; ++t)
                this._morphController.setMorphWeightFromIndex(this._morphIndices[t], e);
            }
          }
          class Ye {
            _enabled;
            _ikSolverState;
            constructor(e, t) {
              (this._enabled = e[t]), (this._ikSolverState = new Uint8Array(e.buffer, e.byteOffset + t, 1));
            }
            get enabled() {
              return this._enabled;
            }
            set enabled(e) {
              (this._enabled = e), (this._ikSolverState[0] = 0.5 < e ? 1 : 0);
            }
          }
          class Qe {
            _meshes;
            constructor(e) {
              this._meshes = e;
            }
            get visibility() {
              return this._meshes[0].visibility;
            }
            set visibility(e) {
              for (let t = 0; t < this._meshes.length; ++t) this._meshes[t].visibility = e;
            }
          }
          class qe {
            name;
            bonePositionAnimations;
            bonePositionAnimationBindMap;
            boneRotationAnimations;
            boneRotationAnimationBindMap;
            morphAnimations;
            morphAnimationBindMap;
            propertyAnimations;
            visibilityAnimation;
            propertyAnimationBindMap;
            startFrame;
            endFrame;
            constructor(e, t) {
              const n = (this.name = e.name),
                i = e.movableBoneTracks,
                o = (this.bonePositionAnimations = new Array(i.length)),
                r = (this.bonePositionAnimationBindMap = new Array(i.length));
              for (let e = 0; e < i.length; ++e) (o[e] = t.createBonePositionAnimation(n, i[e])), (r[e] = i[e].name);
              const a = e.boneTracks,
                s = (this.boneRotationAnimations = new Array(a.length + i.length)),
                l = (this.boneRotationAnimationBindMap = new Array(a.length + i.length));
              for (let e = 0; e < a.length; ++e) (s[e] = t.createBoneRotationAnimation(n, a[e])), (l[e] = a[e].name);
              for (let e = 0; e < i.length; ++e)
                (s[a.length + e] = t.createBoneRotationAnimation(n, i[e])), (l[a.length + e] = i[e].name);
              const h = e.morphTracks,
                d = (this.morphAnimations = new Array(h.length)),
                c = (this.morphAnimationBindMap = new Array(h.length));
              for (let e = 0; e < h.length; ++e) (d[e] = t.createMorphAnimation(n, h[e])), (c[e] = h[e].name);
              (this.visibilityAnimation = t.createVisibilityAnimation(n, e.propertyTrack)),
                (this.propertyAnimations = t.createPropertyAnimation(n, e.propertyTrack)),
                (this.propertyAnimationBindMap = e.propertyTrack.ikBoneNames),
                (this.startFrame = e.startFrame),
                (this.endFrame = e.endFrame);
            }
            createAnimationGroup(e) {
              const t = new Se.AnimationGroup(this.name, e.mesh.getScene(), 1);
              t.isAdditive = !0;
              const n = new Map(),
                i = e.skeleton.bones;
              for (let e = 0; e < i.length; ++e) n.set(i[e].name, e);
              const o = this.bonePositionAnimations,
                r = this.bonePositionAnimationBindMap;
              for (let e = 0; e < o.length; ++e) {
                const a = n.get(r[e]);
                void 0 !== a && t.addTargetedAnimation(o[e], i[a]);
              }
              const a = this.boneRotationAnimations,
                s = this.boneRotationAnimationBindMap;
              for (let e = 0; e < a.length; ++e) {
                const o = n.get(s[e]);
                void 0 !== o && t.addTargetedAnimation(a[e], i[o]);
              }
              const l = this.morphAnimations,
                h = this.morphAnimationBindMap,
                d = e.morph;
              for (let e = 0; e < l.length; ++e) {
                const n = d.getMorphIndices(h[e]);
                void 0 !== n && t.addTargetedAnimation(l[e], new je(d, n));
              }
              const c = e.runtimeBones,
                m = this.propertyAnimations,
                u = this.propertyAnimationBindMap,
                p = e.ikSolverStates;
              for (let e = 0; e < m.length; ++e) {
                const i = n.get(u[e]);
                if (void 0 !== i) {
                  const n = c[i].ikSolverIndex;
                  -1 !== n && t.addTargetedAnimation(m[e], new Ye(p, n));
                }
              }
              const g = this.visibilityAnimation;
              return (
                null !== g &&
                  0 !== e.mesh.metadata.meshes.length &&
                  t.addTargetedAnimation(g, new Qe(e.mesh.metadata.meshes)),
                t
              );
            }
          }
          class He {
            createMorphAnimation(e, t) {
              const n = new Re.Animation(
                  e + "_morph_" + t.name,
                  "influence",
                  30,
                  Re.Animation.ANIMATIONTYPE_FLOAT,
                  Re.Animation.ANIMATIONLOOPMODE_CYCLE
                ),
                i = t.frameNumbers,
                o = t.weights,
                r = new Array(i.length);
              for (let e = 0; e < i.length; ++e)
                r[e] = { frame: i[e], value: o[e], interpolation: Ce.AnimationKeyInterpolation.NONE };
              return n.setKeys(r), n;
            }
            createVisibilityAnimation(e, t) {
              const n = new Re.Animation(
                  e + "_visibility",
                  "visibility",
                  30,
                  Re.Animation.ANIMATIONTYPE_FLOAT,
                  Re.Animation.ANIMATIONLOOPMODE_CYCLE
                ),
                i = t.frameNumbers,
                o = t.visibles,
                r = new Array(i.length);
              for (let e = 0; e < i.length; ++e)
                r[e] = { frame: i[e], value: o[e] - 1, interpolation: Ce.AnimationKeyInterpolation.STEP };
              return n.setKeys(r), 0 === i.length || (1 === i.length && 1 === o[0]) ? null : n;
            }
            createPropertyAnimation(e, t) {
              const n = new Array(t.ikBoneNames.length),
                i = t.ikBoneNames;
              for (let o = 0; o < i.length; ++o) {
                const r = (n[o] = new Re.Animation(
                    e + "_ik_" + i[o],
                    "enabled",
                    30,
                    Re.Animation.ANIMATIONTYPE_FLOAT,
                    Re.Animation.ANIMATIONLOOPMODE_CYCLE
                  )),
                  a = t.frameNumbers,
                  s = t.getIkState(o),
                  l = new Array(a.length);
                for (let e = 0; e < a.length; ++e)
                  l[e] = { frame: a[e], value: s[e] - 1, interpolation: Ce.AnimationKeyInterpolation.STEP };
                r.setKeys(l);
              }
              return n;
            }
          }
          class Ge extends He {
            createBonePositionAnimation(e, t) {
              const n = new Re.Animation(
                  e + "_bone_position_" + t.name,
                  "position",
                  30,
                  Re.Animation.ANIMATIONTYPE_VECTOR3,
                  Re.Animation.ANIMATIONLOOPMODE_CYCLE
                ),
                i = t.frameNumbers,
                o = t.positions,
                r = t.positionInterpolations,
                a = new Array(i.length);
              for (let e = 0; e < i.length; ++e) {
                const t = i[e],
                  n = 0 < e,
                  s = e + 1 < i.length ? i[e + 1] : 1 / 0,
                  l = t - (0 < e ? i[e - 1] : -30),
                  h = s - t;
                a[e] = {
                  frame: t,
                  value: new E.Vector3(o[3 * e], o[3 * e + 1], o[3 * e + 2]),
                  inTangent: n
                    ? new E.Vector3(
                        ke(1 - r[12 * e + 1] / 127, 1 - r[12 * e + 3] / 127, l, o[3 * e] - o[3 * (e - 1)]),
                        ke(1 - r[12 * e + 5] / 127, 1 - r[12 * e + 7] / 127, l, o[3 * e + 1] - o[3 * (e - 1) + 1]),
                        ke(1 - r[12 * e + 9] / 127, 1 - r[12 * e + 11] / 127, l, o[3 * e + 2] - o[3 * (e - 1) + 2])
                      )
                    : void 0,
                  outTangent:
                    s < 1 / 0
                      ? new E.Vector3(
                          ke(r[12 * (e + 1) + 0] / 127, r[12 * (e + 1) + 2] / 127, h, o[3 * (e + 1)] - o[3 * e]),
                          ke(
                            r[12 * (e + 1) + 4] / 127,
                            r[12 * (e + 1) + 6] / 127,
                            h,
                            o[3 * (e + 1) + 1] - o[3 * e + 1]
                          ),
                          ke(
                            r[12 * (e + 1) + 8] / 127,
                            r[12 * (e + 1) + 10] / 127,
                            h,
                            o[3 * (e + 1) + 2] - o[3 * e + 2]
                          )
                        )
                      : void 0,
                  interpolation: Ce.AnimationKeyInterpolation.NONE,
                  lockedTangent: !1,
                };
              }
              return n.setKeys(a), n;
            }
            _minimizeRotationDifference(e, t) {
              E.Quaternion.Dot(e, t) < 0 && ((e.x = -e.x), (e.y = -e.y), (e.z = -e.z), (e.w = -e.w));
            }
            createBoneRotationAnimation(e, t) {
              const n = new Re.Animation(
                  e + "_bone_rotation_" + t.name,
                  "rotationQuaternion",
                  30,
                  Re.Animation.ANIMATIONTYPE_QUATERNION,
                  Re.Animation.ANIMATIONLOOPMODE_CYCLE
                ),
                i = t.frameNumbers,
                o = t.rotations,
                r = t.rotationInterpolations;
              let a = new E.Quaternion(0, 0, 0, 0);
              const s = new Array(i.length);
              for (let e = 0; e < i.length; ++e) {
                const t = i[e],
                  n = 0 < e,
                  l = e + 1 < i.length ? i[e + 1] : 1 / 0,
                  h = t - (0 < e ? i[e - 1] : -30),
                  d = l - t,
                  c = new E.Quaternion(o[4 * e], o[4 * e + 1], o[4 * e + 2], o[4 * e + 3]);
                this._minimizeRotationDifference(c, a);
                const m = new E.Quaternion(o[4 * (e + 1)], o[4 * (e + 1) + 1], o[4 * (e + 1) + 2], o[4 * (e + 1) + 3]);
                this._minimizeRotationDifference(m, c),
                  (s[e] = {
                    frame: t,
                    value: c,
                    inTangent: n
                      ? new E.Quaternion(
                          ke(1 - r[4 * e + 1] / 127, 1 - r[4 * e + 3] / 127, h, c.x - a.x),
                          ke(1 - r[4 * e + 1] / 127, 1 - r[4 * e + 3] / 127, h, c.y - a.y),
                          ke(1 - r[4 * e + 1] / 127, 1 - r[4 * e + 3] / 127, h, c.z - a.z),
                          ke(1 - r[4 * e + 1] / 127, 1 - r[4 * e + 3] / 127, h, c.w - a.w)
                        )
                      : void 0,
                    outTangent:
                      l < 1 / 0
                        ? new E.Quaternion(
                            ke(r[4 * (e + 1) + 0] / 127, r[4 * (e + 1) + 2] / 127, d, m.x - c.x),
                            ke(r[4 * (e + 1) + 0] / 127, r[4 * (e + 1) + 2] / 127, d, m.y - c.y),
                            ke(r[4 * (e + 1) + 0] / 127, r[4 * (e + 1) + 2] / 127, d, m.z - c.z),
                            ke(r[4 * (e + 1) + 0] / 127, r[4 * (e + 1) + 2] / 127, d, m.w - c.w)
                          )
                        : void 0,
                    interpolation: Ce.AnimationKeyInterpolation.NONE,
                    lockedTangent: !1,
                  }),
                  (a = c);
              }
              return n.setKeys(s), n;
            }
          }
          class $e extends He {
            createBonePositionAnimation(e, t) {
              const n = new Re.Animation(
                  e + "_bone_position_" + t.name,
                  "position",
                  30,
                  Re.Animation.ANIMATIONTYPE_VECTOR3,
                  Re.Animation.ANIMATIONLOOPMODE_CYCLE
                ),
                i = t.frameNumbers,
                o = t.positions,
                r = t.positionInterpolations,
                a = new Array(t.endFrame);
              let s = 0;
              const l = new E.Vector3(o[0], o[1], o[2]);
              for (let e = 0; e < i.length; ++e) {
                const t = i[e];
                a[t] = { frame: t, value: new E.Vector3(o[3 * e], o[3 * e + 1], o[3 * e + 2]) };
                const n = r[12 * e + 0] / 127,
                  h = r[12 * e + 1] / 127,
                  d = r[12 * e + 2] / 127,
                  c = r[12 * e + 3] / 127,
                  m = r[12 * e + 4] / 127,
                  u = r[12 * e + 5] / 127,
                  p = r[12 * e + 6] / 127,
                  g = r[12 * e + 7] / 127,
                  f = r[12 * e + 8] / 127,
                  _ = r[12 * e + 9] / 127,
                  b = r[12 * e + 10] / 127,
                  y = r[12 * e + 11] / 127;
                for (let i = s + 1; i < t; ++i) {
                  const r = (i - s) / (t - s),
                    A = Pe.Interpolate(n, h, d, c, r),
                    M = Pe.Interpolate(m, u, p, g, r),
                    T = Pe.Interpolate(f, _, b, y, r);
                  a[i] = {
                    frame: i,
                    value: new E.Vector3(
                      l.x + (o[3 * e] - l.x) * A,
                      l.y + (o[3 * e + 1] - l.y) * M,
                      l.z + (o[3 * e + 2] - l.z) * T
                    ),
                  };
                }
                (s = t), l.set(o[3 * e], o[3 * e + 1], o[3 * e + 2]);
              }
              return n.setKeys(a), n;
            }
            createBoneRotationAnimation(e, t) {
              const n = new Re.Animation(
                  e + "_bone_rotation_" + t.name,
                  "rotationQuaternion",
                  30,
                  Re.Animation.ANIMATIONTYPE_QUATERNION,
                  Re.Animation.ANIMATIONLOOPMODE_CYCLE
                ),
                i = t.frameNumbers,
                o = t.rotations,
                r = t.rotationInterpolations,
                a = new Array(t.endFrame);
              let s = 0;
              const l = new E.Quaternion(o[0], o[1], o[2], o[3]);
              for (let e = 0; e < i.length; ++e) {
                const t = i[e];
                a[t] = { frame: t, value: new E.Quaternion(o[4 * e], o[4 * e + 1], o[4 * e + 2], o[4 * e + 3]) };
                const n = r[4 * e + 0] / 127,
                  h = r[4 * e + 1] / 127,
                  d = r[4 * e + 2] / 127,
                  c = r[4 * e + 3] / 127;
                for (let i = s + 1; i < t; ++i) {
                  const r = (i - s) / (t - s),
                    m = Pe.Interpolate(n, h, d, c, r),
                    u = new E.Quaternion(o[4 * e], o[4 * e + 1], o[4 * e + 2], o[4 * e + 3]);
                  a[i] = { frame: i, value: E.Quaternion.SlerpToRef(l, u, m, u) };
                }
                (s = t), l.set(o[4 * e], o[4 * e + 1], o[4 * e + 2], o[4 * e + 3]);
              }
              return n.setKeys(a), n;
            }
          }
          class Xe extends He {
            createBonePositionAnimation(e, t) {
              const n = new Ee(
                  e + "_bone_position_" + t.name,
                  "position",
                  30,
                  Re.Animation.ANIMATIONTYPE_VECTOR3,
                  Re.Animation.ANIMATIONLOOPMODE_CYCLE
                ),
                i = t.frameNumbers,
                o = t.positions,
                r = t.positionInterpolations,
                a = new Array(i.length);
              for (let e = 0; e < i.length; ++e) {
                const t = i[e],
                  n = 0 < e,
                  s = e + 1 < i.length ? i[e + 1] : 1 / 0;
                a[e] = {
                  frame: t,
                  value: new E.Vector3(o[3 * e], o[3 * e + 1], o[3 * e + 2]),
                  inTangent: n
                    ? [
                        new E.Vector2(r[12 * e + 1] / 127, r[12 * e + 3] / 127),
                        new E.Vector2(r[12 * e + 5] / 127, r[12 * e + 7] / 127),
                        new E.Vector2(r[12 * e + 9] / 127, r[12 * e + 11] / 127),
                      ]
                    : void 0,
                  outTangent:
                    s < 1 / 0
                      ? [
                          new E.Vector2(r[12 * (e + 1) + 0] / 127, r[12 * (e + 1) + 2] / 127),
                          new E.Vector2(r[12 * (e + 1) + 4] / 127, r[12 * (e + 1) + 6] / 127),
                          new E.Vector2(r[12 * (e + 1) + 8] / 127, r[12 * (e + 1) + 10] / 127),
                        ]
                      : void 0,
                  interpolation: 2,
                  lockedTangent: !1,
                };
              }
              return n.setKeys(a), n;
            }
            createBoneRotationAnimation(e, t) {
              const n = new Ee(
                  e + "_bone_rotation_" + t.name,
                  "rotationQuaternion",
                  30,
                  Ee.ANIMATIONTYPE_SLERP_TANGENT_QUATERNION,
                  Re.Animation.ANIMATIONLOOPMODE_CYCLE
                ),
                i = t.frameNumbers,
                o = t.rotations,
                r = t.rotationInterpolations,
                a = new Array(i.length);
              for (let e = 0; e < i.length; ++e) {
                const t = i[e],
                  n = 0 < e,
                  s = e + 1 < i.length ? i[e + 1] : 1 / 0;
                a[e] = {
                  frame: t,
                  value: new E.Quaternion(o[4 * e], o[4 * e + 1], o[4 * e + 2], o[4 * e + 3]),
                  inTangent: n ? new E.Vector2(r[4 * e + 1] / 127, r[4 * e + 3] / 127) : void 0,
                  outTangent: s < 1 / 0 ? new E.Vector2(r[4 * (e + 1) + 0] / 127, r[4 * (e + 1) + 2] / 127) : void 0,
                  interpolation: 2,
                  lockedTangent: !1,
                };
              }
              return n.setKeys(a), n;
            }
          }
          class Je {
            animation;
            boneBindIndexMap;
            movableBoneBindIndexMap;
            _morphController;
            morphBindIndexMap;
            _meshes;
            ikSolverBindIndexMap;
            _ikSolverStates;
            _materialRecompileInduceInfo;
            _bonePositionAnimationStates;
            _boneRotationAnimationStates;
            _morphAnimationStates;
            _propertyAnimationStates;
            _visibilityAnimationState;
            constructor(e, t, n, i, o, r, a, s, l) {
              (this.animation = e),
                (this.boneBindIndexMap = t),
                (this.movableBoneBindIndexMap = n),
                (this._morphController = i),
                (this.morphBindIndexMap = o),
                (this._meshes = r),
                (this.ikSolverBindIndexMap = a),
                (this._ikSolverStates = s),
                (this._materialRecompileInduceInfo = l);
              const h = (this._bonePositionAnimationStates = new Array(e.bonePositionAnimations.length));
              for (let e = 0; e < h.length; ++e) h[e] = Ve();
              const d = (this._boneRotationAnimationStates = new Array(e.boneRotationAnimations.length));
              for (let e = 0; e < d.length; ++e) d[e] = Ve();
              const c = (this._morphAnimationStates = new Array(e.morphAnimations.length));
              for (let e = 0; e < c.length; ++e) c[e] = Ve();
              const m = (this._propertyAnimationStates = new Array(e.propertyAnimations.length));
              for (let e = 0; e < m.length; ++e) m[e] = Ve();
              this._visibilityAnimationState = Ve();
            }
            static _BonePosition = new E.Vector3();
            animate(e) {
              const t = this.animation,
                n = t.boneRotationAnimations,
                i = this.boneBindIndexMap;
              for (let t = 0; t < n.length; ++t) {
                const o = n[t],
                  r = i[t];
                null !== r &&
                  r.setRotationQuaternion(o._interpolate(e, this._boneRotationAnimationStates[t]), ze.Space.LOCAL);
              }
              const o = t.bonePositionAnimations,
                r = this.movableBoneBindIndexMap;
              for (let t = 0; t < o.length; ++t) {
                const n = o[t],
                  i = r[t];
                null !== i &&
                  (i.getRestMatrix().getTranslationToRef(Je._BonePosition),
                  (i.position = Je._BonePosition.addInPlace(n._interpolate(e, this._bonePositionAnimationStates[t]))));
              }
              const a = t.morphAnimations,
                s = this.morphBindIndexMap,
                l = this._morphController;
              for (let t = 0; t < a.length; ++t) {
                const n = a[t],
                  i = s[t];
                if (null === i) continue;
                const o = n._interpolate(e, this._morphAnimationStates[t]);
                for (let e = 0; e < i.length; ++e) l.setMorphWeightFromIndex(i[e], o);
              }
              if (null !== t.visibilityAnimation) {
                const n = this._meshes,
                  i = 1 + t.visibilityAnimation._interpolate(e, this._visibilityAnimationState);
                for (let e = 0; e < n.length; ++e) n[e].visibility = i;
              }
              const h = t.propertyAnimations,
                d = this.ikSolverBindIndexMap,
                c = this._ikSolverStates.ikSolverStates;
              for (let t = 0; t < h.length; ++t) {
                const n = h[t],
                  i = d[t];
                -1 !== i && (c[i] = 0 < 1 + n._interpolate(e, this._propertyAnimationStates[t]) ? 1 : 0);
              }
            }
            induceMaterialRecompile(e, t) {
              null !== this._materialRecompileInduceInfo &&
                (Je.InduceMaterialRecompile(
                  this._materialRecompileInduceInfo,
                  this._morphController,
                  this.morphBindIndexMap,
                  t
                ),
                e && Ie(this._morphController, this.morphBindIndexMap),
                (this._materialRecompileInduceInfo = null));
            }
            static Create(e, t, n, i) {
              const o = t.skeleton.bones,
                r = new Map();
              if (void 0 === n) for (let e = 0; e < o.length; ++e) r.set(o[e].name, e);
              else for (let e = 0; e < o.length; ++e) r.set(n[o[e].name] ?? o[e].name, e);
              const a = new Array(e.boneRotationAnimations.length),
                s = e.boneRotationAnimationBindMap;
              for (let e = 0; e < s.length; ++e) {
                const t = r.get(s[e]);
                void 0 === t ? (i?.warn(`Binding failed: bone ${s[e]} not found`), (a[e] = null)) : (a[e] = o[t]);
              }
              const l = new Array(e.bonePositionAnimations.length),
                h = e.bonePositionAnimationBindMap;
              for (let e = 0; e < h.length; ++e) {
                const t = r.get(h[e]);
                void 0 === t ? (i?.warn(`Binding failed: bone ${h[e]} not found`), (l[e] = null)) : (l[e] = o[t]);
              }
              const d = t.morph,
                c = new Array(e.morphAnimations.length),
                m = e.morphAnimationBindMap;
              for (let e = 0; e < m.length; ++e) {
                const t = m[e],
                  o = n?.[t] ?? t,
                  r = d.getMorphIndices(o);
                void 0 === r ? (i?.warn(`Binding failed: morph ${o} not found`), (c[e] = null)) : (c[e] = r);
              }
              const u = t.runtimeBones,
                p = new Int32Array(e.propertyAnimations.length),
                g = e.propertyAnimationBindMap;
              for (let e = 0; e < g.length; ++e) {
                const t = g[e],
                  n = r.get(t);
                if (void 0 === n) i?.warn(`Binding failed: IK bone ${t} not found`), (p[e] = -1);
                else {
                  const o = u[n].ikSolverIndex;
                  -1 === o ? (i?.warn(`Binding failed: IK solver for bone ${t} not found`), (p[e] = -1)) : (p[e] = o);
                }
              }
              return new Je(e, a, l, d, c, t.mesh.metadata.meshes, p, t, t.mesh.metadata.materials);
            }
            static InduceMaterialRecompile = xe;
          }
          qe.prototype.createRuntimeModelAnimation = function (e, t, n) {
            return Je.Create(this, e, t, n);
          };
          class Ze {
            trackType;
            name;
            frameNumbers;
            constructor(e, t, n, i, o) {
              (this.trackType = e),
                (this.name = t),
                (this.frameNumbers = void 0 === i ? new Uint32Array(n) : new Uint32Array(i, o, n));
            }
            validate() {
              for (let e = 1; e < this.frameNumbers.length; ++e)
                if (this.frameNumbers[e - 1] >= this.frameNumbers[e]) return !1;
              return !0;
            }
            get startFrame() {
              return 0 === this.frameNumbers.length ? 0 : this.frameNumbers[0];
            }
            get endFrame() {
              return 0 === this.frameNumbers.length ? 0 : this.frameNumbers[this.frameNumbers.length - 1];
            }
          }
          class et extends Ze {
            rotations;
            rotationInterpolations;
            constructor(e, t, n, i, o, r) {
              super("bone", e, t, n, i),
                void 0 === n
                  ? ((this.rotations = new Float32Array(4 * t)), (this.rotationInterpolations = new Uint8Array(4 * t)))
                  : ((this.rotations = new Float32Array(n, o, 4 * t)),
                    (this.rotationInterpolations = new Uint8Array(n, r, 4 * t)));
            }
          }
          class tt extends Ze {
            positions;
            positionInterpolations;
            rotations;
            rotationInterpolations;
            constructor(e, t, n, i, o, r, a, s) {
              super("movableBone", e, t, n, i),
                void 0 === n
                  ? ((this.positions = new Float32Array(3 * t)),
                    (this.positionInterpolations = new Uint8Array(12 * t)),
                    (this.rotations = new Float32Array(4 * t)),
                    (this.rotationInterpolations = new Uint8Array(4 * t)))
                  : ((this.positions = new Float32Array(n, o, 3 * t)),
                    (this.positionInterpolations = new Uint8Array(n, r, 12 * t)),
                    (this.rotations = new Float32Array(n, a, 4 * t)),
                    (this.rotationInterpolations = new Uint8Array(n, s, 4 * t)));
            }
          }
          class nt extends Ze {
            weights;
            constructor(e, t, n, i, o) {
              super("morph", e, t, n, i),
                (this.weights = void 0 === n ? new Float32Array(t) : new Float32Array(n, o, t));
            }
          }
          class it extends Ze {
            positions;
            positionInterpolations;
            rotations;
            rotationInterpolations;
            distances;
            distanceInterpolations;
            fovs;
            fovInterpolations;
            constructor(e, t, n, i, o, r, a, s, l, h, d) {
              super("camera", "cameraTrack", e, t, n),
                void 0 === t
                  ? ((this.positions = new Float32Array(3 * e)),
                    (this.positionInterpolations = new Uint8Array(12 * e)),
                    (this.rotations = new Float32Array(3 * e)),
                    (this.rotationInterpolations = new Uint8Array(4 * e)),
                    (this.distances = new Float32Array(e)),
                    (this.distanceInterpolations = new Uint8Array(4 * e)),
                    (this.fovs = new Float32Array(e)),
                    (this.fovInterpolations = new Uint8Array(4 * e)))
                  : ((this.positions = new Float32Array(t, i, 3 * e)),
                    (this.positionInterpolations = new Uint8Array(t, o, 12 * e)),
                    (this.rotations = new Float32Array(t, r, 3 * e)),
                    (this.rotationInterpolations = new Uint8Array(t, a, 4 * e)),
                    (this.distances = new Float32Array(t, s, e)),
                    (this.distanceInterpolations = new Uint8Array(t, l, 4 * e)),
                    (this.fovs = new Float32Array(t, h, e)),
                    (this.fovInterpolations = new Uint8Array(t, d, 4 * e)));
            }
          }
          class ot extends Ze {
            visibles;
            ikBoneNames;
            _ikStates;
            constructor(e, t, n, i, o, r) {
              if ((super("property", "propertyTrack", e, n, i), void 0 === n)) {
                (this.visibles = new Uint8Array(e)), (this.ikBoneNames = t), (this._ikStates = new Array(t.length));
                for (let n = 0; n < t.length; ++n) this._ikStates[n] = new Uint8Array(e);
              } else {
                (this.visibles = new Uint8Array(n, o, e)),
                  (this.ikBoneNames = t),
                  (this._ikStates = new Array(t.length)),
                  void 0 === r && (r = new Array(t.length));
                for (let i = 0; i < t.length; ++i) this._ikStates[i] = new Uint8Array(n, r[i], e);
              }
            }
            getIkState(e) {
              return this._ikStates[e];
            }
          }
          class rt {
            static _Map = new Map();
            instance;
            pool;
            _referenceCount;
            constructor(e, t) {
              (this.instance = e), (this.pool = t), (this._referenceCount = 0);
            }
            addReference() {
              this._referenceCount += 1;
            }
            removeReference() {
              (this._referenceCount -= 1),
                0 == this._referenceCount && (this.pool.free(), rt._Map.delete(this.instance));
            }
            static Get(e) {
              let t = this._Map.get(e);
              if (!t) {
                const n = e.createAnimationPool();
                (t = new rt(e, n)), this._Map.set(e, t);
              }
              return t;
            }
          }
          class at {
            trackType;
            name;
            _frameNumbers;
            get frameNumbers() {
              return this._frameNumbers.array;
            }
            constructor(e, t, n, i, o) {
              (this.trackType = e), (this.name = t), (this._frameNumbers = i.createTypedArray(Uint32Array, o, n));
            }
            get startFrame() {
              const e = this._frameNumbers.array;
              return 0 === e.length ? 0 : e[0];
            }
            get endFrame() {
              const e = this._frameNumbers.array;
              return 0 === e.length ? 0 : e[e.length - 1];
            }
          }
          class st extends at {
            _rotations;
            get rotations() {
              return this._rotations.array;
            }
            _rotationInterpolations;
            get rotationInterpolations() {
              return this._rotationInterpolations.array;
            }
            constructor(e, t, n, i, o, r) {
              super("bone", e, t, n, i),
                (this._rotations = n.createTypedArray(Float32Array, o, 4 * t)),
                (this._rotationInterpolations = n.createTypedArray(Uint8Array, r, 4 * t));
            }
          }
          class lt extends at {
            _positions;
            get positions() {
              return this._positions.array;
            }
            _positionInterpolations;
            get positionInterpolations() {
              return this._positionInterpolations.array;
            }
            _rotations;
            get rotations() {
              return this._rotations.array;
            }
            _rotationInterpolations;
            get rotationInterpolations() {
              return this._rotationInterpolations.array;
            }
            constructor(e, t, n, i, o, r, a, s) {
              super("movableBone", e, t, n, i),
                (this._positions = n.createTypedArray(Float32Array, o, 3 * t)),
                (this._positionInterpolations = n.createTypedArray(Uint8Array, r, 12 * t)),
                (this._rotations = n.createTypedArray(Float32Array, a, 4 * t)),
                (this._rotationInterpolations = n.createTypedArray(Uint8Array, s, 4 * t));
            }
          }
          class ht extends at {
            _weights;
            get weights() {
              return this._weights.array;
            }
            constructor(e, t, n, i, o) {
              super("morph", e, t, n, i), (this._weights = n.createTypedArray(Float32Array, o, t));
            }
          }
          class dt extends at {
            visibles;
            ikBoneNames;
            _ikStates;
            constructor(e, t, n, i, o, r) {
              if ((super("property", "propertyTrack", e, n, i), o.length !== e))
                throw new Error("visibles.length !== frameCount");
              (this.visibles = o),
                (this.ikBoneNames = t),
                (this._ikStates = new Array(t.length)),
                void 0 === r && (r = new Array(t.length));
              for (let i = 0; i < t.length; ++i) this._ikStates[i] = n.createTypedArray(Uint8Array, r[i], e);
            }
            getIkState(e) {
              return this._ikStates[e].array;
            }
          }
          class ct extends Be {
            ptr;
            _poolWrapper;
            _disposed;
            _bindedDispose;
            _disposeObservableObject;
            constructor(e, t, n) {
              const i = rt.Get(t);
              i.addReference();
              const o = i.pool,
                r = e.boneTracks,
                a = o.allocateLengthsBuffer(r.length),
                s = t.createTypedArray(Uint32Array, a, r.length).array;
              for (let e = 0; e < r.length; ++e) s[e] = r[e].frameNumbers.length;
              const l = o.createBoneTracks(a, s.length);
              o.deallocateLengthsBuffer(a, s.length);
              const h = new Array(r.length);
              for (let e = 0; e < r.length; ++e) {
                const n = r[e],
                  i = o.getBoneTrackFrameNumbers(l, e),
                  a = o.getBoneTrackRotations(l, e),
                  s = o.getBoneTrackRotationInterpolations(l, e),
                  d = new st(n.name, n.frameNumbers.length, t, i, a, s);
                d.frameNumbers.set(n.frameNumbers),
                  d.rotations.set(n.rotations),
                  d.rotationInterpolations.set(n.rotationInterpolations),
                  (h[e] = d);
              }
              const d = e.movableBoneTracks,
                c = o.allocateLengthsBuffer(d.length),
                m = t.createTypedArray(Uint32Array, c, d.length).array;
              for (let e = 0; e < d.length; ++e) m[e] = d[e].frameNumbers.length;
              const u = o.createMovableBoneTracks(c, m.length);
              o.deallocateLengthsBuffer(c, m.length);
              const p = new Array(d.length);
              for (let e = 0; e < d.length; ++e) {
                const n = d[e],
                  i = o.getMovableBoneTrackFrameNumbers(u, e),
                  r = o.getMovableBoneTrackPositions(u, e),
                  a = o.getMovableBoneTrackPositionInterpolations(u, e),
                  s = o.getMovableBoneTrackRotations(u, e),
                  l = o.getMovableBoneTrackRotationInterpolations(u, e),
                  h = new lt(n.name, n.frameNumbers.length, t, i, r, a, s, l);
                h.frameNumbers.set(n.frameNumbers),
                  h.positions.set(n.positions),
                  h.positionInterpolations.set(n.positionInterpolations),
                  h.rotations.set(n.rotations),
                  h.rotationInterpolations.set(n.rotationInterpolations),
                  (p[e] = h);
              }
              const g = e.morphTracks,
                f = o.allocateLengthsBuffer(g.length),
                _ = t.createTypedArray(Uint32Array, f, g.length).array;
              for (let e = 0; e < g.length; ++e) _[e] = g[e].frameNumbers.length;
              const b = o.createMorphTracks(f, _.length);
              o.deallocateLengthsBuffer(f, _.length);
              const y = new Array(g.length);
              for (let e = 0; e < g.length; ++e) {
                const n = g[e],
                  i = o.getMorphTrackFrameNumbers(b, e),
                  r = o.getMorphTrackWeights(b, e),
                  a = new ht(n.name, n.frameNumbers.length, t, i, r);
                a.frameNumbers.set(n.frameNumbers), a.weights.set(n.weights), (y[e] = a);
              }
              const A = e.propertyTrack,
                M = o.createAnimation(
                  l,
                  h.length,
                  u,
                  p.length,
                  b,
                  y.length,
                  A.frameNumbers.length,
                  A.ikBoneNames.length
                ),
                T = o.getPropertyTrackFrameNumbers(M);
              let w;
              A.visibles.buffer.byteLength - A.visibles.byteLength < A.visibles.byteLength
                ? (w = A.visibles)
                : ((w = new Uint8Array(A.visibles.length)), w.set(A.visibles));
              const x = [];
              for (let e = 0; e < A.ikBoneNames.length; ++e) {
                const t = o.getPropertyTrackIkStates(M, e);
                x.push(t);
              }
              const I = new dt(A.frameNumbers.length, A.ikBoneNames, t, T, w, x);
              I.frameNumbers.set(A.frameNumbers);
              for (let e = 0; e < A.ikBoneNames.length; ++e) {
                const t = A.getIkState(e);
                I.getIkState(e).set(t);
              }
              const v = e.cameraTrack,
                B =
                  v.frameNumbers.byteLength +
                  v.positions.byteLength +
                  v.positionInterpolations.byteLength +
                  v.rotations.byteLength +
                  v.rotationInterpolations.byteLength +
                  v.distances.byteLength +
                  v.distanceInterpolations.byteLength +
                  v.fovs.byteLength +
                  v.fovInterpolations.byteLength;
              let P;
              v.frameNumbers.buffer.byteLength - B < B
                ? (P = v)
                : ((P = new it(v.frameNumbers.length)),
                  P.frameNumbers.set(v.frameNumbers),
                  P.positions.set(v.positions),
                  P.positionInterpolations.set(v.positionInterpolations),
                  P.rotations.set(v.rotations),
                  P.rotationInterpolations.set(v.rotationInterpolations),
                  P.distances.set(v.distances),
                  P.distanceInterpolations.set(v.distanceInterpolations),
                  P.fovs.set(v.fovs),
                  P.fovInterpolations.set(v.fovInterpolations)),
                super(e.name, h, p, y, I, P),
                (this.ptr = M),
                (this._poolWrapper = i),
                (this._disposed = !1),
                (this._bindedDispose = this.dispose.bind(this)),
                (this._disposeObservableObject = n),
                null !== this._disposeObservableObject &&
                  this._disposeObservableObject.onDisposeObservable.add(this._bindedDispose);
            }
            dispose() {
              this._disposed ||
                ((this._disposed = !0),
                this._poolWrapper.pool.destroyAnimation(this.ptr),
                this._poolWrapper.removeReference(),
                (this._poolWrapper = null),
                (this.boneTracks.length = 0),
                (this.movableBoneTracks.length = 0),
                (this.morphTracks.length = 0),
                (this.propertyTrack = new ot(0, [])),
                (this.cameraTrack = new it(0)),
                null !== this._disposeObservableObject &&
                  this._disposeObservableObject.onDisposeObservable.removeCallback(this._bindedDispose));
            }
            get isDisposed() {
              return this._disposed;
            }
          }
          class mt extends Oe {
            ptr;
            _modelPtr;
            _onDispose;
            animation;
            _boneBindIndexMap;
            get boneBindIndexMap() {
              return this._boneBindIndexMap.array;
            }
            _movableBoneBindIndexMap;
            get movableBoneBindIndexMap() {
              return this._movableBoneBindIndexMap.array;
            }
            _morphController;
            morphBindIndexMap;
            _meshes;
            _ikSolverBindIndexMap;
            get ikSolverBindIndexMap() {
              return this._ikSolverBindIndexMap.array;
            }
            _materialRecompileInduceInfo;
            constructor(e, t, n, i, o, r, a, s, l, h, d) {
              super(),
                (this.ptr = e),
                (this._modelPtr = t),
                (this._onDispose = d),
                (this.animation = n),
                (this._boneBindIndexMap = i),
                (this._movableBoneBindIndexMap = o),
                (this._morphController = r),
                (this.morphBindIndexMap = a),
                (this._meshes = s),
                (this._ikSolverBindIndexMap = l),
                (this._materialRecompileInduceInfo = h);
            }
            dispose(e = !1) {
              if (null !== this._onDispose) {
                if (!e) {
                  const e = this.animation._runtimeModelAnimations;
                  if (void 0 !== e) {
                    const t = e.indexOf(this);
                    -1 !== t && e.splice(t, 1);
                  }
                }
                this._onDispose(),
                  (this._onDispose = null),
                  this.animation._poolWrapper.pool.destroyRuntimeAnimation(this.ptr);
              }
            }
            wasmAnimate(e) {
              this.animation._poolWrapper.pool.animateMmdModel(this.ptr, this._modelPtr, e);
            }
            animate(e) {
              const t = this.animation,
                n = t.morphTracks;
              if (0 < n.length) {
                const t = this._morphController,
                  i = this.morphBindIndexMap;
                for (let o = 0; o < n.length; ++o) {
                  const r = i[o];
                  if (null === r) continue;
                  const a = n[o],
                    s = Math.max(a.startFrame, Math.min(a.endFrame, e)),
                    l = this._upperBoundFrameIndex(s, a),
                    h = l - 1,
                    d = a.frameNumbers[l];
                  if (void 0 === d) {
                    const e = a.weights[h];
                    for (let n = 0; n < r.length; ++n) t.setMorphWeightFromIndex(r[n], e, !1);
                  } else {
                    const e = a.frameNumbers[h],
                      n = (s - e) / (d - e),
                      i = a.weights[h],
                      o = i + (a.weights[l] - i) * n;
                    for (let e = 0; e < r.length; ++e) t.setMorphWeightFromIndex(r[e], o, !1);
                  }
                }
              }
              if (0 < t.propertyTrack.frameNumbers.length) {
                const n = t.propertyTrack,
                  i = Math.max(n.startFrame, Math.min(n.endFrame, e)),
                  o = this._upperBoundFrameIndex(i, n) - 1,
                  r = n.visibles[o],
                  a = this._meshes;
                for (let e = 0; e < a.length; ++e) a[e].visibility = r;
              }
            }
            induceMaterialRecompile(e, t) {
              null !== this._materialRecompileInduceInfo &&
                (mt.InduceMaterialRecompile(
                  this._materialRecompileInduceInfo,
                  this._morphController,
                  this.morphBindIndexMap,
                  t
                ),
                e && Ie(this._morphController, this.morphBindIndexMap),
                (this._materialRecompileInduceInfo = null));
            }
            static Create(e, t, n, i, o) {
              const r = e._poolWrapper.instance,
                a = e._poolWrapper.pool,
                s = t.skeleton.bones,
                l = new Map();
              if (void 0 === i) for (let e = 0; e < s.length; ++e) l.set(s[e].name, e);
              else for (let e = 0; e < s.length; ++e) l.set(i[s[e].name] ?? s[e].name, e);
              const h = a.createBoneBindIndexMap(e.ptr),
                d = r.createTypedArray(Int32Array, h, e.boneTracks.length);
              {
                const t = e.boneTracks,
                  n = d.array;
                for (let e = 0; e < t.length; ++e) {
                  const i = t[e],
                    r = l.get(i.name);
                  void 0 === r ? (o?.warn(`Binding failed: bone ${i.name} not found`), (n[e] = -1)) : (n[e] = r);
                }
              }
              const c = a.createMovableBoneBindIndexMap(e.ptr),
                m = r.createTypedArray(Int32Array, c, e.movableBoneTracks.length);
              {
                const t = m.array,
                  n = e.movableBoneTracks;
                for (let e = 0; e < n.length; ++e) {
                  const i = n[e],
                    r = l.get(i.name);
                  void 0 === r ? (o?.warn(`Binding failed: bone ${i.name} not found`), (t[e] = -1)) : (t[e] = r);
                }
              }
              const u = new Array(e.morphTracks.length),
                p = t.morph,
                g = e.morphTracks;
              for (let e = 0; e < g.length; ++e) {
                const t = g[e],
                  n = i?.[t.name] ?? t.name,
                  r = p.getMorphIndices(n);
                void 0 === r ? (o?.warn(`Binding failed: morph ${n} not found`), (u[e] = null)) : (u[e] = r);
              }
              const f = a.allocateLengthsBuffer(g.length),
                _ = r.createTypedArray(Uint32Array, f, g.length);
              {
                const e = _.array,
                  t = p.wasmMorphIndexMap;
                for (let n = 0; n < g.length; ++n) {
                  let i = 0;
                  const o = u[n];
                  if (null !== o)
                    for (let e = 0; e < o.length; ++e) {
                      const n = t[o[e]];
                      void 0 !== n && -1 !== n && (i += 1);
                    }
                  e[n] = i;
                }
              }
              const b = a.createMorphBindIndexMap(e.ptr, f);
              {
                const e = p.wasmMorphIndexMap;
                for (let t = 0; t < g.length; ++t) {
                  const n = a.getNthMorphBindIndexMap(b, t),
                    i = r.createTypedArray(Int32Array, n, _.array[t]).array;
                  let o = 0;
                  const s = u[t];
                  if (null !== s)
                    for (let t = 0; t < s.length; ++t) {
                      const n = e[s[t]];
                      void 0 !== n && -1 !== n && ((i[o] = n), (o += 1));
                    }
                }
              }
              a.deallocateLengthsBuffer(f, g.length);
              const y = a.createIkSolverBindIndexMap(e.ptr),
                A = r.createTypedArray(Int32Array, y, e.propertyTrack.ikBoneNames.length);
              {
                const n = A.array,
                  i = t.runtimeBones,
                  r = e.propertyTrack.ikBoneNames;
                for (let e = 0; e < r.length; ++e) {
                  const t = r[e],
                    a = l.get(t);
                  if (void 0 === a) o?.warn(`Binding failed: IK bone ${t} not found`), (n[e] = -1);
                  else {
                    const r = i[a].ikSolverIndex;
                    -1 === r ? (o?.warn(`Binding failed: IK solver for bone ${t} not found`), (n[e] = -1)) : (n[e] = r);
                  }
                }
              }
              const M = a.createRuntimeAnimation(e.ptr, h, c, b, y);
              return new mt(M, t.ptr, e, d, m, p, u, t.mesh.metadata.meshes, A, t.mesh.metadata.materials, n);
            }
            static InduceMaterialRecompile = xe;
          }
          ct.prototype.createWasmRuntimeModelAnimation = function (e, t, n, i) {
            void 0 === this._runtimeModelAnimations && (this._runtimeModelAnimations = []);
            const o = mt.Create(this, e, t, n, i);
            return this._runtimeModelAnimations.push(o), o;
          };
          const ut = ct.prototype.dispose;
          ct.prototype.dispose = function () {
            if (this.isDisposed) return;
            const e = this._runtimeModelAnimations;
            if (void 0 !== e) {
              for (let t = 0; t < e.length; ++t) e[t].dispose(!0);
              this._runtimeModelAnimations = void 0;
            }
            ut.call(this);
          };
          class pt extends Be {
            constructor(e, t, n, i, o, r) {
              super(e, t, n, i, o, r);
            }
            validate() {
              const e = this.boneTracks;
              for (let t = 0; t < e.length; ++t) if (!e[t].validate()) return !1;
              const t = this.movableBoneTracks;
              for (let e = 0; e < t.length; ++e) if (!t[e].validate()) return !1;
              const n = this.morphTracks;
              for (let e = 0; e < n.length; ++e) if (!n[e].validate()) return !1;
              return this.propertyTrack.validate() && this.cameraTrack.validate();
            }
          }
          var gt, ft;
          !(function (e) {
            (e.isMmdMesh = function (e) {
              return !(null === e.metadata || !e.metadata.isMmdModel);
            }),
              (e.isMmdSkinnedMesh = function (e) {
                return !(null === e.metadata || !e.metadata.isMmdModel) && null !== e.metadata.skeleton;
              });
          })(gt || (gt = {})),
            (function (e) {
              e.isSerializationMetadata = function (e) {
                return !0 === e.containsSerializationData;
              };
            })(ft || (ft = {}));
          class _t {
            _dataView;
            _encoder;
            _offset;
            constructor(e) {
              (this._dataView = new DataView(e)), (this._encoder = new TextEncoder()), (this._offset = 0);
            }
            get offset() {
              return this._offset;
            }
            set offset(e) {
              this._offset = e;
            }
            setUint8(e) {
              this._dataView.setUint8(this._offset, e), (this._offset += 1);
            }
            setUint8Array(e) {
              const t = this._dataView;
              for (let n = 0; n < e.length; ++n) t.setUint8(this._offset, e[n]), (this._offset += 1);
            }
            setInt8(e) {
              this._dataView.setInt8(this._offset, e), (this._offset += 1);
            }
            setInt8Array(e) {
              const t = this._dataView;
              for (let n = 0; n < e.length; ++n) t.setInt8(this._offset, e[n]), (this._offset += 1);
            }
            setUint16(e) {
              this._dataView.setUint16(this._offset, e, !0), (this._offset += 2);
            }
            setUint16Array(e) {
              const t = this._dataView;
              for (let n = 0; n < e.length; ++n) t.setUint16(this._offset, e[n], !0), (this._offset += 2);
            }
            setUint32(e) {
              this._dataView.setUint32(this._offset, e, !0), (this._offset += 4);
            }
            setUint32Array(e) {
              const t = this._dataView;
              for (let n = 0; n < e.length; ++n) t.setUint32(this._offset, e[n], !0), (this._offset += 4);
            }
            setInt32(e) {
              this._dataView.setInt32(this._offset, e, !0), (this._offset += 4);
            }
            setInt32Array(e) {
              const t = this._dataView;
              for (let n = 0; n < e.length; ++n) t.setInt32(this._offset, e[n], !0), (this._offset += 4);
            }
            setFloat32(e) {
              this._dataView.setFloat32(this._offset, e, !0), (this._offset += 4);
            }
            setFloat32Array(e) {
              const t = this._dataView;
              for (let n = 0; n < e.length; ++n) t.setFloat32(this._offset, e[n], !0), (this._offset += 4);
            }
            setString(e) {
              const t = this._dataView,
                n = this._encoder.encode(e);
              t.setUint32(this._offset, n.length, !0), (this._offset += 4);
              for (let e = 0; e < n.length; ++e) t.setUint8(this._offset, n[e]), (this._offset += 1);
            }
            get bytesAvailable() {
              return this._dataView.byteLength - this._offset;
            }
            static Padding(e, t) {
              return e % t == 0 ? 0 : t - (e % t);
            }
          }
          class bt {
            _loggingEnabled;
            log;
            warn;
            error;
            constructor() {
              (this._loggingEnabled = !0),
                (this.log = this._logDisabled),
                (this.warn = this._warnDisabled),
                (this.error = this._errorDisabled);
            }
            convert(e, t = {}) {
              if (!gt.isMmdMesh(e)) throw new Error(`${e.name} is not MmdMesh`);
              const { includeSkinningData: n = !0, includeMorphData: i = !0 } = t,
                r = e.metadata,
                a = ft.isSerializationMetadata(r);
              n && null === r.skeleton && this.log("MmdMesh has no skeleton. Skinning data will not be included");
              const s = [],
                l = new Int32Array(r.bones.length).fill(-1);
              let h = -1;
              const d = r.skeleton?.bones ?? [];
              for (let e = 0; e < d.length; ++e) h = Math.max(h, d[e].getIndex());
              const c = new Int32Array(h + 1).fill(-1);
              if (n && null !== r.skeleton) {
                const e = r.bones,
                  t = new Map();
                {
                  const n = new Map();
                  for (let e = 0; e < d.length; ++e) {
                    const t = d[e];
                    n.has(t.name) || n.set(t.name, t);
                  }
                  for (let i = 0; i < e.length; ++i) {
                    const o = e[i],
                      r = n.get(o.name);
                    void 0 !== r && t.set(o, r);
                  }
                }
                const n = new Map();
                {
                  const t = new Map();
                  for (let n = 0; n < e.length; ++n) {
                    const i = e[n];
                    t.has(i.name) || t.set(i.name, i);
                  }
                  for (let e = 0; e < d.length; ++e) {
                    const i = d[e],
                      o = t.get(i.name);
                    void 0 !== o && n.set(i, o);
                  }
                }
                const i = new Map();
                for (let t = 0; t < e.length; ++t) {
                  const n = e[t];
                  let o = i.get(e[n.parentBoneIndex]);
                  void 0 === o &&
                    0 <= n.parentBoneIndex &&
                    n.parentBoneIndex < e.length &&
                    ((o = []), i.set(e[n.parentBoneIndex], o)),
                    o?.push(n);
                }
                const o = new Map();
                for (let e = 0; e < d.length; ++e) {
                  if (null !== d[e].getParent()) continue;
                  const t = [d[e]];
                  for (o.set(d[e], d[e].getRestMatrix()); t.length > 0; ) {
                    const e = t.pop(),
                      n = o.get(e),
                      i = e.children;
                    for (let e = 0; e < i.length; ++e) {
                      const r = i[e];
                      o.set(r, r.getRestMatrix().multiply(n)), t.push(r);
                    }
                  }
                }
                const a = new Map();
                for (let r = 0; r < e.length; ++r) {
                  const h = e[r];
                  let d = t.get(h);
                  const m = [],
                    u = (e) => {
                      const t = e.children;
                      for (let i = 0; i < t.length; ++i) {
                        const o = t[i],
                          r = n.get(o);
                        void 0 === r ? (m.push(e), u(o)) : a.has(r) || a.set(r, s.length + m.length);
                      }
                    };
                  if (void 0 !== d) u(d);
                  else {
                    const e = i.get(h);
                    if (void 0 !== e)
                      for (let t = 0; t < e.length; ++t) {
                        const n = e[t];
                        a.set(n, s.length + m.length);
                      }
                  }
                  const p = (e) => {
                    const n = i.get(e);
                    if (void 0 !== n)
                      for (let e = 0; e < n.length; ++e) {
                        const i = n[e];
                        let o = t.get(i);
                        if (void 0 !== o) return o;
                        if (((o = p(i)), void 0 !== o)) return o;
                      }
                  };
                  if ((void 0 === d && (d = p(h)), void 0 === d)) {
                    let n = e[h.parentBoneIndex];
                    for (; void 0 !== n && ((d = t.get(n)), void 0 === d); ) n = e[n.parentBoneIndex];
                  }
                  const g = h.name,
                    f = h.englishName,
                    _ = void 0 !== d ? o.get(d).getTranslation().asArray() : [0, 0, 0],
                    b = -1,
                    A = h.transformOrder,
                    M = h.tailPosition ?? -2,
                    T = h.appendTransform,
                    w = h.axisLimit,
                    x = h.localVector,
                    I = h.externalParentTransform,
                    v = h.ik;
                  let B =
                    (h.flag ?? 0) &
                    (Array.isArray(M) ? ~y.Bone.Flag.UseBoneIndexAsTailPosition : 0) &
                    (T ? 0 : ~y.Bone.Flag.HasAppendRotate | ~y.Bone.Flag.HasAppendMove) &
                    (w ? 0 : ~y.Bone.Flag.HasAxisLimit) &
                    (x ? 0 : ~y.Bone.Flag.HasLocalVector) &
                    (I ? 0 : ~y.Bone.Flag.IsExternalParentTransformed) &
                    (v ? 0 : ~y.Bone.Flag.IsIkEnabled);
                  B |=
                    (Array.isArray(M) ? 0 : y.Bone.Flag.UseBoneIndexAsTailPosition) |
                    (T ? y.Bone.Flag.HasAppendRotate | y.Bone.Flag.HasAppendMove : 0) |
                    (w ? y.Bone.Flag.HasAxisLimit : 0) |
                    (x ? y.Bone.Flag.HasLocalVector : 0) |
                    (I ? y.Bone.Flag.IsExternalParentTransformed : 0) |
                    (v ? y.Bone.Flag.IsIkEnabled : 0);
                  const P = {
                      name: g,
                      englishName: f,
                      position: _,
                      parentBoneIndex: b,
                      transformOrder: A,
                      flag: B,
                      tailPosition: M,
                      appendTransform: T,
                      axisLimit: w,
                      localVector: x,
                      externalParentTransform: I,
                      ik: v,
                    },
                    O = (l[r] = s.length);
                  void 0 !== d && (c[d.getIndex()] = O), s.push(P);
                  const F =
                    y.Bone.Flag.UseBoneIndexAsTailPosition |
                    y.Bone.Flag.IsRotatable |
                    y.Bone.Flag.IsVisible |
                    y.Bone.Flag.IsControllable;
                  for (let e = 0; e < m.length; ++e) {
                    const t = m[e];
                    c[t.getIndex()] = s.length;
                    let i = -1;
                    const r = t.getParent();
                    null !== r && (i = n.get(r) === h ? O : c[r.getIndex()]),
                      s.push({
                        name: t.name,
                        englishName: "",
                        position: o.get(t).getTranslation().asArray(),
                        parentBoneIndex: i,
                        transformOrder: 0,
                        flag: F,
                        tailPosition: i,
                        appendTransform: void 0,
                        axisLimit: void 0,
                        localVector: void 0,
                        externalParentTransform: void 0,
                        ik: void 0,
                      });
                  }
                }
                for (let t = 0; t < e.length; ++t) {
                  const n = e[t],
                    i = s[l[t]],
                    o = (i.parentBoneIndex = a.get(n) ?? -1);
                  -2 === i.tailPosition
                    ? (i.tailPosition = o)
                    : "number" == typeof i.tailPosition &&
                      0 <= i.tailPosition &&
                      i.tailPosition < e.length &&
                      (i.tailPosition = l[i.tailPosition]);
                  const r = i.appendTransform;
                  void 0 !== r &&
                    (i.appendTransform = { parentIndex: l[r.parentIndex] ?? r.parentIndex, ratio: r.ratio });
                  const h = i.ik;
                  if (void 0 !== h) {
                    const e = [];
                    i.ik = {
                      target: l[h.target] ?? h.target,
                      iteration: h.iteration,
                      rotationConstraint: h.rotationConstraint,
                      links: e,
                    };
                    const t = h.links;
                    for (let n = 0; n < t.length; ++n) {
                      const i = t[n];
                      e.push({ target: l[i.target] ?? i.target, limitation: i.limitation });
                    }
                  }
                }
              }
              const u = [],
                p = new Map();
              {
                const e = r.meshes;
                for (let t = 0; t < e.length; ++t) {
                  const n = e[t];
                  if (null === n.geometry) {
                    this.warn(`mesh ${n.name} has no geometry. skippping`);
                    continue;
                  }
                  const i = n.geometry;
                  null !== i.getVerticesData(o.VertexBuffer.PositionKind)
                    ? null !== i.getVerticesData(o.VertexBuffer.NormalKind)
                      ? null !== i.getVerticesData(o.VertexBuffer.UVKind)
                        ? n.isUnIndexed || null !== i.getIndices()
                          ? null === r.skeleton || r.skeleton === n.skeleton
                            ? (p.set(t, u.length), u.push(n))
                            : this.warn(`mesh ${n.name} has different skeleton. skippping`)
                          : this.warn(`mesh ${n.name} has no indices data. skippping`)
                        : this.warn(`mesh ${n.name} has no uv data. skippping`)
                      : this.warn(`mesh ${n.name} has no normal data. skippping`)
                    : this.warn(`mesh ${n.name} has no position data. skippping`);
                }
              }
              const g = [],
                f = [];
              {
                const e = new Set();
                for (let t = 0; t < u.length; ++t) {
                  const n = u[t].material;
                  if (
                    null !== n &&
                    (n.diffuseTexture ? e.add(n.diffuseTexture) : n.albedoTexture && e.add(n.albedoTexture),
                    n.sphereTexture && e.add(n.sphereTexture),
                    n.toonTexture)
                  ) {
                    const t = n.toonTexture.name;
                    (t.startsWith("file:shared_toon_texture_") && t.length <= 27 && !isNaN(Number(t.substring(25)))) ||
                      e.add(n.toonTexture);
                  }
                }
                const t = a ? r.textureNameMap : null;
                null === t &&
                  this.warn(
                    "metadata.textureNameMap is not defined. texture names will be fallback to converted string by loader"
                  );
                const n = new Map(),
                  i = new Map();
                for (const o of e) {
                  let e = null;
                  const r = o._buffer;
                  r instanceof ArrayBuffer
                    ? (e = new Uint8Array(r))
                    : null == r
                    ? this.warn(
                        `texture ${o.name} has no texture buffer. make sure load model with materialBuilder.deleteTextureBufferAfterLoad = false`
                      )
                    : r.buffer instanceof ArrayBuffer
                    ? (e = new Uint8Array(r.buffer, r.byteOffset, r.byteLength))
                    : this.warn(
                        `texture ${o.name} has unsupported type of texture buffer. only ArrayBuffer and TypedArray is supported`
                      );
                  const a = (o.noMipmap ? oe.Texture.Flag.NoMipmap : 0) | (o.invertY ? oe.Texture.Flag.InvertY : 0);
                  let s;
                  if (null !== e) {
                    let r = i.get(e.buffer);
                    void 0 === r && ((r = i.size), i.set(e.buffer, r));
                    const a = `${r}_${e.byteOffset}_${e.byteLength}`;
                    if (((s = n.get(a)), void 0 === s)) {
                      (s = g.length), n.set(a, s);
                      let i = t?.get(o);
                      void 0 === i &&
                        (this.warn(
                          `texture ${o.name} has no name in textureNameMap. falling back to converted string by loader`
                        ),
                        (i = o.name)),
                        g.push({ relativePath: i, mimeType: o.mimeType, buffer: e });
                    }
                  }
                  f.push({ flag: a, samplingMode: o.samplingMode, imageIndex: s ?? -1, texture: o });
                }
              }
              const _ = [],
                b = new Map();
              {
                const e = new Map();
                {
                  const t = r.materials;
                  for (let n = 0; n < t.length; ++n) {
                    const i = t[n];
                    e.set(i, n);
                  }
                }
                const t = new Map();
                {
                  const e = r.materials,
                    n = a ? r.materialsMetadata : null;
                  if (null !== n)
                    for (let i = 0; i < e.length; ++i) {
                      const o = e[i],
                        r = n[i];
                      t.has(o) || (void 0 !== r && t.set(o, r));
                    }
                }
                let n = !1;
                const i = new Map();
                for (let o = 0; o < u.length; ++o) {
                  const r = u[o],
                    a = r.material;
                  if (null === a) {
                    if (n) this.warn(`mesh ${r.name} has no material. using default material metadata`);
                    else {
                      (n = !0), this.warn(`mesh ${r.name} has no material. adding default material metadata`);
                      const e = {
                        name: "default",
                        englishName: "default",
                        diffuse: [1, 1, 1, 1],
                        specular: [0, 0, 0],
                        shininess: 0,
                        ambient: [0, 0, 0],
                        evauatedTransparency: 0,
                        flag: 0,
                        edgeColor: [0, 0, 0, 1],
                        edgeSize: 0,
                        textureIndex: -1,
                        sphereTextureIndex: -1,
                        sphereTextureMode: y.Material.SphereTextureMode.Off,
                        isSharedToonTexture: !1,
                        toonTextureIndex: -1,
                        comment: "",
                        linkedMaterial: null,
                      };
                      _.push(e);
                    }
                    continue;
                  }
                  const s = i.get(a),
                    l = e.get(a);
                  if (void 0 === l) this.warn(`mesh ${r.name} has material which is not included in model metadata`);
                  else if (void 0 !== s) b.set(l, s);
                  else {
                    b.set(l, _.length), i.set(a, _.length);
                    const e = t.get(a);
                    void 0 === e && this.log(`mesh ${r.name} has no additional material metadata`);
                    const n = a.name ?? "",
                      o = e?.englishName ?? "",
                      s = a.diffuseColor?.asArray() ?? [1, 1, 1, 1];
                    (s.length = 4), (s[3] = a.alpha ?? 1);
                    const h = a.specularColor?.asArray() ?? a.reflectivityColor?.asArray() ?? [0, 0, 0];
                    h.length = 3;
                    const d = a.specularPower ?? 0,
                      c = a.ambientColor?.asArray() ?? [0, 0, 0];
                    c.length = 3;
                    const m = a.transparencyMode ?? N.Material.MATERIAL_OPAQUE,
                      u =
                        (e?.isDoubleSided ?? !1 === a.backFaceCulling ? y.Material.Flag.IsDoubleSided : 0) |
                        (a.renderOutline ? y.Material.Flag.EnabledToonEdge : 0),
                      p = a.outlineColor?.asArray() ?? [0, 0, 0];
                    (p.length = 4), (p[3] = a.outlineAlpha ?? 0);
                    const g = a.outlineWidth ?? 0,
                      A = a.diffuseTexture ?? a.albedoTexture,
                      M = A ? f.findIndex((e) => e.texture === A) : -1,
                      T = a.sphereTexture,
                      w = T ? f.findIndex((e) => e.texture === T) : -1,
                      x = a.sphereTextureBlendMode ?? y.Material.SphereTextureMode.Off,
                      I = a.toonTexture,
                      v =
                        !!I &&
                        I.name.startsWith("file:shared_toon_texture_") &&
                        I.name.length <= 27 &&
                        !isNaN(Number(I.name.substring(25)));
                    let B;
                    B = v ? Number(I.name.substring(25)) - 1 : I ? f.findIndex((e) => e.texture === I) : -1;
                    const P = {
                      name: n,
                      englishName: o,
                      diffuse: s,
                      specular: h,
                      shininess: d,
                      ambient: c,
                      evauatedTransparency: m,
                      flag: u,
                      edgeColor: p,
                      edgeSize: g,
                      textureIndex: M,
                      sphereTextureIndex: w,
                      sphereTextureMode: x,
                      isSharedToonTexture: v,
                      toonTextureIndex: B,
                      comment: e?.comment ?? "",
                      linkedMaterial: a,
                    };
                    _.push(P);
                  }
                }
              }
              const A = new Array(r.morphs.length).fill(null);
              for (let e = 0; e < A.length; ++e) A[e] = [];
              if (i)
                if (a) {
                  const e = r.morphs;
                  for (let t = 0; t < e.length; ++t) {
                    const n = e[t];
                    switch (n.type) {
                      case y.Morph.Type.VertexMorph:
                      case y.Morph.Type.UvMorph:
                      case y.Morph.Type.AdditionalUvMorph1:
                      case y.Morph.Type.AdditionalUvMorph2:
                      case y.Morph.Type.AdditionalUvMorph3:
                      case y.Morph.Type.AdditionalUvMorph4: {
                        const e = [],
                          i = n.elements;
                        for (let t = 0; t < i.length; ++t) {
                          const o = i[t],
                            r = p.get(o.meshIndex);
                          void 0 !== r
                            ? e.push({ meshIndex: r, indices: o.indices, offsets: o.offsets })
                            : this.warn(`morph ${n.name} has invalid mesh. skipping`);
                        }
                        A[t] = e;
                      }
                    }
                  }
                } else {
                  this.warn("metadata.morphsMetadata is not defined. UV morphs will be lossy converted");
                  const e = r.morphs;
                  for (let t = 0; t < e.length; ++t) {
                    const n = e[t];
                    let i = !1;
                    switch (n.type) {
                      case y.Morph.Type.VertexMorph:
                      case y.Morph.Type.UvMorph:
                      case y.Morph.Type.AdditionalUvMorph1:
                      case y.Morph.Type.AdditionalUvMorph2:
                      case y.Morph.Type.AdditionalUvMorph3:
                      case y.Morph.Type.AdditionalUvMorph4:
                        i = !0;
                    }
                    if (!i) continue;
                    const r = (A[t] = []),
                      a = n.morphTargets;
                    for (let e = 0; e < a.length; ++e) {
                      let t = -1;
                      const i = a[e];
                      e: for (let e = 0; e < u.length; ++e) {
                        const n = u[e].morphTargetManager;
                        if (null === n) continue;
                        const o = n.numTargets;
                        for (let r = 0; r < o; ++r)
                          if (n.getTarget(r) === i) {
                            t = e;
                            break e;
                          }
                      }
                      if (-1 === t) {
                        this.warn(`morph ${n.name} has no target mesh. skipping`);
                        continue;
                      }
                      let s,
                        l,
                        h = 0;
                      if (n.type === y.Morph.Type.VertexMorph) {
                        const e = u[t].geometry.getVerticesData(o.VertexBuffer.PositionKind),
                          r = i.getPositions();
                        if (null === r) {
                          this.warn(`morph ${n.name} has no positions data. skipping`);
                          continue;
                        }
                        if (e.length !== r.length) {
                          this.warn(`morph ${n.name} has different number of positions. skipping`);
                          continue;
                        }
                        for (let t = 0; t < e.length; t += 3)
                          (e[t + 0] === r[t + 0] && e[t + 1] === r[t + 1] && e[t + 2] === r[t + 2]) || (h += 1);
                        (s = new Int32Array(h)), (l = new Float32Array(3 * h));
                        const a = e.length / 3;
                        for (let t = 0, n = 0; t < a; ++t)
                          (e[3 * t + 0] === r[3 * t + 0] &&
                            e[3 * t + 1] === r[3 * t + 1] &&
                            e[3 * t + 2] === r[3 * t + 2]) ||
                            ((s[n] = t),
                            (l[3 * n + 0] = r[3 * t + 0] - e[3 * t + 0]),
                            (l[3 * n + 1] = r[3 * t + 1] - e[3 * t + 1]),
                            (l[3 * n + 2] = r[3 * t + 2] - e[3 * t + 2]),
                            (n += 1));
                      } else {
                        const e = u[t].geometry.getVerticesData(o.VertexBuffer.UVKind),
                          r = i.getUVs();
                        if (null === r) {
                          this.warn(`morph ${n.name} has no uvs data. skipping`);
                          continue;
                        }
                        if (e.length !== r.length) {
                          this.warn(`morph ${n.name} has different number of uvs. skipping`);
                          continue;
                        }
                        for (let t = 0; t < e.length; t += 2)
                          (e[t + 0] === r[t + 0] && e[t + 1] === r[t + 1]) || (h += 1);
                        (s = new Int32Array(h)), (l = new Float32Array(4 * h));
                        const a = e.length / 2;
                        for (let t = 0, n = 0; t < a; ++t)
                          (e[2 * t + 0] === r[2 * t + 0] && e[2 * t + 1] === r[2 * t + 1]) ||
                            ((s[n] = t),
                            (l[4 * n + 0] = r[2 * t + 0] - e[2 * t + 0]),
                            (l[4 * n + 1] = r[2 * t + 1] - e[2 * t + 1]),
                            (n += 1));
                      }
                      r.push({ meshIndex: t, indices: s, offsets: l });
                    }
                  }
                }
              const M = new TextEncoder();
              let T = 7;
              {
                const e = r.header;
                (T += 4 + M.encode(e.modelName).length),
                  (T += 4 + M.encode(e.englishModelName).length),
                  (T += 4 + M.encode(e.comment).length),
                  (T += 4 + M.encode(e.englishComment).length),
                  (T += 1),
                  (T += 4);
                for (let e = 0; e < u.length; ++e) {
                  const t = u[e],
                    n = t.geometry;
                  (T += 4 + M.encode(t.name).length), (T += 4), (T += 4);
                  const i = n.getVerticesData(o.VertexBuffer.PositionKind);
                  T += 4 * i.length;
                  const r = i.length / 3;
                  if (
                    ((T += 3 * r * 4),
                    (T += 2 * r * 4),
                    (T += 1),
                    null !== n.getVerticesData(m.AdditionalUV1Kind) && (T += 4 * r * 4),
                    null !== n.getVerticesData(m.AdditionalUV2Kind) && (T += 4 * r * 4),
                    null !== n.getVerticesData(m.AdditionalUV3Kind) && (T += 4 * r * 4),
                    null !== n.getVerticesData(m.AdditionalUV4Kind) && (T += 4 * r * 4),
                    (T += 1),
                    !t.isUnIndexed)
                  ) {
                    (T += 1), (T += 4);
                    const e = n.getIndices();
                    T += Array.isArray(e) ? 4 * e.length : e.byteLength;
                  }
                  0 !== s.length &&
                    (null === n.getVerticesData(o.VertexBuffer.MatricesIndicesKind) &&
                      this.warn(`mesh ${t.name} has no matricesIndices data. falling back to zero matricesIndices`),
                    (T += 4 * r * 4),
                    null === n.getVerticesData(o.VertexBuffer.MatricesWeightsKind) &&
                      this.warn(`mesh ${t.name} has no matricesWeights data. falling back to zero matricesWeights`),
                    (T += 4 * r * 4));
                  const a = n.getVerticesData(m.MatricesSdefCKind),
                    l = n.getVerticesData(m.MatricesSdefR0Kind),
                    h = n.getVerticesData(m.MatricesSdefR1Kind);
                  null !== a && null !== l && null !== h
                    ? ((T += 3 * r * 4), (T += 3 * r * 4), (T += 3 * r * 4))
                    : (null !== a && null !== l && null !== h) ||
                      (null === a && null === l && null === h) ||
                      this.warn(
                        `mesh ${t.name} has incomplete sdef data. sdefC, sdefR0, sdefR1 must be all defined or all undefined. falling back to linear blend skinning`
                      ),
                    null !== n.getVerticesData(m.EdgeScaleKind) && (T += 4 * r);
                }
                T += 4;
                for (let e = 0; e < g.length; ++e) {
                  const t = g[e];
                  (T += 4 + M.encode(t.relativePath).length),
                    (T += 1),
                    void 0 !== t.mimeType && (T += 4 + M.encode(t.mimeType).length),
                    (T += 4),
                    (T += t.buffer.byteLength);
                }
                T += 4;
                for (let e = 0; e < f.length; ++e) T += 6;
                T += 4;
                for (let e = 0; e < _.length; ++e) {
                  const t = _[e];
                  (T += 4 + M.encode(t.name).length),
                    (T += 4 + M.encode(t.englishName).length),
                    (T += 16),
                    (T += 12),
                    (T += 4),
                    (T += 12),
                    (T += 1),
                    (T += 1),
                    (T += 16),
                    (T += 4),
                    (T += 4),
                    (T += 4),
                    (T += 1),
                    (T += 1),
                    (T += 4),
                    (T += 4 + M.encode(t.comment).length);
                }
                if (0 !== s.length) {
                  (T += 4),
                    a ||
                      this.warn(
                        "metadata.bones has following missing properties: tailPosition, axisLimit, localVector, externalParentTransform. lossy conversion will be applied"
                      );
                  for (let e = 0; e < s.length; ++e) {
                    const t = s[e];
                    if (
                      ((T += 4 + M.encode(t.name).length),
                      (T += 4 + M.encode(t.englishName).length),
                      (T += 12),
                      (T += 4),
                      (T += 4),
                      (T += 2),
                      a ? ("number" == typeof t.tailPosition ? (T += 4) : (T += 12)) : (T += 4),
                      void 0 !== t.appendTransform && ((T += 4), (T += 4)),
                      void 0 !== t.axisLimit && (T += 12),
                      void 0 !== t.localVector && ((T += 12), (T += 12)),
                      void 0 !== t.externalParentTransform && (T += 4),
                      void 0 !== t.ik)
                    ) {
                      (T += 4), (T += 4), (T += 4), (T += 4);
                      const e = t.ik.links;
                      for (let t = 0; t < e.length; ++t)
                        (T += 4), (T += 1), void 0 !== e[t].limitation && ((T += 12), (T += 12));
                    }
                  }
                }
                T += 4;
                const t = r.morphs;
                for (let e = 0; e < t.length; ++e) {
                  const n = t[e];
                  switch (
                    ((T += 4 + M.encode(n.name).length),
                    (T += 4 + M.encode(n.englishName).length),
                    (T += 1),
                    (T += 1),
                    n.type)
                  ) {
                    case y.Morph.Type.GroupMorph:
                      T += 4 + 8 * n.indices.length;
                      break;
                    case y.Morph.Type.VertexMorph:
                      {
                        T += 4;
                        const t = A[e];
                        for (let e = 0; e < t.length; ++e) {
                          const n = t[e];
                          T += 8 + 4 * n.indices.length + 4 * n.offsets.length;
                        }
                      }
                      break;
                    case y.Morph.Type.BoneMorph:
                      T += 4 + 32 * n.indices.length;
                      break;
                    case y.Morph.Type.UvMorph:
                    case y.Morph.Type.AdditionalUvMorph1:
                    case y.Morph.Type.AdditionalUvMorph2:
                    case y.Morph.Type.AdditionalUvMorph3:
                    case y.Morph.Type.AdditionalUvMorph4:
                      {
                        T += 4;
                        const t = A[e];
                        for (let e = 0; e < t.length; ++e) {
                          const n = t[e];
                          T += 8 + 4 * n.indices.length + 4 * n.offsets.length;
                        }
                      }
                      break;
                    case y.Morph.Type.MaterialMorph:
                      T += 4 + 117 * n.elements.length;
                  }
                }
                if (((T += 4), a && null !== r.displayFrames)) {
                  const e = r.displayFrames;
                  for (let t = 0; t < e.length; ++t) {
                    const n = e[t];
                    (T += 4 + M.encode(n.name).length),
                      (T += 4 + M.encode(n.englishName).length),
                      (T += 1),
                      (T += 4),
                      (T += 5 * n.frames.length);
                  }
                }
                T += 4;
                const n = r.rigidBodies;
                for (let e = 0; e < n.length; ++e) {
                  const t = n[e];
                  (T += 4 + M.encode(t.name).length),
                    (T += 4 + M.encode(t.englishName).length),
                    (T += 4),
                    (T += 1),
                    (T += 2),
                    (T += 1),
                    (T += 12),
                    (T += 12),
                    (T += 12),
                    (T += 4),
                    (T += 4),
                    (T += 4),
                    (T += 4),
                    (T += 4),
                    (T += 1);
                }
                T += 4;
                const i = r.joints;
                for (let e = 0; e < i.length; ++e) {
                  const t = i[e];
                  (T += 4 + M.encode(t.name).length),
                    (T += 4 + M.encode(t.englishName).length),
                    (T += 1),
                    (T += 4),
                    (T += 4),
                    (T += 12),
                    (T += 12),
                    (T += 12),
                    (T += 12),
                    (T += 12),
                    (T += 12),
                    (T += 12),
                    (T += 12);
                }
              }
              const w = new ArrayBuffer(T),
                x = new _t(w);
              x.setUint8Array(M.encode("BPMX")), x.setInt8Array([2, 0, 0]);
              {
                const e = r.header;
                x.setString(e.modelName),
                  x.setString(e.englishModelName),
                  x.setString(e.comment),
                  x.setString(e.englishComment);
              }
              const I = 0 !== s.length ? oe.Geometry.MeshType.IsSkinnedMesh : 0;
              x.setUint8(I), x.setUint32(u.length);
              for (let e = 0; e < u.length; ++e) {
                const t = u[e],
                  n = t.geometry;
                x.setString(t.name);
                const i = t.material,
                  r = _.findIndex((e) => e.linkedMaterial === i);
                x.setInt32(r);
                const a = n.getVerticesData(o.VertexBuffer.PositionKind),
                  l = a.length / 3;
                x.setUint32(l), x.setFloat32Array(a);
                let h = n.getVerticesData(o.VertexBuffer.NormalKind);
                if (h.length !== 3 * l) {
                  this.warn(`mesh ${t.name} normals vertex count is different from positions vertex count`);
                  const e = new Float32Array(3 * l);
                  e.set(h), (h = e);
                }
                x.setFloat32Array(h);
                let d = n.getVerticesData(o.VertexBuffer.UVKind);
                if (d.length !== 2 * l) {
                  this.warn(`mesh ${t.name} uv vertex count is different from positions vertex count`);
                  const e = new Float32Array(2 * l);
                  e.set(d), (d = e);
                }
                x.setFloat32Array(d);
                const p = [];
                {
                  const e = n.getVerticesData(m.AdditionalUV1Kind);
                  null !== e && p.push(e);
                  const t = n.getVerticesData(m.AdditionalUV2Kind);
                  null !== t && p.push(t);
                  const i = n.getVerticesData(m.AdditionalUV3Kind);
                  null !== i && p.push(i);
                  const o = n.getVerticesData(m.AdditionalUV4Kind);
                  null !== o && p.push(o);
                }
                x.setUint8(p.length);
                for (let e = 0; e < p.length; ++e) {
                  const n = p[e];
                  if (n.length !== 4 * l) {
                    this.warn(`mesh ${t.name} additional uv vertex count is different from positions vertex count`);
                    const i = new Float32Array(4 * l);
                    i.set(n), (p[e] = i);
                  }
                  x.setFloat32Array(n);
                }
                let g = n.getVerticesData(m.MatricesSdefCKind),
                  f = n.getVerticesData(m.MatricesSdefR0Kind),
                  b = n.getVerticesData(m.MatricesSdefR1Kind);
                const y = null !== g && null !== f && null !== b;
                let A = n.getVerticesData(m.EdgeScaleKind);
                const M =
                  (y ? oe.Geometry.GeometryType.HasSdef : 0) |
                  (t.isUnIndexed ? 0 : oe.Geometry.GeometryType.IsIndexed) |
                  (null !== A ? oe.Geometry.GeometryType.HasEdgeScale : 0);
                if ((x.setUint8(M), !t.isUnIndexed)) {
                  const e = n.getIndices();
                  x.setUint8(
                    e instanceof Uint32Array
                      ? oe.Geometry.IndexElementType.Uint32
                      : e instanceof Uint16Array
                      ? oe.Geometry.IndexElementType.Uint16
                      : oe.Geometry.IndexElementType.Int32
                  ),
                    x.setUint32(e.length),
                    e instanceof Uint16Array
                      ? x.setUint16Array(e)
                      : e instanceof Uint32Array
                      ? x.setUint32Array(e)
                      : x.setInt32Array(e);
                }
                if (0 !== s.length) {
                  const e = new Float32Array(4 * l);
                  {
                    const i = n.getVerticesData(o.VertexBuffer.MatricesIndicesKind);
                    if (
                      ((null !== i && i.length === 4 * l) ||
                        this.warn(`mesh ${t.name} bone indices vertex count is different from positions vertex count`),
                      null !== i)
                    )
                      for (let t = 0; t < e.length; ++t) e[t] = c[i[t]] ?? i[t];
                  }
                  x.setFloat32Array(e);
                  let i = n.getVerticesData(o.VertexBuffer.MatricesWeightsKind);
                  if ((null === i && (i = new Float32Array(4 * l)), i.length !== 4 * l)) {
                    this.warn(`mesh ${t.name} bone weights vertex count is different from positions vertex count`);
                    const e = new Float32Array(4 * l);
                    e.set(i), (i = e);
                  }
                  if ((x.setFloat32Array(i), y)) {
                    if (g.length !== 3 * l) {
                      this.warn(`mesh ${t.name} sdefC vertex count is different from positions vertex count`);
                      const e = new Float32Array(3 * l);
                      e.set(g), (g = e);
                    }
                    if (f.length !== 3 * l) {
                      this.warn(`mesh ${t.name} sdefR0 vertex count is different from positions vertex count`);
                      const e = new Float32Array(3 * l);
                      e.set(f), (f = e);
                    }
                    if (b.length !== 3 * l) {
                      this.warn(`mesh ${t.name} sdefR1 vertex count is different from positions vertex count`);
                      const e = new Float32Array(3 * l);
                      e.set(b), (b = e);
                    }
                    x.setFloat32Array(g), x.setFloat32Array(f), x.setFloat32Array(b);
                  }
                }
                if (null !== A) {
                  if (A.length !== l) {
                    this.warn(`mesh ${t.name} edgeScale vertex count is different from positions vertex count`);
                    const e = new Float32Array(l);
                    e.set(A), (A = e);
                  }
                  x.setFloat32Array(A);
                }
              }
              x.setUint32(g.length);
              for (let e = 0; e < g.length; ++e) {
                const t = g[e];
                x.setString(t.relativePath);
                const n = void 0 !== t.mimeType ? oe.Image.Flag.HasMimeType : 0;
                x.setUint8(n),
                  void 0 !== t.mimeType && x.setString(t.mimeType),
                  x.setUint32(t.buffer.byteLength),
                  x.setUint8Array(t.buffer);
              }
              x.setUint32(f.length);
              for (let e = 0; e < f.length; ++e) {
                const t = f[e];
                x.setUint8(t.flag), x.setUint8(t.samplingMode), x.setInt32(t.imageIndex);
              }
              x.setUint32(_.length);
              for (let e = 0; e < _.length; ++e) {
                const t = _[e];
                x.setString(t.name),
                  x.setString(t.englishName),
                  x.setFloat32Array(t.diffuse),
                  x.setFloat32Array(t.specular),
                  x.setFloat32(t.shininess),
                  x.setFloat32Array(t.ambient),
                  x.setInt8(t.evauatedTransparency),
                  x.setUint8(t.flag),
                  x.setFloat32Array(t.edgeColor),
                  x.setFloat32(t.edgeSize),
                  x.setInt32(t.textureIndex),
                  x.setInt32(t.sphereTextureIndex),
                  x.setUint8(t.sphereTextureMode),
                  x.setUint8(t.isSharedToonTexture ? 1 : 0),
                  x.setInt32(t.toonTextureIndex),
                  x.setString(t.comment);
              }
              if (0 !== s.length) {
                x.setUint32(s.length);
                for (let e = 0; e < s.length; ++e) {
                  const t = s[e];
                  if (
                    (x.setString(t.name),
                    x.setString(t.englishName),
                    x.setFloat32Array(t.position),
                    x.setInt32(t.parentBoneIndex),
                    x.setInt32(t.transformOrder),
                    x.setUint16(t.flag),
                    "number" == typeof t.tailPosition ? x.setInt32(t.tailPosition) : x.setFloat32Array(t.tailPosition),
                    void 0 !== t.appendTransform &&
                      (x.setInt32(t.appendTransform.parentIndex), x.setFloat32(t.appendTransform.ratio)),
                    void 0 !== t.axisLimit && x.setFloat32Array(t.axisLimit),
                    void 0 !== t.localVector &&
                      (x.setFloat32Array(t.localVector.x), x.setFloat32Array(t.localVector.z)),
                    void 0 !== t.externalParentTransform && x.setInt32(t.externalParentTransform),
                    void 0 !== t.ik)
                  ) {
                    const e = t.ik;
                    x.setInt32(e.target), x.setInt32(e.iteration), x.setFloat32(e.rotationConstraint);
                    const n = e.links;
                    x.setInt32(n.length);
                    for (let e = 0; e < n.length; ++e) {
                      const t = n[e];
                      x.setInt32(t.target),
                        x.setUint8(void 0 !== t.limitation ? 1 : 0),
                        void 0 !== t.limitation &&
                          (x.setFloat32Array(t.limitation.minimumAngle), x.setFloat32Array(t.limitation.maximumAngle));
                    }
                  }
                }
              }
              x.setUint32(r.morphs.length);
              const v = r.morphs;
              for (let e = 0; e < v.length; ++e) {
                const t = v[e];
                switch (
                  (x.setString(t.name), x.setString(t.englishName), x.setUint8(t.category), x.setUint8(t.type), t.type)
                ) {
                  case y.Morph.Type.GroupMorph:
                    {
                      x.setUint32(t.indices.length), x.setInt32Array(t.indices);
                      let e = t.ratios;
                      if (e.length !== t.indices.length) {
                        this.warn(`morph ${t.name} group morph ratio count is different from indices count`);
                        const n = new Float32Array(t.indices.length);
                        n.set(e), (e = n);
                      }
                      x.setFloat32Array(e);
                    }
                    break;
                  case y.Morph.Type.VertexMorph:
                  case y.Morph.Type.UvMorph:
                  case y.Morph.Type.AdditionalUvMorph1:
                  case y.Morph.Type.AdditionalUvMorph2:
                  case y.Morph.Type.AdditionalUvMorph3:
                  case y.Morph.Type.AdditionalUvMorph4:
                    {
                      const n = A[e];
                      x.setUint32(n.length);
                      for (let e = 0; e < n.length; ++e) {
                        const i = n[e];
                        x.setUint32(i.meshIndex), x.setUint32(i.indices.length), x.setInt32Array(i.indices);
                        let o = i.offsets;
                        const r = t.type === y.Morph.Type.VertexMorph ? 3 : 4;
                        if (o.length !== i.indices.length * r) {
                          this.warn(`morph ${t.name} vertex/uv morph offset count is different from indices count`);
                          const e = new Float32Array(i.indices.length * r);
                          e.set(o), (o = e);
                        }
                        x.setFloat32Array(o);
                      }
                    }
                    break;
                  case y.Morph.Type.BoneMorph:
                    {
                      const e = new Int32Array(t.indices.length);
                      {
                        const n = t.indices;
                        for (let t = 0; t < n.length; ++t) e[t] = l[n[t]] ?? n[t];
                      }
                      x.setUint32(e.length), x.setInt32Array(e);
                      let n = t.positions;
                      if (n.length !== 3 * e.length) {
                        this.warn(`morph ${t.name} bone morph position count is different from indices count`);
                        const i = new Float32Array(3 * e.length);
                        i.set(n), (n = i);
                      }
                      x.setFloat32Array(n);
                      let i = t.rotations;
                      if (i.length !== 4 * e.length) {
                        this.warn(`morph ${t.name} bone morph rotation count is different from indices count`);
                        const n = new Float32Array(4 * e.length);
                        n.set(i), (i = n);
                      }
                      x.setFloat32Array(i);
                    }
                    break;
                  case y.Morph.Type.MaterialMorph:
                    {
                      x.setUint32(t.elements.length);
                      const e = t.elements;
                      for (let t = 0; t < e.length; ++t) {
                        const n = e[t],
                          i = b.get(n.index) ?? n.index;
                        x.setInt32(i),
                          x.setUint8(n.type),
                          x.setFloat32Array(n.diffuse),
                          x.setFloat32Array(n.specular),
                          x.setFloat32(n.shininess),
                          x.setFloat32Array(n.ambient),
                          x.setFloat32Array(n.edgeColor),
                          x.setFloat32(n.edgeSize),
                          x.setFloat32Array(n.textureColor),
                          x.setFloat32Array(n.sphereTextureColor),
                          x.setFloat32Array(n.toonTextureColor);
                      }
                    }
                    break;
                  default:
                    x.setUint32(0);
                }
              }
              if (a && null !== r.displayFrames) {
                x.setUint32(r.displayFrames.length);
                const e = r.displayFrames;
                for (let t = 0; t < e.length; ++t) {
                  const n = e[t];
                  x.setString(n.name),
                    x.setString(n.englishName),
                    x.setUint8(n.isSpecialFrame ? 1 : 0),
                    x.setUint32(n.frames.length);
                  const i = n.frames;
                  for (let e = 0; e < i.length; ++e) {
                    const t = i[e];
                    x.setUint8(t.type);
                    const n = t.type === y.DisplayFrame.FrameData.FrameType.Bone ? l[t.index] ?? t.index : t.index;
                    x.setInt32(n);
                  }
                }
              } else x.setUint32(0);
              x.setUint32(r.rigidBodies.length);
              const B = r.rigidBodies;
              for (let e = 0; e < B.length; ++e) {
                const t = B[e];
                x.setString(t.name),
                  x.setString(t.englishName),
                  x.setInt32(l[t.boneIndex] ?? t.boneIndex),
                  x.setUint8(t.collisionGroup),
                  x.setUint16(t.collisionMask),
                  x.setUint8(t.shapeType),
                  x.setFloat32Array(t.shapeSize),
                  x.setFloat32Array(t.shapePosition),
                  x.setFloat32Array(t.shapeRotation),
                  x.setFloat32(t.mass),
                  x.setFloat32(t.linearDamping),
                  x.setFloat32(t.angularDamping),
                  x.setFloat32(t.repulsion),
                  x.setFloat32(t.friction),
                  x.setUint8(t.physicsMode);
              }
              x.setUint32(r.joints.length);
              const P = r.joints;
              for (let e = 0; e < P.length; ++e) {
                const t = P[e];
                x.setString(t.name),
                  x.setString(t.englishName),
                  x.setUint8(t.type),
                  x.setInt32(t.rigidbodyIndexA),
                  x.setInt32(t.rigidbodyIndexB),
                  x.setFloat32Array(t.position),
                  x.setFloat32Array(t.rotation),
                  x.setFloat32Array(t.positionMin),
                  x.setFloat32Array(t.positionMax),
                  x.setFloat32Array(t.rotationMin),
                  x.setFloat32Array(t.rotationMax),
                  x.setFloat32Array(t.springPosition),
                  x.setFloat32Array(t.springRotation);
              }
              return 0 !== x.bytesAvailable && this.error(`unexpected bytes available: ${x.bytesAvailable}`), w;
            }
            get loggingEnabled() {
              return this._loggingEnabled;
            }
            set loggingEnabled(e) {
              (this._loggingEnabled = e),
                e
                  ? ((this.log = this._logEnabled), (this.warn = this._warnEnabled), (this.error = this._errorEnabled))
                  : ((this.log = this._logDisabled),
                    (this.warn = this._warnDisabled),
                    (this.error = this._errorDisabled));
            }
            _logEnabled(e) {
              k.Logger.Log(e);
            }
            _logDisabled() {}
            _warnEnabled(e) {
              k.Logger.Warn(e);
            }
            _warnDisabled() {}
            _errorEnabled(e) {
              k.Logger.Error(e);
            }
            _errorDisabled() {}
          }
          class yt {
            constructor() {}
            static Convert(e) {
              const t = new TextEncoder();
              let n = 7;
              {
                n += 4;
                const i = e.boneTracks.length;
                for (let o = 0; o < i; ++o) {
                  const i = e.boneTracks[o];
                  (n += 4 + t.encode(i.name).length),
                    (n += 4),
                    (n += 4 * i.frameNumbers.length + _t.Padding(n, 4)),
                    (n += 16 * i.frameNumbers.length + _t.Padding(n, 4)),
                    (n += 4 * i.frameNumbers.length);
                }
                n += 4;
                const o = e.movableBoneTracks.length;
                for (let i = 0; i < o; ++i) {
                  const o = e.movableBoneTracks[i];
                  (n += 4 + t.encode(o.name).length),
                    (n += 4),
                    (n += 4 * o.frameNumbers.length + _t.Padding(n, 4)),
                    (n += 12 * o.frameNumbers.length + _t.Padding(n, 4)),
                    (n += 12 * o.frameNumbers.length),
                    (n += 16 * o.frameNumbers.length + _t.Padding(n, 4)),
                    (n += 4 * o.frameNumbers.length);
                }
                n += 4;
                const r = e.morphTracks.length;
                for (let i = 0; i < r; ++i) {
                  const o = e.morphTracks[i];
                  (n += 4 + t.encode(o.name).length),
                    (n += 4),
                    (n += 4 * o.frameNumbers.length + _t.Padding(n, 4)),
                    (n += 4 * o.frameNumbers.length + _t.Padding(n, 4));
                }
                (n += 4),
                  (n += 4 * e.propertyTrack.frameNumbers.length + _t.Padding(n, 4)),
                  (n += 1 * e.propertyTrack.frameNumbers.length + _t.Padding(n, 4)),
                  (n += 4);
                const a = e.propertyTrack.ikBoneNames.length;
                for (let i = 0; i < a; ++i) {
                  const o = e.propertyTrack.ikBoneNames[i];
                  n += 4 + t.encode(o).length;
                }
                (n += 1 * a * e.propertyTrack.frameNumbers.length),
                  (n += 4),
                  (n += 4 * e.cameraTrack.frameNumbers.length + _t.Padding(n, 4)),
                  (n += 12 * e.cameraTrack.frameNumbers.length + _t.Padding(n, 4)),
                  (n += 12 * e.cameraTrack.frameNumbers.length),
                  (n += 12 * e.cameraTrack.frameNumbers.length + _t.Padding(n, 4)),
                  (n += 4 * e.cameraTrack.frameNumbers.length),
                  (n += 4 * e.cameraTrack.frameNumbers.length + _t.Padding(n, 4)),
                  (n += 4 * e.cameraTrack.frameNumbers.length),
                  (n += 4 * e.cameraTrack.frameNumbers.length + _t.Padding(n, 4)),
                  (n += 4 * e.cameraTrack.frameNumbers.length);
              }
              const i = new ArrayBuffer(n),
                o = new _t(i);
              o.setUint8Array(t.encode("BVMD")), o.setInt8Array([2, 0, 0]);
              const r = e.boneTracks;
              o.setUint32(r.length);
              for (let e = 0; e < r.length; ++e) {
                const t = r[e];
                o.setString(t.name),
                  o.setUint32(t.frameNumbers.length),
                  (o.offset += _t.Padding(o.offset, 4)),
                  o.setUint32Array(t.frameNumbers),
                  (o.offset += _t.Padding(o.offset, 4)),
                  o.setFloat32Array(t.rotations),
                  o.setUint8Array(t.rotationInterpolations);
              }
              const a = e.movableBoneTracks;
              o.setUint32(a.length);
              for (let e = 0; e < a.length; ++e) {
                const t = a[e];
                o.setString(t.name),
                  o.setUint32(t.frameNumbers.length),
                  (o.offset += _t.Padding(o.offset, 4)),
                  o.setUint32Array(t.frameNumbers),
                  (o.offset += _t.Padding(o.offset, 4)),
                  o.setFloat32Array(t.positions),
                  o.setUint8Array(t.positionInterpolations),
                  (o.offset += _t.Padding(o.offset, 4)),
                  o.setFloat32Array(t.rotations),
                  o.setUint8Array(t.rotationInterpolations);
              }
              const s = e.morphTracks;
              o.setUint32(s.length);
              for (let e = 0; e < s.length; ++e) {
                const t = s[e];
                o.setString(t.name),
                  o.setUint32(t.frameNumbers.length),
                  (o.offset += _t.Padding(o.offset, 4)),
                  o.setUint32Array(t.frameNumbers),
                  (o.offset += _t.Padding(o.offset, 4)),
                  o.setFloat32Array(t.weights);
              }
              o.setUint32(e.propertyTrack.frameNumbers.length),
                o.setUint32(e.propertyTrack.ikBoneNames.length),
                (o.offset += _t.Padding(o.offset, 4)),
                o.setUint32Array(e.propertyTrack.frameNumbers),
                o.setUint8Array(e.propertyTrack.visibles);
              const l = e.propertyTrack.ikBoneNames;
              for (let t = 0; t < l.length; ++t) {
                const n = l[t];
                o.setString(n), o.setUint8Array(e.propertyTrack.getIkState(t));
              }
              return (
                o.setUint32(e.cameraTrack.frameNumbers.length),
                (o.offset += _t.Padding(o.offset, 4)),
                o.setUint32Array(e.cameraTrack.frameNumbers),
                (o.offset += _t.Padding(o.offset, 4)),
                o.setFloat32Array(e.cameraTrack.positions),
                o.setUint8Array(e.cameraTrack.positionInterpolations),
                (o.offset += _t.Padding(o.offset, 4)),
                o.setFloat32Array(e.cameraTrack.rotations),
                o.setUint8Array(e.cameraTrack.rotationInterpolations),
                (o.offset += _t.Padding(o.offset, 4)),
                o.setFloat32Array(e.cameraTrack.distances),
                o.setUint8Array(e.cameraTrack.distanceInterpolations),
                (o.offset += _t.Padding(o.offset, 4)),
                o.setFloat32Array(e.cameraTrack.fovs),
                o.setUint8Array(e.cameraTrack.fovInterpolations),
                i
              );
            }
          }
          class At {
            _scene;
            _loggingEnabled;
            log;
            warn;
            error;
            constructor(e) {
              (this._loggingEnabled = !1),
                (this.log = this._logDisabled),
                (this.warn = this._warnDisabled),
                (this.error = this._errorDisabled),
                (this._scene = e);
            }
            loadFromBuffer(e, t) {
              const n = new T(t);
              if ((n.initializeTextDecoder("utf-8"), "BVMD" !== n.getDecoderString(4, !1)))
                throw new be.LoadFileError("BVMD signature is not valid.");
              const i = [n.getInt8(), n.getInt8(), n.getInt8()];
              if (2 !== i[0] || 0 !== i[1] || 0 !== i[2])
                throw new be.LoadFileError(`BVMD version ${i[0]}.${i[1]}.${i[2]} is not supported.`);
              const o = n.getUint32(),
                r = new Array(o);
              for (let e = 0; e < o; ++e) {
                const i = n.getDecoderString(n.getUint32(), !0),
                  o = n.getUint32(),
                  a = n.getPaddedArrayOffset(4, o),
                  s = n.getPaddedArrayOffset(4, 4 * o),
                  l = n.getPaddedArrayOffset(1, 4 * o),
                  h = (r[e] = new et(i, o, t, a, s, l));
                n.isDeviceLittleEndian || (n.swap32Array(h.frameNumbers), n.swap32Array(h.rotations));
              }
              const a = n.getUint32(),
                s = new Array(a);
              for (let e = 0; e < a; ++e) {
                const i = n.getDecoderString(n.getUint32(), !0),
                  o = n.getUint32(),
                  r = n.getPaddedArrayOffset(4, o),
                  a = n.getPaddedArrayOffset(4, 3 * o),
                  l = n.getPaddedArrayOffset(1, 12 * o),
                  h = n.getPaddedArrayOffset(4, 4 * o),
                  d = n.getPaddedArrayOffset(1, 4 * o),
                  c = (s[e] = new tt(i, o, t, r, a, l, h, d));
                n.isDeviceLittleEndian ||
                  (n.swap32Array(c.frameNumbers), n.swap32Array(c.positions), n.swap32Array(c.rotations));
              }
              const l = n.getUint32(),
                h = new Array(l);
              for (let e = 0; e < l; ++e) {
                const i = n.getDecoderString(n.getUint32(), !0),
                  o = n.getUint32(),
                  r = n.getPaddedArrayOffset(4, o),
                  a = n.getPaddedArrayOffset(4, o),
                  s = (h[e] = new nt(i, o, t, r, a));
                n.isDeviceLittleEndian || (n.swap32Array(s.frameNumbers), n.swap32Array(s.weights));
              }
              const d = n.getUint32(),
                c = n.getUint32(),
                m = n.getPaddedArrayOffset(4, d),
                u = n.getPaddedArrayOffset(1, d),
                p = new Array(c),
                g = new Array(c);
              for (let e = 0; e < c; ++e)
                (p[e] = n.getDecoderString(n.getUint32(), !0)), (g[e] = n.getPaddedArrayOffset(1, d));
              const f = new ot(d, p, t, m, u, g);
              n.isDeviceLittleEndian || n.swap32Array(f.frameNumbers);
              const _ = n.getUint32(),
                b = n.getPaddedArrayOffset(4, _),
                y = n.getPaddedArrayOffset(4, 3 * _),
                A = n.getPaddedArrayOffset(1, 12 * _),
                M = n.getPaddedArrayOffset(4, 3 * _),
                w = n.getPaddedArrayOffset(1, 4 * _),
                x = n.getPaddedArrayOffset(4, _),
                I = n.getPaddedArrayOffset(1, 4 * _),
                v = n.getPaddedArrayOffset(4, _),
                B = n.getPaddedArrayOffset(1, 4 * _),
                P = new it(_, t, b, y, A, M, w, x, I, v, B);
              return (
                n.isDeviceLittleEndian ||
                  (n.swap32Array(P.frameNumbers),
                  n.swap32Array(P.positions),
                  n.swap32Array(P.rotations),
                  n.swap32Array(P.distances),
                  n.swap32Array(P.fovs)),
                new pt(e, r, s, h, f, P)
              );
            }
            load(e, t, n, i, o) {
              return this._scene._loadFile(
                t,
                (t, i) => {
                  n(this.loadFromBuffer(e, t));
                },
                i,
                !0,
                !0,
                o
              );
            }
            loadAsync(e, t, n) {
              return new Promise((i, o) => {
                this.load(e, t, i, n, (e, t) => o({ request: e, exception: t }));
              });
            }
            get loggingEnabled() {
              return this._loggingEnabled;
            }
            set loggingEnabled(e) {
              (this._loggingEnabled = e),
                e
                  ? ((this.log = this._logEnabled), (this.warn = this._warnEnabled), (this.error = this._errorEnabled))
                  : ((this.log = this._logDisabled),
                    (this.warn = this._warnDisabled),
                    (this.error = this._errorDisabled));
            }
            _logEnabled(e) {
              k.Logger.Log(e);
            }
            _logDisabled() {}
            _warnEnabled(e) {
              k.Logger.Warn(e);
            }
            _warnDisabled() {}
            _errorEnabled(e) {
              k.Logger.Error(e);
            }
            _errorDisabled() {}
          }
          class Mt {
            static _Signature = "Vocaloid Motion Data 0002";
            static SignatureBytes = 30;
            static ModelNameBytes = 20;
            static BoneKeyFrameBytes = 111;
            static MorphKeyFrameBytes = 23;
            static CameraKeyFrameBytes = 61;
            static LightKeyFrameBytes = 28;
            static SelfShadowKeyFrameBytes = 9;
            static PropertyKeyFrameBytes = 5;
            static PropertyKeyFrameIkStateBytes = 21;
            dataDeserializer;
            boneKeyFrameCount;
            morphKeyFrameCount;
            cameraKeyFrameCount;
            lightKeyFrameCount;
            selfShadowKeyFrameCount;
            propertyKeyFrameCount;
            constructor(e, t, n, i, o, r, a) {
              (this.dataDeserializer = e),
                (this.boneKeyFrameCount = t),
                (this.morphKeyFrameCount = n),
                (this.cameraKeyFrameCount = i),
                (this.lightKeyFrameCount = o),
                (this.selfShadowKeyFrameCount = r),
                (this.propertyKeyFrameCount = a);
            }
            static CheckedCreate(e, t = new M()) {
              const n = new T(e);
              if ((n.initializeTextDecoder("shift-jis"), n.bytesAvailable < Mt.SignatureBytes + Mt.ModelNameBytes))
                return null;
              if (n.getSignatureString(this.SignatureBytes).substring(0, this._Signature.length) !== this._Signature)
                return null;
              n.offset += Mt.ModelNameBytes;
              let i = 0,
                o = 0,
                r = 0,
                a = 0,
                s = 0,
                l = 0;
              if (n.bytesAvailable < 4) return null;
              if (((i = n.getUint32()), n.bytesAvailable < i * Mt.BoneKeyFrameBytes)) return null;
              if (((n.offset += i * Mt.BoneKeyFrameBytes), n.bytesAvailable < 4)) return null;
              if (((o = n.getUint32()), n.bytesAvailable < o * Mt.MorphKeyFrameBytes)) return null;
              if (((n.offset += o * Mt.MorphKeyFrameBytes), 0 !== n.bytesAvailable)) {
                if (n.bytesAvailable < 4) return null;
                if (((r = n.getUint32()), n.bytesAvailable < r * Mt.CameraKeyFrameBytes)) return null;
                if (((n.offset += r * Mt.CameraKeyFrameBytes), n.bytesAvailable < 4)) return null;
                if (((a = n.getUint32()), n.bytesAvailable < a * Mt.LightKeyFrameBytes)) return null;
                n.offset += a * Mt.LightKeyFrameBytes;
              }
              if (0 !== n.bytesAvailable) {
                if (n.bytesAvailable < 4) return null;
                if (((s = n.getUint32()), n.bytesAvailable < s * Mt.SelfShadowKeyFrameBytes)) return null;
                n.offset += s * Mt.SelfShadowKeyFrameBytes;
              }
              if (0 !== n.bytesAvailable) {
                if (n.bytesAvailable < 4) return null;
                l = n.getUint32();
                for (let e = 0; e < l; ++e) {
                  if (n.bytesAvailable < Mt.PropertyKeyFrameBytes) return null;
                  if (((n.offset += Mt.PropertyKeyFrameBytes), n.bytesAvailable < 4)) return null;
                  const e = n.getUint32();
                  if (n.bytesAvailable < e * Mt.PropertyKeyFrameIkStateBytes) return null;
                  n.offset += e * Mt.PropertyKeyFrameIkStateBytes;
                }
              }
              return (
                n.bytesAvailable > 0 && t.warn(`There are ${n.bytesAvailable} bytes left after parsing`),
                (n.offset = 0),
                new Mt(n, i, o, r, a, s, l)
              );
            }
          }
          class Tt {
            propertyKeyFrames;
            _vmdData;
            constructor(e, t) {
              (this._vmdData = e), (this.propertyKeyFrames = t);
            }
            static Parse(e) {
              const t = e.dataDeserializer,
                n = [];
              t.offset =
                Mt.SignatureBytes +
                Mt.ModelNameBytes +
                4 +
                e.boneKeyFrameCount * Mt.BoneKeyFrameBytes +
                4 +
                e.morphKeyFrameCount * Mt.MorphKeyFrameBytes +
                4 +
                e.cameraKeyFrameCount * Mt.CameraKeyFrameBytes +
                4 +
                e.lightKeyFrameCount * Mt.LightKeyFrameBytes +
                4 +
                e.selfShadowKeyFrameCount * Mt.SelfShadowKeyFrameBytes +
                4;
              const i = e.propertyKeyFrameCount;
              for (let e = 0; e < i; ++e) {
                const e = t.getUint32(),
                  i = 0 !== t.getUint8(),
                  o = t.getUint32(),
                  r = [];
                for (let e = 0; e < o; ++e) {
                  const e = t.getDecoderString(20, !0),
                    n = 0 !== t.getUint8();
                  r.push([e, n]);
                }
                const a = { frameNumber: e, visible: i, ikStates: r };
                n.push(a);
              }
              return new Tt(e, n);
            }
            static ParseFromBuffer(e) {
              const t = Mt.CheckedCreate(e);
              if (null === t) throw new Error("Invalid VMD data");
              return Tt.Parse(t);
            }
            get boneKeyFrames() {
              const e = Mt.SignatureBytes + Mt.ModelNameBytes + 4;
              return new Tt.BoneKeyFrames(this._vmdData.dataDeserializer, e, this._vmdData.boneKeyFrameCount);
            }
            get morphKeyFrames() {
              const e =
                Mt.SignatureBytes + Mt.ModelNameBytes + 4 + this._vmdData.boneKeyFrameCount * Mt.BoneKeyFrameBytes + 4;
              return new Tt.MorphKeyFrames(this._vmdData.dataDeserializer, e, this._vmdData.morphKeyFrameCount);
            }
            get cameraKeyFrames() {
              const e =
                Mt.SignatureBytes +
                Mt.ModelNameBytes +
                4 +
                this._vmdData.boneKeyFrameCount * Mt.BoneKeyFrameBytes +
                4 +
                this._vmdData.morphKeyFrameCount * Mt.MorphKeyFrameBytes +
                4;
              return new Tt.CameraKeyFrames(this._vmdData.dataDeserializer, e, this._vmdData.cameraKeyFrameCount);
            }
            get lightKeyFrames() {
              const e =
                Mt.SignatureBytes +
                Mt.ModelNameBytes +
                4 +
                this._vmdData.boneKeyFrameCount * Mt.BoneKeyFrameBytes +
                4 +
                this._vmdData.morphKeyFrameCount * Mt.MorphKeyFrameBytes +
                4 +
                this._vmdData.cameraKeyFrameCount * Mt.CameraKeyFrameBytes +
                4;
              return new Tt.LightKeyFrames(this._vmdData.dataDeserializer, e, this._vmdData.lightKeyFrameCount);
            }
            get selfShadowKeyFrames() {
              const e =
                Mt.SignatureBytes +
                Mt.ModelNameBytes +
                4 +
                this._vmdData.boneKeyFrameCount * Mt.BoneKeyFrameBytes +
                4 +
                this._vmdData.morphKeyFrameCount * Mt.MorphKeyFrameBytes +
                4 +
                this._vmdData.cameraKeyFrameCount * Mt.CameraKeyFrameBytes +
                4 +
                this._vmdData.lightKeyFrameCount * Mt.LightKeyFrameBytes +
                4;
              return new Tt.SelfShadowKeyFrames(
                this._vmdData.dataDeserializer,
                e,
                this._vmdData.selfShadowKeyFrameCount
              );
            }
          }
          !(function (e) {
            class t {
              _dataDeserializer;
              _startOffset;
              _length;
              constructor(e, t, n) {
                (this._dataDeserializer = e), (this._startOffset = t), (this._length = n);
              }
              get length() {
                return this._length;
              }
            }
            (e.BufferArrayReader = t),
              (e.BoneKeyFrames = class extends t {
                constructor(e, t, n) {
                  super(e, t, n);
                }
                get(e) {
                  const t = this._startOffset + e * Mt.BoneKeyFrameBytes;
                  return new n(this._dataDeserializer, t);
                }
              });
            class n {
              boneName;
              frameNumber;
              position;
              rotation;
              interpolation;
              constructor(e, t) {
                (e.offset = t),
                  (this.boneName = e.getDecoderString(15, !0)),
                  (this.frameNumber = e.getUint32()),
                  (this.position = e.getFloat32Tuple(3)),
                  (this.rotation = e.getFloat32Tuple(4)),
                  (this.interpolation = new Uint8Array(64));
                for (let t = 0; t < 64; ++t) this.interpolation[t] = e.getUint8();
              }
            }
            (e.BoneKeyFrame = n),
              (e.MorphKeyFrames = class extends t {
                constructor(e, t, n) {
                  super(e, t, n);
                }
                get(e) {
                  const t = this._startOffset + e * Mt.MorphKeyFrameBytes;
                  return new i(this._dataDeserializer, t);
                }
              });
            class i {
              morphName;
              frameNumber;
              weight;
              constructor(e, t) {
                (e.offset = t),
                  (this.morphName = e.getDecoderString(15, !0)),
                  (this.frameNumber = e.getUint32()),
                  (this.weight = e.getFloat32());
              }
            }
            (e.MorphKeyFrame = i),
              (e.CameraKeyFrames = class extends t {
                constructor(e, t, n) {
                  super(e, t, n);
                }
                get(e) {
                  const t = this._startOffset + e * Mt.CameraKeyFrameBytes;
                  return new o(this._dataDeserializer, t);
                }
              });
            class o {
              frameNumber;
              distance;
              position;
              rotation;
              interpolation;
              fov;
              perspective;
              constructor(e, t) {
                (e.offset = t),
                  (this.frameNumber = e.getUint32()),
                  (this.distance = e.getFloat32()),
                  (this.position = e.getFloat32Tuple(3)),
                  (this.rotation = e.getFloat32Tuple(3)),
                  (this.interpolation = new Uint8Array(24));
                for (let t = 0; t < 24; ++t) this.interpolation[t] = e.getUint8();
                (this.fov = e.getUint32()), (this.perspective = 0 !== e.getUint8());
              }
            }
            (e.CameraKeyFrame = o),
              (e.LightKeyFrames = class extends t {
                constructor(e, t, n) {
                  super(e, t, n);
                }
                get(e) {
                  const t = this._startOffset + e * Mt.LightKeyFrameBytes;
                  return new r(this._dataDeserializer, t);
                }
              });
            class r {
              frameNumber;
              color;
              direction;
              constructor(e, t) {
                (e.offset = t),
                  (this.frameNumber = e.getUint32()),
                  (this.color = e.getFloat32Tuple(3)),
                  (this.direction = e.getFloat32Tuple(3));
              }
            }
            (e.LightKeyFrame = r),
              (e.SelfShadowKeyFrames = class extends t {
                constructor(e, t, n) {
                  super(e, t, n);
                }
                get(e) {
                  const t = this._startOffset + e * Mt.SelfShadowKeyFrameBytes;
                  return new a(this._dataDeserializer, t);
                }
              });
            class a {
              frameNumber;
              mode;
              distance;
              constructor(e, t) {
                (e.offset = t),
                  (this.frameNumber = e.getUint32()),
                  (this.mode = e.getUint8()),
                  (this.distance = e.getFloat32());
              }
            }
            e.SelfShadowKeyFrame = a;
          })(Tt || (Tt = {}));
          class wt {
            static _Signature = "Vocaloid Pose Data file";
            constructor() {}
            static Parse(e, t = new M()) {
              if (!e.startsWith(wt._Signature)) throw new Error("VPD signature is not valid.");
              const n = [wt._Signature.length];
              wt._ConsumeStatement(e, n), wt._ConsumeStatement(e, n);
              const i = {},
                o = {};
              for (; n[0] < e.length && ((n[0] = wt._ConsumeEmpty(e, n[0])), !(e.length <= n[0])); ) {
                const r = wt._ConsumeBeforeOpenBracket(e, n);
                if (r.startsWith("Bone")) {
                  const o = wt._ConsumeBeforeLineEnding(e, n);
                  let r, a;
                  const s = wt._ConsumeStatement(e, n),
                    l = s.split(",");
                  if (3 !== l.length) t.warn(`Position components are not 3: ${s}`);
                  else {
                    const e = Number(l[0]),
                      n = Number(l[1]),
                      i = Number(l[2]);
                    isNaN(e) || isNaN(n) || isNaN(e)
                      ? t.warn(`Invalid position: ${s}`)
                      : (0 === e && 0 === n && 0 === i) || (r = [e, n, i]);
                  }
                  const h = wt._ConsumeStatement(e, n),
                    d = h.split(",");
                  if (4 !== d.length) t.warn(`Rotation components are not 4: ${h}`);
                  else {
                    const e = Number(d[0]),
                      n = Number(d[1]),
                      i = Number(d[2]),
                      o = Number(d[3]);
                    isNaN(e) || isNaN(n) || isNaN(e) || isNaN(o)
                      ? t.warn(`Invalid rotation: ${h}`)
                      : (a = [e, n, i, o]);
                  }
                  void 0 !== a &&
                    (void 0 !== i[o] && t.warn(`Duplicate bone: ${o}. Use the last one.`),
                    (i[o] = { position: r, rotation: a }));
                } else if (r.startsWith("Morph")) {
                  const i = wt._ConsumeBeforeLineEnding(e, n),
                    r = wt._ConsumeStatement(e, n),
                    a = Number(r);
                  isNaN(a)
                    ? t.warn(`Invalid weight: ${r}`)
                    : (void 0 !== o[i] && t.warn(`Duplicate morph: ${i}. Use the last one.`), (o[i] = a));
                } else t.warn(`Unknown type: ${r}`);
                n[0] = wt._ConsumeWhileCloseBracket(e, n[0]);
              }
              return { bones: i, morphs: o };
            }
            static _ConsumeWhiteSpace(e, t) {
              for (; t < e.length && (" " === e[t] || "\t" === e[t] || "\r" === e[t] || "\n" === e[t]); ) t += 1;
              return t;
            }
            static _ConsumeLine(e, t) {
              for (; t < e.length; ) {
                if ("\r" === e[t] || "\n" === e[t]) {
                  t += 1;
                  break;
                }
                t += 1;
              }
              return "\r" === e[t - 1] && "\n" === e[t] && (t += 1), t;
            }
            static _ConsumeEmpty(e, t) {
              let n = t;
              for (
                ;
                t < e.length &&
                ((n = t),
                "/" === e[(t = wt._ConsumeWhiteSpace(e, t))] && "/" === e[t + 1] && (t = wt._ConsumeLine(e, t)),
                n !== t);

              );
              return t;
            }
            static _ConsumeWhileCloseBracket(e, t) {
              for (; t < e.length; ) {
                if ("}" === e[t]) {
                  t += 1;
                  break;
                }
                t += 1;
              }
              return t;
            }
            static _ConsumeStatement(e, t) {
              let n = t[0],
                i = "";
              for (;;)
                if (((n = wt._ConsumeWhiteSpace(e, n)), "/" !== e[n] || "/" !== e[n + 1])) {
                  if (e.length <= n) break;
                  if (";" === e[n]) {
                    n += 1;
                    break;
                  }
                  (i += e[n]), (n += 1);
                } else n = wt._ConsumeLine(e, n);
              return (t[0] = n), i;
            }
            static _ConsumeBeforeLineEnding(e, t) {
              const n = t[0];
              let i = t[0];
              for (; i < e.length && "\r" !== e[i] && "\n" !== e[i]; ) i += 1;
              return (t[0] = i), e.substring(n, i);
            }
            static _ConsumeBeforeOpenBracket(e, t) {
              let n = t[0],
                i = "";
              for (; n < e.length; ) {
                if ("{" === e[n]) {
                  n += 1;
                  break;
                }
                (i += e[n]), (n += 1);
              }
              return (t[0] = n), i;
            }
          }
          function xt(e, t, n) {
            if (void 0 === t[e.targetProperty])
              return void n?.warn(`Wrong target property ${e.targetProperty} for ${e.name} ${t.name}`);
            const i =
              "rotationQuaternion" === e.targetProperty
                ? E.Quaternion.FromRotationMatrix(t.getRestMatrix())
                : "position" === e.targetProperty
                ? t.getRestMatrix().getTranslation()
                : void 0;
            if (void 0 === i) return void n?.warn(`Failed to get rest pose for ${e.name} ${e.targetProperty}`);
            const o = e.getKeys();
            switch (e.dataType) {
              case Re.Animation.ANIMATIONTYPE_QUATERNION: {
                const e = i.clone().invertInPlace();
                for (let t = 0; t < o.length; ++t) e.multiplyToRef(o[t].value, o[t].value);
                break;
              }
              case Re.Animation.ANIMATIONTYPE_VECTOR3:
                for (let e = 0; e < o.length; ++e) o[e].value.subtractInPlace(i);
                break;
              default:
                n?.warn("Animation data type is not supported");
            }
          }
          function It(e) {
            const t = new Re.Animation(e.name, e.targetProperty, e.framePerSecond, e.dataType, e.loopMode);
            (t.enableBlending = e.enableBlending), (t.blendingSpeed = e.blendingSpeed);
            const n = e.getKeys();
            if (void 0 !== n) {
              const e = new Array(n.length);
              for (let t = 0; t < n.length; t++) {
                const i = (e[t] = { ...n[t] });
                void 0 !== i.value.clone && (i.value = i.value.clone()),
                  void 0 !== i.inTangent && void 0 !== i.inTangent.clone && (i.inTangent = i.inTangent.clone()),
                  void 0 !== i.outTangent && void 0 !== i.outTangent.clone && (i.outTangent = i.outTangent.clone());
              }
              t.setKeys(e);
            }
            if (t._ranges) {
              t._ranges = {};
              for (const n in e._ranges) {
                const i = e._ranges[n];
                i && (t._ranges[n] = i.clone());
              }
            }
            return t;
          }
          class vt {
            _boneNameMap;
            _sourceSkeleton;
            _targetSkeleton;
            _sourceSkeletonTransformOffset;
            _sourceSkeletonAbsoluteMatrices;
            _targetBoneNameMap;
            _loggingEnabled;
            log;
            warn;
            error;
            constructor() {
              (this._boneNameMap = null),
                (this._sourceSkeleton = null),
                (this._targetSkeleton = null),
                (this._sourceSkeletonTransformOffset = null),
                (this._sourceSkeletonAbsoluteMatrices = null),
                (this._targetBoneNameMap = null),
                (this._loggingEnabled = !1),
                (this.log = this._logDisabled),
                (this.warn = this._warnDisabled),
                (this.error = this._errorDisabled);
            }
            setBoneMap(e) {
              return (this._boneNameMap = e), this;
            }
            setSourceSkeleton(e, t) {
              return (
                (this._sourceSkeleton = e),
                void 0 === t
                  ? (this._sourceSkeletonTransformOffset = null)
                  : void 0 !== t.getWorldMatrix
                  ? (this._sourceSkeletonTransformOffset = t.computeWorldMatrix(!0).clone())
                  : (this._sourceSkeletonTransformOffset = t.clone()),
                (this._sourceSkeletonAbsoluteMatrices = null),
                this
              );
            }
            setTargetSkeleton(e) {
              return (this._targetSkeleton = e), (this._targetBoneNameMap = null), this;
            }
            retargetAnimation(e, t = {}) {
              if (!this._isSkeletonAnimation(e))
                return this.warn("Animation is not skeleton animation. animation retargeting is aborted."), null;
              if (((t.cloneAnimation ??= !0), (t.removeBoneRotationOffset ??= !1), null === this._boneNameMap))
                throw new Error("Bone map is not set");
              if (null === this._sourceSkeleton) throw new Error("Source skeleton is not set");
              if (null === this._targetSkeleton) throw new Error("Target skeleton is not set");
              if (null === this._targetBoneNameMap) {
                const e = (this._targetBoneNameMap = new Map());
                {
                  const t = this._targetSkeleton.bones;
                  for (let n = 0; n < t.length; ++n) {
                    const i = t[n];
                    e.set(i.name, i);
                  }
                }
              }
              t.cloneAnimation &&
                (e = (function (e, t) {
                  const n = new Se.AnimationGroup(t || e.name, e._scene);
                  for (const t of e.targetedAnimations) n.addTargetedAnimation(It(t.animation), t.target);
                  return n;
                })(e, e.name + "_retargeted")),
                this._removeScaleAnimation(e);
              const n = e.targetedAnimations;
              for (let e = 0; e < n.length; ++e) this._flattenAnimationTarget(n[e]);
              if (
                (e.isAdditive ||
                  (function (e, t, n) {
                    if (e.isAdditive) return void n?.warn("Animation group is already additive");
                    const i = new Map();
                    {
                      const e = t.bones;
                      for (let t = 0; t < e.length; ++t) {
                        const n = e[t],
                          o = n.getTransformNode();
                        null !== o && i.set(o, n);
                      }
                    }
                    const o = e.targetedAnimations;
                    for (let e = 0; e < o.length; ++e) {
                      const t = o[e].animation,
                        r = o[e].target,
                        a = i.get(r);
                      void 0 === a && o[e].target,
                        void 0 !== a ? xt(t, a) : n?.warn(`Failed to find rest pose for ${t.name}`);
                    }
                    e.isAdditive = !0;
                  })(e, this._sourceSkeleton),
                void 0 !== t.rotationOffsets)
              ) {
                const n = new E.Quaternion(),
                  i = t.rotationOffsets,
                  o = e.targetedAnimations;
                for (let e = 0; e < o.length; ++e) {
                  const t = o[e].target,
                    r = o[e].animation.targetPropertyPath;
                  if ("rotationQuaternion" === r[r.length - 1]) {
                    const r = i[t.name];
                    if (void 0 !== r) {
                      E.Quaternion.FromEulerAnglesToRef(r.x, r.y, r.z, n);
                      const t = o[e].animation.getKeys();
                      for (let e = 0; e < t.length; ++e) {
                        const i = t[e].value;
                        n.multiplyToRef(i, i);
                      }
                    }
                  }
                }
              }
              if (t.removeBoneRotationOffset) {
                const t = new Map(),
                  i = new Map();
                {
                  const e = this._sourceSkeleton.bones;
                  for (let n = 0; n < e.length; ++n) {
                    const o = e[n],
                      r = o.getTransformNode();
                    null !== r && t.set(r, o), i.set(o, n);
                  }
                }
                const o = new Int32Array(n.length);
                for (let e = 0; e < n.length; ++e) {
                  const r = n[e].target;
                  let a = t.get(r);
                  void 0 === a && (a = r);
                  const s = i.get(a);
                  void 0 === s ? ((o[e] = -1), this.warn(`${a.name} is not found in source skeleton`)) : (o[e] = s);
                }
                null === this._sourceSkeletonAbsoluteMatrices &&
                  (this._sourceSkeletonAbsoluteMatrices = this._computeSkeletonAbsoluteMatrices(
                    this._sourceSkeleton,
                    this._sourceSkeletonTransformOffset,
                    i
                  )),
                  this._removeBoneRotationOffset(e, o, this._sourceSkeleton, this._sourceSkeletonAbsoluteMatrices, i);
              }
              return (
                this._retargetAnimationInternal(e, this._boneNameMap, this._targetBoneNameMap),
                (e.isAdditive = !0),
                (e.weight = 1),
                e
              );
            }
            _isSkeletonAnimation(e) {
              const t = e.targetedAnimations;
              for (let e = 0; e < t.length; ++e) {
                const n = t[e].animation,
                  i = n.targetPropertyPath[n.targetPropertyPath.length - 1];
                if ("position" !== i && "rotationQuaternion" !== i && "scaling" !== i) return !1;
              }
              return !0;
            }
            static _Stack = [];
            _computeSkeletonAbsoluteMatrices(e, t, n) {
              const i = e.bones,
                o = vt._Stack;
              o.length = 0;
              for (let e = 0; e < i.length; ++e) {
                const t = i[e];
                null === t.getParent() && o.push(t);
              }
              null === t && (t = E.Matrix.Identity());
              const r = new Array(i.length);
              for (; o.length > 0; ) {
                const e = o.pop(),
                  i = e.getParent(),
                  a = null === i ? t : r[n.get(i)];
                r[n.get(e)] = e.getRestMatrix().multiply(a);
                const s = e.getChildren();
                for (let e = 0; e < s.length; ++e) o.push(s[e]);
              }
              return r;
            }
            _removeScaleAnimation(e) {
              const t = [],
                n = e.targetedAnimations;
              for (let e = 0; e < n.length; ++e) {
                const i = n[e];
                i.target && "scaling" === i.animation.targetProperty && t.push(e);
              }
              for (let e = 0, i = 0; e < n.length; ++e) e !== t[i] ? (n[e - i] = n[e]) : (i += 1);
              n.length -= t.length;
            }
            _getFinalTarget(e, t) {
              if (t.length > 1) {
                let n = e[t[0]];
                for (let e = 1; e < t.length - 1; e++) n = n[t[e]];
                return n;
              }
              return e;
            }
            _flattenAnimationTarget(e) {
              const t = e.target,
                n = e.animation.targetPropertyPath,
                i = this._getFinalTarget(t, n);
              (e.target = i),
                (n[0] = e.animation.targetPropertyPath[e.animation.targetPropertyPath.length - 1]),
                (n.length = 1),
                (e.animation.targetProperty = e.animation.targetPropertyPath[0]);
            }
            _removeBoneRotationOffset(e, t, n, i, o) {
              const r = e.targetedAnimations,
                a = new E.Matrix(),
                s = new E.Matrix(),
                l = this._sourceSkeletonTransformOffset;
              for (let e = 0; e < r.length; ++e) {
                const h = t[e];
                if (-1 === h) continue;
                const d = r[e].animation,
                  c = d.targetProperty,
                  m = n.bones[h];
                if ("rotationQuaternion" === c) {
                  const e = i[h];
                  e.invertToRef(s);
                  const t = d.getKeys();
                  for (let n = 0; n < t.length; ++n) {
                    const i = t[n].value;
                    s.multiplyToRef(E.Matrix.FromQuaternionToRef(i, a), a),
                      a.multiplyToRef(e, a),
                      E.Quaternion.FromRotationMatrixToRef(a, i);
                  }
                } else if ("position" === c) {
                  const e = m.getParent(),
                    t = null !== e ? o.get(e) : -1,
                    n = -1 !== t ? i[t] : l;
                  if (null !== n) {
                    const e = d.getKeys();
                    for (let t = 0; t < e.length; ++t) {
                      const i = e[t].value;
                      E.Vector3.TransformNormalToRef(i, n, i);
                    }
                  }
                } else this.warn(`Unsupported target property: ${c}`);
              }
            }
            _retargetAnimationInternal(e, t, n) {
              const i = [],
                o = e.targetedAnimations;
              for (let e = 0; e < o.length; ++e) {
                const r = o[e];
                if (!r.target) {
                  i.push(e), this.warn(`Animation target is null. Animation name: ${r.animation.name}`);
                  continue;
                }
                const a = t[r.target.name];
                if (void 0 !== a) {
                  const t = n.get(a);
                  void 0 !== t ? (r.target = t) : (i.push(e), this.warn(`Bone not found. Bone name: ${r.target.name}`));
                } else i.push(e), this.warn(`Bone not found. Bone name: ${r.target.name}`);
              }
              for (let e = 0, t = 0; e < o.length; ++e) e !== i[t] ? (o[e - t] = o[e]) : (t += 1);
              o.length -= i.length;
            }
            get loggingEnabled() {
              return this._loggingEnabled;
            }
            set loggingEnabled(e) {
              (this._loggingEnabled = e),
                e
                  ? ((this.log = this._logEnabled), (this.warn = this._warnEnabled), (this.error = this._errorEnabled))
                  : ((this.log = this._logDisabled),
                    (this.warn = this._warnDisabled),
                    (this.error = this._errorDisabled));
            }
            _logEnabled(e) {
              k.Logger.Log(e);
            }
            _logDisabled() {}
            _warnEnabled(e) {
              k.Logger.Warn(e);
            }
            _warnDisabled() {}
            _errorEnabled(e) {
              k.Logger.Error(e);
            }
            _errorDisabled() {}
          }
          const Bt = {
              hips: "mixamorig:Hips",
              spine: "mixamorig:Spine",
              chest: "mixamorig:Spine2",
              neck: "mixamorig:Neck",
              head: "mixamorig:Head",
              leftShoulder: "mixamorig:LeftShoulder",
              leftUpperArm: "mixamorig:LeftArm",
              leftLowerArm: "mixamorig:LeftForeArm",
              leftHand: "mixamorig:LeftHand",
              rightShoulder: "mixamorig:RightShoulder",
              rightUpperArm: "mixamorig:RightArm",
              rightLowerArm: "mixamorig:RightForeArm",
              rightHand: "mixamorig:RightHand",
              leftUpperLeg: "mixamorig:LeftUpLeg",
              leftLowerLeg: "mixamorig:LeftLeg",
              leftFoot: "mixamorig:LeftFoot",
              leftToes: "mixamorig:LeftToeBase",
              rightUpperLeg: "mixamorig:RightUpLeg",
              rightLowerLeg: "mixamorig:RightLeg",
              rightFoot: "mixamorig:RightFoot",
              rightToes: "mixamorig:RightToeBase",
              leftEye: void 0,
              rightEye: void 0,
              leftThumbProximal: "mixamorig:LeftHandThumb1",
              leftThumbIntermediate: "mixamorig:LeftHandThumb2",
              leftThumbDistal: "mixamorig:LeftHandThumb3",
              leftIndexProximal: "mixamorig:LeftHandIndex1",
              leftIndexIntermediate: "mixamorig:LeftHandIndex2",
              leftIndexDistal: "mixamorig:LeftHandIndex3",
              leftMiddleProximal: "mixamorig:LeftHandMiddle1",
              leftMiddleIntermediate: "mixamorig:LeftHandMiddle2",
              leftMiddleDistal: "mixamorig:LeftHandMiddle3",
              leftRingProximal: "mixamorig:LeftHandRing1",
              leftRingIntermediate: "mixamorig:LeftHandRing2",
              leftRingDistal: "mixamorig:LeftHandRing3",
              leftLittleProximal: "mixamorig:LeftHandPinky1",
              leftLittleIntermediate: "mixamorig:LeftHandPinky2",
              leftLittleDistal: "mixamorig:LeftHandPinky3",
              rightThumbProximal: "mixamorig:RightHandThumb1",
              rightThumbIntermediate: "mixamorig:RightHandThumb2",
              rightThumbDistal: "mixamorig:RightHandThumb3",
              rightIndexProximal: "mixamorig:RightHandIndex1",
              rightIndexIntermediate: "mixamorig:RightHandIndex2",
              rightIndexDistal: "mixamorig:RightHandIndex3",
              rightMiddleProximal: "mixamorig:RightHandMiddle1",
              rightMiddleIntermediate: "mixamorig:RightHandMiddle2",
              rightMiddleDistal: "mixamorig:RightHandMiddle3",
              rightRingProximal: "mixamorig:RightHandRing1",
              rightRingIntermediate: "mixamorig:RightHandRing2",
              rightRingDistal: "mixamorig:RightHandRing3",
              rightLittleProximal: "mixamorig:RightHandPinky1",
              rightLittleIntermediate: "mixamorig:RightHandPinky2",
              rightLittleDistal: "mixamorig:RightHandPinky3",
            },
            Pt = {
              hips: "hips",
              spine: "spine",
              chest: "chest",
              neck: "neck",
              head: "head",
              leftShoulder: "leftShoulder",
              leftUpperArm: "leftUpperArm",
              leftLowerArm: "leftLowerArm",
              leftHand: "leftHand",
              rightShoulder: "rightShoulder",
              rightUpperArm: "rightUpperArm",
              rightLowerArm: "rightLowerArm",
              rightHand: "rightHand",
              leftUpperLeg: "leftUpperLeg",
              leftLowerLeg: "leftLowerLeg",
              leftFoot: "leftFoot",
              leftToes: "leftToes",
              rightUpperLeg: "rightUpperLeg",
              rightLowerLeg: "rightLowerLeg",
              rightFoot: "rightFoot",
              rightToes: "rightToes",
              leftEye: "leftEye",
              rightEye: "rightEye",
              leftThumbProximal: "leftThumbProximal",
              leftThumbIntermediate: "leftThumbIntermediate",
              leftThumbDistal: "leftThumbDistal",
              leftIndexProximal: "leftIndexProximal",
              leftIndexIntermediate: "leftIndexIntermediate",
              leftIndexDistal: "leftIndexDistal",
              leftMiddleProximal: "leftMiddleProximal",
              leftMiddleIntermediate: "leftMiddleIntermediate",
              leftMiddleDistal: "leftMiddleDistal",
              leftRingProximal: "leftRingProximal",
              leftRingIntermediate: "leftRingIntermediate",
              leftRingDistal: "leftRingDistal",
              leftLittleProximal: "leftLittleProximal",
              leftLittleIntermediate: "leftLittleIntermediate",
              leftLittleDistal: "leftLittleDistal",
              rightThumbProximal: "rightThumbProximal",
              rightThumbIntermediate: "rightThumbIntermediate",
              rightThumbDistal: "rightThumbDistal",
              rightIndexProximal: "rightIndexProximal",
              rightIndexIntermediate: "rightIndexIntermediate",
              rightIndexDistal: "rightIndexDistal",
              rightMiddleProximal: "rightMiddleProximal",
              rightMiddleIntermediate: "rightMiddleIntermediate",
              rightMiddleDistal: "rightMiddleDistal",
              rightRingProximal: "rightRingProximal",
              rightRingIntermediate: "rightRingIntermediate",
              rightRingDistal: "rightRingDistal",
              rightLittleProximal: "rightLittleProximal",
              rightLittleIntermediate: "rightLittleIntermediate",
              rightLittleDistal: "rightLittleDistal",
            };
          class Ot {
            static _PropertyMap = {
              hips: "センター",
              spine: "上半身",
              chest: "上半身2",
              neck: "首",
              head: "頭",
              leftShoulder: "左肩",
              leftUpperArm: "左腕",
              leftLowerArm: "左ひじ",
              leftHand: "左手首",
              rightShoulder: "右肩",
              rightUpperArm: "右腕",
              rightLowerArm: "右ひじ",
              rightHand: "右手首",
              leftUpperLeg: "左足",
              leftLowerLeg: "左ひざ",
              leftFoot: "左足首",
              leftToes: "左つま先",
              rightUpperLeg: "右足",
              rightLowerLeg: "右ひざ",
              rightFoot: "右足首",
              rightToes: "右つま先",
              leftEye: "左目",
              rightEye: "右目",
              leftThumbProximal: "左親指０",
              leftThumbIntermediate: "左親指１",
              leftThumbDistal: "左親指２",
              leftIndexProximal: "左人指１",
              leftIndexIntermediate: "左人指２",
              leftIndexDistal: "左人指３",
              leftMiddleProximal: "左中指１",
              leftMiddleIntermediate: "左中指２",
              leftMiddleDistal: "左中指３",
              leftRingProximal: "左薬指１",
              leftRingIntermediate: "左薬指２",
              leftRingDistal: "左薬指３",
              leftLittleProximal: "左小指１",
              leftLittleIntermediate: "左小指２",
              leftLittleDistal: "左小指３",
              rightThumbProximal: "右親指０",
              rightThumbIntermediate: "右親指１",
              rightThumbDistal: "右親指２",
              rightIndexProximal: "右人指１",
              rightIndexIntermediate: "右人指２",
              rightIndexDistal: "右人指３",
              rightMiddleProximal: "右中指１",
              rightMiddleIntermediate: "右中指２",
              rightMiddleDistal: "右中指３",
              rightRingProximal: "右薬指１",
              rightRingIntermediate: "右薬指２",
              rightRingDistal: "右薬指３",
              rightLittleProximal: "右小指１",
              rightLittleIntermediate: "右小指２",
              rightLittleDistal: "右小指３",
            };
            static _PropertyKeys = Object.keys(Ot._PropertyMap);
            boneMap;
            constructor(e) {
              const t = (this.boneMap = {}),
                n = Ot._PropertyMap,
                i = Ot._PropertyKeys;
              for (let o = 0, r = i.length; o < r; ++o) {
                const r = i[o],
                  a = e[r],
                  s = n[r];
                void 0 !== a && void 0 !== s && (t[a] = s);
              }
            }
          }
          class Ft {
            _scene;
            _loggingEnabled;
            log;
            warn;
            error;
            constructor(e) {
              (this._loggingEnabled = !1),
                (this.log = this._logDisabled),
                (this.warn = this._warnDisabled),
                (this.error = this._errorDisabled),
                (this._scene = e);
            }
            loadFromVmdObject(e, t, n, i) {
              this.loadFromVmdObjectAsync(e, t, i).then(n);
            }
            async loadFromVmdObjectAsync(e, t, n) {
              Array.isArray(t) || (t = [t]);
              let i = 0,
                o = 0,
                r = 0,
                a = 0;
              for (let e = 0; e < t.length; ++e) {
                const n = t[e];
                (i += n.boneKeyFrames.length),
                  (o += n.morphKeyFrames.length),
                  (r += n.propertyKeyFrames.length),
                  (a += n.cameraKeyFrames.length);
              }
              const s = { lengthComputable: !0, loaded: 0, total: i + o + r + a };
              let l = 0,
                h = performance.now();
              const d = [];
              {
                const e = new Map(),
                  i = [],
                  o = [],
                  r = [];
                for (let e = 0; e < t.length; ++e) {
                  const n = t[e].boneKeyFrames,
                    i = n.length;
                  for (let e = 0; e < i; ++e) r.push(n.get(e));
                }
                100 < performance.now() - h && (await B.Tools.DelayAsync(0), (h = performance.now()));
                const a = r.length;
                for (let t = 0; t < a; ++t) {
                  const n = r[t].boneName;
                  let a = e.get(n);
                  void 0 === a && ((a = e.size), e.set(n, a), i.push(0), o.push(n)), (i[a] += 1);
                }
                r.sort((e, t) => e.frameNumber - t.frameNumber);
                for (let t = 0; t < e.size; ++t) d.push(new tt(o[t], i[t]));
                100 < performance.now() - h && (await B.Tools.DelayAsync(0), (h = performance.now()));
                const c = new Uint32Array(e.size);
                for (let t = 0; t < a; ++t) {
                  const i = r[t],
                    o = e.get(i.boneName),
                    a = d[o],
                    m = c[o],
                    u = i.interpolation;
                  a.frameNumbers[m] = i.frameNumber;
                  const p = a.positions,
                    g = i.position;
                  (p[3 * m + 0] = g[0]), (p[3 * m + 1] = g[1]), (p[3 * m + 2] = g[2]);
                  const f = a.positionInterpolations;
                  (f[12 * m + 0] = u[0]),
                    (f[12 * m + 1] = u[8]),
                    (f[12 * m + 2] = u[4]),
                    (f[12 * m + 3] = u[12]),
                    (f[12 * m + 4] = u[16]),
                    (f[12 * m + 5] = u[24]),
                    (f[12 * m + 6] = u[20]),
                    (f[12 * m + 7] = u[28]),
                    (f[12 * m + 8] = u[32]),
                    (f[12 * m + 9] = u[40]),
                    (f[12 * m + 10] = u[36]),
                    (f[12 * m + 11] = u[44]);
                  const _ = a.rotations,
                    b = i.rotation;
                  (_[4 * m + 0] = b[0]), (_[4 * m + 1] = b[1]), (_[4 * m + 2] = b[2]), (_[4 * m + 3] = b[3]);
                  const y = a.rotationInterpolations;
                  (y[4 * m + 0] = u[48]),
                    (y[4 * m + 1] = u[56]),
                    (y[4 * m + 2] = u[52]),
                    (y[4 * m + 3] = u[60]),
                    (c[o] += 1),
                    t % 1e3 == 0 &&
                      100 < performance.now() - h &&
                      ((s.loaded = l + t), n?.({ ...s }), await B.Tools.DelayAsync(0), (h = performance.now()));
                }
              }
              const c = [],
                m = [];
              for (let e = 0; e < d.length; ++e) {
                const t = d[e];
                let n = !0;
                for (let e = 0; e < t.frameNumbers.length; ++e) {
                  const i = t.positions;
                  if (0 !== i[3 * e + 0] || 0 !== i[3 * e + 1] || 0 !== i[3 * e + 2]) {
                    n = !1;
                    break;
                  }
                  const o = t.rotations;
                  if (0 !== o[4 * e + 0] || 0 !== o[4 * e + 1] || 0 !== o[4 * e + 2] || 1 !== o[4 * e + 3]) {
                    n = !1;
                    break;
                  }
                }
                if (n) continue;
                let i = !1;
                for (let e = 0; e < t.positions.length; ++e)
                  if (0 !== t.positions[e]) {
                    i = !0;
                    break;
                  }
                if (i) m.push(t);
                else {
                  const e = new et(t.name, t.frameNumbers.length);
                  e.frameNumbers.set(t.frameNumbers),
                    e.rotations.set(t.rotations),
                    e.rotationInterpolations.set(t.rotationInterpolations),
                    c.push(e);
                }
              }
              if (((d.length = 0), 1 < t.length)) {
                const e = new Int32Array(c.length).fill(-1);
                for (let t = 0; t < c.length; ++t) {
                  const n = c[t].frameNumbers;
                  let i = 0,
                    o = n[0];
                  for (let e = 1; e <= n.length; ++e) {
                    const t = n[e];
                    o !== t && ((i += 1), (o = t));
                  }
                  n.length !== i && (e[t] = i);
                }
                for (let t = 0; t < c.length; ++t) {
                  const n = e[t];
                  if (-1 === n) continue;
                  const i = c[t],
                    o = i.frameNumbers,
                    r = i.rotations,
                    a = i.rotationInterpolations,
                    s = new et(i.name, n);
                  let l = 0,
                    h = o[0];
                  for (let e = 1; e <= o.length; ++e) {
                    const t = o[e];
                    if (h !== t) {
                      const n = e - 1;
                      s.frameNumbers[l] = h;
                      const i = s.rotations;
                      (i[4 * l + 0] = r[4 * n + 0]),
                        (i[4 * l + 1] = r[4 * n + 1]),
                        (i[4 * l + 2] = r[4 * n + 2]),
                        (i[4 * l + 3] = r[4 * n + 3]);
                      const o = s.rotationInterpolations;
                      (o[4 * l + 0] = a[4 * n + 0]),
                        (o[4 * l + 1] = a[4 * n + 1]),
                        (o[4 * l + 2] = a[4 * n + 2]),
                        (o[4 * l + 3] = a[4 * n + 3]),
                        (l += 1),
                        (h = t);
                    }
                  }
                  c[t] = s;
                }
                const t = new Int32Array(m.length).fill(-1);
                for (let e = 0; e < m.length; ++e) {
                  const n = m[e].frameNumbers;
                  let i = 0,
                    o = n[0];
                  for (let e = 1; e <= n.length; ++e) {
                    const t = n[e];
                    o !== t && ((i += 1), (o = t));
                  }
                  n.length !== i && (t[e] = i);
                }
                for (let e = 0; e < m.length; ++e) {
                  const n = t[e];
                  if (-1 === n) continue;
                  const i = m[e],
                    o = i.frameNumbers,
                    r = i.positions,
                    a = i.positionInterpolations,
                    s = i.rotations,
                    l = i.rotationInterpolations,
                    h = new tt(i.name, n);
                  let d = 0,
                    c = o[0];
                  for (let e = 1; e <= o.length; ++e) {
                    const t = o[e];
                    if (c !== t) {
                      const n = e - 1;
                      h.frameNumbers[d] = c;
                      const i = h.positions;
                      (i[3 * d + 0] = r[3 * n + 0]), (i[3 * d + 1] = r[3 * n + 1]), (i[3 * d + 2] = r[3 * n + 2]);
                      const o = h.positionInterpolations;
                      (o[12 * d + 0] = a[12 * n + 0]),
                        (o[12 * d + 1] = a[12 * n + 1]),
                        (o[12 * d + 2] = a[12 * n + 2]),
                        (o[12 * d + 3] = a[12 * n + 3]),
                        (o[12 * d + 4] = a[12 * n + 4]),
                        (o[12 * d + 5] = a[12 * n + 5]),
                        (o[12 * d + 6] = a[12 * n + 6]),
                        (o[12 * d + 7] = a[12 * n + 7]),
                        (o[12 * d + 8] = a[12 * n + 8]),
                        (o[12 * d + 9] = a[12 * n + 9]),
                        (o[12 * d + 10] = a[12 * n + 10]),
                        (o[12 * d + 11] = a[12 * n + 11]);
                      const m = h.rotations;
                      (m[4 * d + 0] = s[4 * n + 0]),
                        (m[4 * d + 1] = s[4 * n + 1]),
                        (m[4 * d + 2] = s[4 * n + 2]),
                        (m[4 * d + 3] = s[4 * n + 3]);
                      const u = h.rotationInterpolations;
                      (u[4 * d + 0] = l[4 * n + 0]),
                        (u[4 * d + 1] = l[4 * n + 1]),
                        (u[4 * d + 2] = l[4 * n + 2]),
                        (u[4 * d + 3] = l[4 * n + 3]),
                        (d += 1),
                        (c = t);
                    }
                  }
                  m[e] = h;
                }
              }
              (s.loaded = l + i), n?.({ ...s }), (l += i);
              const u = [];
              {
                const e = new Map(),
                  i = [],
                  o = [],
                  r = [];
                for (let e = 0; e < t.length; ++e) {
                  const n = t[e].morphKeyFrames,
                    i = n.length;
                  for (let e = 0; e < i; ++e) r.push(n.get(e));
                }
                100 < performance.now() - h && (await B.Tools.DelayAsync(0), (h = performance.now()));
                const a = r.length;
                for (let t = 0; t < a; ++t) {
                  const n = r[t].morphName;
                  let a = e.get(n);
                  void 0 === a && ((a = e.size), e.set(n, a), i.push(0), o.push(n)), (i[a] += 1);
                }
                r.sort((e, t) => e.frameNumber - t.frameNumber);
                for (let t = 0; t < e.size; ++t) u.push(new nt(o[t], i[t]));
                100 < performance.now() - h && (await B.Tools.DelayAsync(0), (h = performance.now()));
                const d = new Uint32Array(e.size);
                for (let t = 0; t < a; ++t) {
                  const i = r[t],
                    o = e.get(i.morphName),
                    a = u[o],
                    c = d[o];
                  (a.frameNumbers[c] = i.frameNumber),
                    (a.weights[c] = i.weight),
                    (d[o] += 1),
                    t % 1e3 == 0 &&
                      100 < performance.now() - h &&
                      ((s.loaded = l + t), n?.({ ...s }), await B.Tools.DelayAsync(0), (h = performance.now()));
                }
              }
              const p = [];
              for (let e = 0; e < u.length; ++e) {
                const t = u[e];
                let n = !0;
                for (let e = 0; e < t.weights.length; ++e)
                  if (0 !== t.weights[e]) {
                    n = !1;
                    break;
                  }
                n || p.push(t);
              }
              if (((u.length = 0), 1 < t.length)) {
                const e = new Int32Array(p.length).fill(-1);
                for (let t = 0; t < p.length; ++t) {
                  const n = p[t].frameNumbers;
                  let i = 0,
                    o = n[0];
                  for (let e = 1; e <= n.length; ++e) {
                    const t = n[e];
                    o !== t && ((i += 1), (o = t));
                  }
                  n.length !== i && (e[t] = i);
                }
                for (let t = 0; t < p.length; ++t) {
                  const n = e[t];
                  if (-1 === n) continue;
                  const i = p[t],
                    o = i.frameNumbers,
                    r = i.weights,
                    a = new nt(i.name, n);
                  let s = 0,
                    l = o[0];
                  for (let e = 1; e <= o.length; ++e) {
                    const t = o[e];
                    l !== t && ((a.frameNumbers[s] = l), (a.weights[s] = r[e - 1]), (s += 1), (l = t));
                  }
                  p[t] = a;
                }
              }
              (s.loaded = l + o), n?.({ ...s }), (l += o);
              const g = [];
              for (let e = 0; e < t.length; ++e) {
                const n = t[e].propertyKeyFrames;
                for (let e = 0; e < n.length; ++e) g.push(n[e]);
              }
              let f;
              if ((g.sort((e, t) => e.frameNumber - t.frameNumber), 1 < t.length)) f = g;
              else {
                f = [];
                let e = g[0]?.frameNumber;
                for (let t = 1; t <= g.length; ++t) {
                  const n = g[t]?.frameNumber;
                  e !== n && (f.push(g[t - 1]), (e = n));
                }
              }
              const _ = new Set();
              for (let e = 0; e < t.length; ++e) {
                const n = t[e].propertyKeyFrames;
                for (let e = 0; e < n.length; ++e) {
                  const t = n[e];
                  for (let e = 0; e < t.ikStates.length; ++e) _.add(t.ikStates[e][0]);
                }
              }
              const b = new Array(_.size),
                y = new Map();
              {
                let e = 0;
                for (const t of _) y.set(t, e), (b[e] = t), (e += 1);
              }
              const A = new ot(f.length, b);
              {
                const e = new Uint8Array(_.size);
                for (let t = 0; t < f.length; ++t) {
                  const n = f[t];
                  (A.frameNumbers[t] = n.frameNumber), (A.visibles[t] = n.visible ? 1 : 0);
                  const i = n.ikStates;
                  e.fill(0);
                  for (let n = 0; n < i.length; ++n) {
                    const o = i[n],
                      r = y.get(o[0]);
                    (A.getIkState(r)[t] = o[1] ? 1 : 0), (e[r] = 1);
                  }
                  for (let n = 0; n < e.length; ++n)
                    if (0 === e[n]) {
                      const e = A.getIkState(n)[t - 1];
                      A.getIkState(n)[t] = void 0 === e ? 0 : e;
                    }
                }
              }
              (s.loaded = l + r), n?.({ ...s }), (l += r);
              const M = [];
              for (let e = 0; e < t.length; ++e) {
                const n = t[e].cameraKeyFrames;
                for (let e = 0; e < n.length; ++e) M.push(n.get(e));
              }
              let T;
              if ((M.sort((e, t) => e.frameNumber - t.frameNumber), 1 < t.length)) T = M;
              else {
                T = [];
                let e = M[0]?.frameNumber;
                for (let t = 1; t <= M.length; ++t) {
                  const n = M[t]?.frameNumber;
                  e !== n && (T.push(M[t - 1]), (e = n));
                }
              }
              const w = new it(T.length);
              for (let e = 0; e < T.length; ++e) {
                const t = T[e],
                  i = t.interpolation;
                w.frameNumbers[e] = t.frameNumber;
                const o = w.positions,
                  r = t.position;
                (o[3 * e + 0] = r[0]), (o[3 * e + 1] = r[1]), (o[3 * e + 2] = r[2]);
                const a = w.positionInterpolations;
                (a[12 * e + 0] = i[0]),
                  (a[12 * e + 1] = i[1]),
                  (a[12 * e + 2] = i[2]),
                  (a[12 * e + 3] = i[3]),
                  (a[12 * e + 4] = i[4]),
                  (a[12 * e + 5] = i[5]),
                  (a[12 * e + 6] = i[6]),
                  (a[12 * e + 7] = i[7]),
                  (a[12 * e + 8] = i[8]),
                  (a[12 * e + 9] = i[9]),
                  (a[12 * e + 10] = i[10]),
                  (a[12 * e + 11] = i[11]);
                const d = w.rotations,
                  c = t.rotation;
                (d[3 * e + 0] = c[0]), (d[3 * e + 1] = c[1]), (d[3 * e + 2] = c[2]);
                const m = w.rotationInterpolations;
                (m[4 * e + 0] = i[12]),
                  (m[4 * e + 1] = i[13]),
                  (m[4 * e + 2] = i[14]),
                  (m[4 * e + 3] = i[15]),
                  (w.distances[e] = t.distance);
                const u = w.distanceInterpolations;
                (u[4 * e + 0] = i[16]),
                  (u[4 * e + 1] = i[17]),
                  (u[4 * e + 2] = i[18]),
                  (u[4 * e + 3] = i[19]),
                  (w.fovs[e] = t.fov);
                const p = w.fovInterpolations;
                (p[4 * e + 0] = i[20]),
                  (p[4 * e + 1] = i[21]),
                  (p[4 * e + 2] = i[22]),
                  (p[4 * e + 3] = i[23]),
                  e % 1e3 == 0 &&
                    100 < performance.now() - h &&
                    ((s.loaded = l + e), n?.({ ...s }), await B.Tools.DelayAsync(0), (h = performance.now()));
              }
              return (s.loaded = l + a), n?.({ ...s }), (l += a), new pt(e, c, m, p, A, w);
            }
            loadFromVmdData(e, t, n, i) {
              Array.isArray(t) || (t = [t]);
              const o = [];
              for (let e = 0; e < t.length; ++e) o.push(Tt.Parse(t[e]));
              this.loadFromVmdObject(e, o, n, i);
            }
            loadFromVmdDataAsync(e, t, n) {
              return new Promise((i) => {
                this.loadFromVmdData(e, t, i, n);
              });
            }
            loadFromBuffer(e, t, n, i, o) {
              Array.isArray(t) || (t = [t]);
              const r = [];
              for (let e = 0; e < t.length; ++e) {
                const n = Mt.CheckedCreate(t[e]);
                if (null === n) return void o?.(new Error("VMD data validation failed."));
                r.push(n);
              }
              this.loadFromVmdData(e, r, n, i);
            }
            loadFromBufferAsync(e, t, n) {
              return new Promise((i, o) => {
                this.loadFromBuffer(e, t, i, n, o);
              });
            }
            load(e, t, n, i, o) {
              Array.isArray(t) || (t = [t]);
              const r = this._scene,
                a = [],
                s = [];
              for (let l = 0; l < t.length; ++l) {
                const h = t[l];
                s.push(
                  r._loadFile(
                    h,
                    (r, s) => {
                      a.push(r),
                        a.length === t.length &&
                          this.loadFromBuffer(e, a, n, i, (e) => {
                            o?.(void 0, e);
                          });
                    },
                    i,
                    !0,
                    !0,
                    o
                  )
                );
              }
              return 1 === t.length ? s[0] : s;
            }
            loadAsync(e, t, n) {
              return new Promise((i, o) => {
                this.load(e, t, i, n, (e, t) => o({ request: e, exception: t }));
              });
            }
            get loggingEnabled() {
              return this._loggingEnabled;
            }
            set loggingEnabled(e) {
              (this._loggingEnabled = e),
                e
                  ? ((this.log = this._logEnabled), (this.warn = this._warnEnabled), (this.error = this._errorEnabled))
                  : ((this.log = this._logDisabled),
                    (this.warn = this._warnDisabled),
                    (this.error = this._errorDisabled));
            }
            _logEnabled(e) {
              k.Logger.Log(e);
            }
            _logDisabled() {}
            _warnEnabled(e) {
              k.Logger.Warn(e);
            }
            _warnDisabled() {}
            _errorEnabled(e) {
              k.Logger.Error(e);
            }
            _errorDisabled() {}
          }
          class Rt {
            _scene;
            _textDecoder;
            _loggingEnabled;
            log;
            warn;
            error;
            constructor(e) {
              (this._loggingEnabled = !1),
                (this.log = this._logDisabled),
                (this.warn = this._warnDisabled),
                (this.error = this._errorDisabled),
                (this._scene = e),
                (this._textDecoder = new TextDecoder("shift_jis"));
            }
            loadFromVpdObject(e, t) {
              const n = t.bones,
                i = Object.keys(n);
              let o = 0;
              for (let e = 0; e < i.length; e++) void 0 !== n[i[e]].position && (o += 1);
              const r = new Array(i.length - o),
                a = new Array(o);
              let s = 0,
                l = 0;
              for (let e = 0; e < i.length; e++) {
                const t = i[e],
                  o = n[t];
                if (void 0 === o.position) {
                  const e = (r[s] = new et(t, 1));
                  (e.rotations[0] = o.rotation[0]),
                    (e.rotations[1] = o.rotation[1]),
                    (e.rotations[2] = o.rotation[2]),
                    (e.rotations[3] = o.rotation[3]),
                    (s += 1);
                } else {
                  const e = (a[l] = new tt(t, 1));
                  (e.positions[0] = o.position[0]),
                    (e.positions[1] = o.position[1]),
                    (e.positions[2] = o.position[2]),
                    (e.rotations[0] = o.rotation[0]),
                    (e.rotations[1] = o.rotation[1]),
                    (e.rotations[2] = o.rotation[2]),
                    (e.rotations[3] = o.rotation[3]),
                    (l += 1);
                }
              }
              const h = t.morphs,
                d = Object.keys(h),
                c = new Array(d.length);
              for (let e = 0; e < d.length; e++) {
                const t = d[e];
                (c[e] = new nt(t, 1)).weights[0] = h[t];
              }
              return new pt(e, r, a, c, new ot(0, []), new it(0));
            }
            loadFromBuffer(e, t) {
              const n = this._textDecoder.decode(t),
                i = wt.Parse(n, this);
              return this.loadFromVpdObject(e, i);
            }
            load(e, t, n, i, o) {
              return this._scene._loadFile(t, (t) => n(this.loadFromBuffer(e, t)), i, !0, !0, o);
            }
            loadAsync(e, t, n) {
              return new Promise((i, o) => {
                this.load(e, t, i, n, (e, t) => o({ request: e, exception: t }));
              });
            }
            get loggingEnabled() {
              return this._loggingEnabled;
            }
            set loggingEnabled(e) {
              (this._loggingEnabled = e),
                e
                  ? ((this.log = this._logEnabled), (this.warn = this._warnEnabled), (this.error = this._errorEnabled))
                  : ((this.log = this._logDisabled),
                    (this.warn = this._warnDisabled),
                    (this.error = this._errorDisabled));
            }
            _logEnabled(e) {
              k.Logger.Log(e);
            }
            _logDisabled() {}
            _warnEnabled(e) {
              k.Logger.Warn(e);
            }
            _warnDisabled() {}
            _errorEnabled(e) {
              k.Logger.Error(e);
            }
            _errorDisabled() {}
          }
          class St {
            onLoadErrorObservable;
            onDurationChangedObservable;
            onPlaybackRateChangedObservable;
            onMuteStateChangedObservable;
            onPlayObservable;
            onPauseObservable;
            onSeekObservable;
            _audio;
            _duration;
            _playbackRate;
            _isVirtualPlay;
            _virtualStartTime;
            _virtualPaused;
            _virtualPauseCurrentTime;
            _metadataLoaded;
            _bindedDispose;
            _disposeObservableObject;
            constructor(e) {
              (this.onLoadErrorObservable = new U.Observable()),
                (this.onDurationChangedObservable = new U.Observable()),
                (this.onPlaybackRateChangedObservable = new U.Observable()),
                (this.onMuteStateChangedObservable = new U.Observable()),
                (this.onPlayObservable = new U.Observable()),
                (this.onPauseObservable = new U.Observable()),
                (this.onSeekObservable = new U.Observable());
              const t = (this._audio = new Audio());
              (t.loop = !1),
                (t.autoplay = !1),
                (this._duration = 0),
                (this._playbackRate = 1),
                (this._isVirtualPlay = !1),
                (this._virtualStartTime = 0),
                (this._virtualPaused = !0),
                (this._virtualPauseCurrentTime = 0),
                (this._metadataLoaded = !1),
                (t.ondurationchange = this._onDurationChanged),
                (t.onerror = this._onLoadError),
                (t.onplaying = this._onPlay),
                (t.onpause = this._onPause),
                (t.onseeked = this._onSeek),
                (this._bindedDispose = this.dispose.bind(this)),
                (this._disposeObservableObject = e),
                null !== this._disposeObservableObject &&
                  this._disposeObservableObject.onDisposeObservable.add(this._bindedDispose);
            }
            _onDurationChanged = () => {
              (this._duration = this._audio.duration),
                this._isVirtualPlay &&
                  ((this._isVirtualPlay = !1), this.onMuteStateChangedObservable.notifyObservers()),
                (this._virtualPaused = !0),
                (this._virtualPauseCurrentTime = 0),
                (this._metadataLoaded = !0),
                this.onDurationChangedObservable.notifyObservers();
            };
            _onLoadError = () => {
              (this._duration = 0),
                this._isVirtualPlay &&
                  ((this._isVirtualPlay = !1), this.onMuteStateChangedObservable.notifyObservers()),
                (this._virtualPaused = !0),
                (this._virtualPauseCurrentTime = 0),
                (this._metadataLoaded = !1),
                this.onLoadErrorObservable.notifyObservers(),
                this.onDurationChangedObservable.notifyObservers();
            };
            _onPlay = () => {
              this._isVirtualPlay || (this._audio.playbackRate = this._playbackRate),
                this.onPlayObservable.notifyObservers();
            };
            _onPause = () => {
              this._isVirtualPlay
                ? this._virtualPaused && this.onPauseObservable.notifyObservers()
                : this.onPauseObservable.notifyObservers();
            };
            _ignoreSeekedEventOnce = !1;
            _onSeek = () => {
              this._ignoreSeekedEventOnce
                ? (this._ignoreSeekedEventOnce = !1)
                : this.onSeekObservable.notifyObservers();
            };
            get duration() {
              return this._duration;
            }
            get currentTime() {
              if (this._isVirtualPlay) {
                if (this._virtualPaused) return this._virtualPauseCurrentTime;
                {
                  const e = (performance.now() / 1e3 - this._virtualStartTime) * this._playbackRate;
                  return e > this._duration
                    ? ((this._virtualPaused = !0),
                      (this._virtualPauseCurrentTime = this._duration),
                      this._onPause(),
                      this._virtualPauseCurrentTime)
                    : e;
                }
              }
              return this._audio.currentTime;
            }
            set currentTime(e) {
              this._isVirtualPlay
                ? (this._virtualPaused
                    ? (this._virtualPauseCurrentTime = e)
                    : (this._virtualStartTime = performance.now() / 1e3 - e / this._playbackRate),
                  this._onSeek())
                : (this._audio.currentTime = e);
            }
            _setCurrentTimeWithoutNotify(e) {
              this._isVirtualPlay
                ? this._virtualPaused
                  ? (this._virtualPauseCurrentTime = e)
                  : (this._virtualStartTime = performance.now() / 1e3 - e / this._playbackRate)
                : ((this._ignoreSeekedEventOnce = !0), (this._audio.currentTime = e));
            }
            get volume() {
              return this._audio.volume;
            }
            set volume(e) {
              this._audio.volume = e;
            }
            get muted() {
              return this._isVirtualPlay;
            }
            mute() {
              this._isVirtualPlay ||
                ((this._isVirtualPlay = !0),
                (this._virtualStartTime = performance.now() / 1e3 - this._audio.currentTime / this._playbackRate),
                (this._virtualPaused = this._audio.paused),
                (this._virtualPauseCurrentTime = this._audio.currentTime),
                this._audio.pause(),
                this.onMuteStateChangedObservable.notifyObservers());
            }
            async unmute() {
              if (!this._isVirtualPlay) return !1;
              let e = !1;
              if (((this._ignoreSeekedEventOnce = !0), this._virtualPaused))
                this._audio.currentTime = this._virtualPauseCurrentTime;
              else {
                this._audio.currentTime = (performance.now() / 1e3 - this._virtualStartTime) * this._playbackRate;
                try {
                  await this._audio.play(), (this._audio.playbackRate = this._playbackRate);
                } catch (t) {
                  if (!(t instanceof DOMException && "NotAllowedError" === t.name)) throw t;
                  e = !0;
                }
              }
              return (
                !e &&
                ((this._isVirtualPlay = !1),
                (this._virtualPaused = !0),
                (this._virtualPauseCurrentTime = 0),
                this.onMuteStateChangedObservable.notifyObservers(),
                !0)
              );
            }
            get playbackRate() {
              return this._playbackRate;
            }
            set playbackRate(e) {
              this._setPlaybackRateWithoutNotify(e), this.onPlaybackRateChangedObservable.notifyObservers();
            }
            _setPlaybackRateWithoutNotify(e) {
              if (this._isVirtualPlay && !this._virtualPaused) {
                const t = performance.now() / 1e3,
                  n = (t - this._virtualStartTime) * this._playbackRate;
                this._virtualStartTime = t - n / e;
              }
              (this._playbackRate = e), (this._audio.playbackRate = e);
            }
            get preservesPitch() {
              return this._audio.preservesPitch;
            }
            set preservesPitch(e) {
              this._audio.preservesPitch = e;
            }
            get paused() {
              return this._isVirtualPlay ? this._virtualPaused : this._audio.paused;
            }
            get source() {
              return this._audio.src;
            }
            set source(e) {
              e !== this._audio.src &&
                ((this._audio.src = e),
                (this._metadataLoaded = !1),
                this._isVirtualPlay &&
                  ((this._isVirtualPlay = !1), this.onMuteStateChangedObservable.notifyObservers()),
                (this._virtualPaused = !0),
                (this._virtualPauseCurrentTime = 0),
                this._audio.load());
            }
            get metadataLoaded() {
              return this._metadataLoaded;
            }
            async _virtualPlay() {
              this._metadataLoaded
                ? (this._virtualPaused &&
                    ((this._virtualStartTime =
                      performance.now() / 1e3 - this._virtualPauseCurrentTime / this._playbackRate),
                    (this._virtualPaused = !1)),
                  this._isVirtualPlay ||
                    ((this._isVirtualPlay = !0), this.onMuteStateChangedObservable.notifyObservers()),
                  this._onPlay())
                : await new Promise((e, t) => {
                    const n = () => {
                        this._virtualPaused &&
                          ((this._virtualStartTime =
                            performance.now() / 1e3 - this._virtualPauseCurrentTime / this._playbackRate),
                          (this._virtualPaused = !1)),
                          this._isVirtualPlay ||
                            ((this._isVirtualPlay = !0), this.onMuteStateChangedObservable.notifyObservers()),
                          this._onPlay(),
                          this.onLoadErrorObservable.removeCallback(i),
                          e();
                      },
                      i = () => {
                        this.onDurationChangedObservable.removeCallback(n),
                          t(
                            new DOMException(
                              "The media resource indicated by the src attribute or assigned media provider object was not suitable.",
                              "NotSupportedError"
                            )
                          );
                      };
                    this.onDurationChangedObservable.addOnce(n), this.onLoadErrorObservable.addOnce(i);
                  });
            }
            _playRequestBlocking = !1;
            async play() {
              if (!this._isVirtualPlay || this._virtualPaused)
                if (this._isVirtualPlay) await this._virtualPlay();
                else if (!this._playRequestBlocking) {
                  this._playRequestBlocking = !0;
                  try {
                    await this._audio.play();
                  } catch (e) {
                    if (!(e instanceof DOMException && "NotAllowedError" === e.name)) throw e;
                    await this._virtualPlay();
                  } finally {
                    this._playRequestBlocking = !1;
                  }
                }
            }
            pause() {
              if (this._isVirtualPlay) {
                if (this._virtualPaused) return;
                (this._virtualPaused = !0),
                  (this._virtualPauseCurrentTime =
                    (performance.now() / 1e3 - this._virtualStartTime) * this._playbackRate),
                  this._onPause();
              } else this._audio.pause();
            }
            dispose() {
              const e = this._audio;
              e.pause(),
                (e.ondurationchange = null),
                (e.onerror = null),
                (e.onplaying = null),
                (e.onpause = null),
                (e.onseeked = null),
                this._audio.remove(),
                this.onLoadErrorObservable.clear(),
                this.onDurationChangedObservable.clear(),
                this.onPlaybackRateChangedObservable.clear(),
                this.onMuteStateChangedObservable.clear(),
                this.onPlayObservable.clear(),
                this.onPauseObservable.clear(),
                this.onSeekObservable.clear(),
                null !== this._disposeObservableObject &&
                  this._disposeObservableObject.onDisposeObservable.removeCallback(this._bindedDispose);
            }
          }
          let Ct, Et;
          const kt = new Array(128).fill(void 0);
          function Nt(e) {
            return kt[e];
          }
          kt.push(void 0, null, !0, !1);
          let Dt = kt.length;
          function Lt(e) {
            const t = Nt(e);
            return (
              (function (e) {
                e < 132 || ((kt[e] = Dt), (Dt = e));
              })(e),
              t
            );
          }
          function Ut(e) {
            Dt === kt.length && kt.push(kt.length + 1);
            const t = Dt;
            if (((Dt = kt[t]), "number" != typeof Dt)) throw new Error("corrupt heap");
            return (kt[t] = e), t;
          }
          function Vt(e) {
            if ("boolean" != typeof e) throw new Error("expected a boolean argument, found " + typeof e);
          }
          const Wt =
            "undefined" != typeof TextDecoder
              ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 })
              : {
                  decode: () => {
                    throw Error("TextDecoder not available");
                  },
                };
          "undefined" != typeof TextDecoder && Wt.decode();
          let zt = null;
          function Kt() {
            return (null !== zt && zt.buffer === Et.memory.buffer) || (zt = new Uint8Array(Et.memory.buffer)), zt;
          }
          function jt(e, t) {
            return (e >>>= 0), Wt.decode(Kt().slice(e, e + t));
          }
          function Yt(e) {
            if ("number" != typeof e) throw new Error("expected a number argument, found " + typeof e);
          }
          function Qt(e) {
            return null == e;
          }
          function qt(e, t) {
            if (!(e instanceof t)) throw new Error(`expected instance of ${t.name}`);
            return e.ptr;
          }
          function Ht() {
            Et.init();
          }
          function Gt() {
            const e = Et.createMmdRuntime();
            return dn.__wrap(e);
          }
          function $t() {
            const e = Et.createAnimationPool();
            return ln.__wrap(e);
          }
          function Xt(e, t) {
            try {
              return e.apply(this, t);
            } catch (e) {
              let t = (function () {
                try {
                  return e instanceof Error ? `${e.message}\n\nStack:\n${e.stack}` : e.toString();
                } catch (e) {
                  return "<failed to stringify thrown value>";
                }
              })();
              throw (
                (console.error("wasm-bindgen: imported JS function that was not marked as `catch` threw an error:", t),
                e)
              );
            }
          }
          let Jt = 0;
          const Zt =
              "undefined" != typeof TextEncoder
                ? new TextEncoder("utf-8")
                : {
                    encode: () => {
                      throw Error("TextEncoder not available");
                    },
                  },
            en = function (e, t) {
              const n = Zt.encode(e);
              return t.set(n), { read: e.length, written: n.length };
            };
          let tn = null;
          function nn() {
            return (null !== tn && tn.buffer === Et.memory.buffer) || (tn = new Int32Array(Et.memory.buffer)), tn;
          }
          function on(e, t) {
            try {
              return e.apply(this, t);
            } catch (e) {
              Et.__wbindgen_exn_store(Ut(e));
            }
          }
          function rn(e) {
            return Yt(e), Lt(Et.initThreadPool(e));
          }
          function an(e) {
            Yt(e), Et.wbg_rayon_start_worker(e);
          }
          const sn =
            "undefined" == typeof FinalizationRegistry
              ? { register: () => {}, unregister: () => {} }
              : new FinalizationRegistry((e) => Et.__wbg_animationpool_free(e >>> 0));
          class ln {
            constructor() {
              throw new Error("cannot invoke `new` directly");
            }
            static __wrap(e) {
              e >>>= 0;
              const t = Object.create(ln.prototype);
              return (t.__wbg_ptr = e), sn.register(t, t.__wbg_ptr, t), t;
            }
            __destroy_into_raw() {
              const e = this.__wbg_ptr;
              return (this.__wbg_ptr = 0), sn.unregister(this), e;
            }
            free() {
              const e = this.__destroy_into_raw();
              Et.__wbg_animationpool_free(e);
            }
            allocateLengthsBuffer(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return Yt(this.__wbg_ptr), Yt(e), Et.animationpool_allocateLengthsBuffer(this.__wbg_ptr, e) >>> 0;
            }
            deallocateLengthsBuffer(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              Yt(this.__wbg_ptr), Yt(e), Yt(t), Et.animationpool_deallocateLengthsBuffer(this.__wbg_ptr, e, t);
            }
            createBoneTracks(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return Yt(this.__wbg_ptr), Yt(e), Yt(t), Et.animationpool_createBoneTracks(this.__wbg_ptr, e, t) >>> 0;
            }
            getBoneTrackFrameNumbers(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                Yt(this.__wbg_ptr), Yt(e), Yt(t), Et.animationpool_getBoneTrackFrameNumbers(this.__wbg_ptr, e, t) >>> 0
              );
            }
            getBoneTrackRotations(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                Yt(this.__wbg_ptr), Yt(e), Yt(t), Et.animationpool_getBoneTrackRotations(this.__wbg_ptr, e, t) >>> 0
              );
            }
            getBoneTrackRotationInterpolations(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                Yt(this.__wbg_ptr),
                Yt(e),
                Yt(t),
                Et.animationpool_getBoneTrackRotationInterpolations(this.__wbg_ptr, e, t) >>> 0
              );
            }
            createMovableBoneTracks(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                Yt(this.__wbg_ptr), Yt(e), Yt(t), Et.animationpool_createMovableBoneTracks(this.__wbg_ptr, e, t) >>> 0
              );
            }
            getMovableBoneTrackFrameNumbers(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                Yt(this.__wbg_ptr),
                Yt(e),
                Yt(t),
                Et.animationpool_getMovableBoneTrackFrameNumbers(this.__wbg_ptr, e, t) >>> 0
              );
            }
            getMovableBoneTrackPositions(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                Yt(this.__wbg_ptr),
                Yt(e),
                Yt(t),
                Et.animationpool_getMovableBoneTrackPositions(this.__wbg_ptr, e, t) >>> 0
              );
            }
            getMovableBoneTrackPositionInterpolations(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                Yt(this.__wbg_ptr),
                Yt(e),
                Yt(t),
                Et.animationpool_getMovableBoneTrackPositionInterpolations(this.__wbg_ptr, e, t) >>> 0
              );
            }
            getMovableBoneTrackRotations(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                Yt(this.__wbg_ptr),
                Yt(e),
                Yt(t),
                Et.animationpool_getMovableBoneTrackRotations(this.__wbg_ptr, e, t) >>> 0
              );
            }
            getMovableBoneTrackRotationInterpolations(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                Yt(this.__wbg_ptr),
                Yt(e),
                Yt(t),
                Et.animationpool_getMovableBoneTrackRotationInterpolations(this.__wbg_ptr, e, t) >>> 0
              );
            }
            createMorphTracks(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return Yt(this.__wbg_ptr), Yt(e), Yt(t), Et.animationpool_createMorphTracks(this.__wbg_ptr, e, t) >>> 0;
            }
            getMorphTrackFrameNumbers(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                Yt(this.__wbg_ptr), Yt(e), Yt(t), Et.animationpool_getMorphTrackFrameNumbers(this.__wbg_ptr, e, t) >>> 0
              );
            }
            getMorphTrackWeights(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                Yt(this.__wbg_ptr), Yt(e), Yt(t), Et.animationpool_getMorphTrackWeights(this.__wbg_ptr, e, t) >>> 0
              );
            }
            createAnimation(e, t, n, i, o, r, a, s) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                Yt(this.__wbg_ptr),
                Yt(e),
                Yt(t),
                Yt(n),
                Yt(i),
                Yt(o),
                Yt(r),
                Yt(a),
                Yt(s),
                Et.animationpool_createAnimation(this.__wbg_ptr, e, t, n, i, o, r, a, s) >>> 0
              );
            }
            getPropertyTrackFrameNumbers(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return Yt(this.__wbg_ptr), Yt(e), Et.animationpool_getPropertyTrackFrameNumbers(this.__wbg_ptr, e) >>> 0;
            }
            getPropertyTrackIkStates(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                Yt(this.__wbg_ptr), Yt(e), Yt(t), Et.animationpool_getPropertyTrackIkStates(this.__wbg_ptr, e, t) >>> 0
              );
            }
            destroyAnimation(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              Yt(this.__wbg_ptr), Yt(e), Et.animationpool_destroyAnimation(this.__wbg_ptr, e);
            }
            createBoneBindIndexMap(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return Yt(this.__wbg_ptr), Yt(e), Et.animationpool_createBoneBindIndexMap(this.__wbg_ptr, e) >>> 0;
            }
            createMovableBoneBindIndexMap(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return Yt(this.__wbg_ptr), Yt(e), Et.animationpool_createMovableBoneBindIndexMap(this.__wbg_ptr, e) >>> 0;
            }
            createMorphBindIndexMap(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                Yt(this.__wbg_ptr), Yt(e), Yt(t), Et.animationpool_createMorphBindIndexMap(this.__wbg_ptr, e, t) >>> 0
              );
            }
            getNthMorphBindIndexMap(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                Yt(this.__wbg_ptr), Yt(e), Yt(t), Et.animationpool_getNthMorphBindIndexMap(this.__wbg_ptr, e, t) >>> 0
              );
            }
            createIkSolverBindIndexMap(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return Yt(this.__wbg_ptr), Yt(e), Et.animationpool_createIkSolverBindIndexMap(this.__wbg_ptr, e) >>> 0;
            }
            createRuntimeAnimation(e, t, n, i, o) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                Yt(this.__wbg_ptr),
                Yt(e),
                Yt(t),
                Yt(n),
                Yt(i),
                Yt(o),
                Et.animationpool_createRuntimeAnimation(this.__wbg_ptr, e, t, n, i, o) >>> 0
              );
            }
            destroyRuntimeAnimation(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              Yt(this.__wbg_ptr), Yt(e), Et.animationpool_destroyRuntimeAnimation(this.__wbg_ptr, e);
            }
            animateMmdModel(e, t, n) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              Yt(this.__wbg_ptr), Yt(e), Yt(t), Et.animationpool_animateMmdModel(this.__wbg_ptr, e, t, n);
            }
          }
          const hn =
            "undefined" == typeof FinalizationRegistry
              ? { register: () => {}, unregister: () => {} }
              : new FinalizationRegistry((e) => Et.__wbg_mmdruntime_free(e >>> 0));
          class dn {
            constructor() {
              throw new Error("cannot invoke `new` directly");
            }
            static __wrap(e) {
              e >>>= 0;
              const t = Object.create(dn.prototype);
              return (t.__wbg_ptr = e), hn.register(t, t.__wbg_ptr, t), t;
            }
            __destroy_into_raw() {
              const e = this.__wbg_ptr;
              return (this.__wbg_ptr = 0), hn.unregister(this), e;
            }
            free() {
              const e = this.__destroy_into_raw();
              Et.__wbg_mmdruntime_free(e);
            }
            allocateBuffer(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return Yt(this.__wbg_ptr), Yt(e), Et.mmdruntime_allocateBuffer(this.__wbg_ptr, e) >>> 0;
            }
            deallocateBuffer(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              Yt(this.__wbg_ptr), Yt(e), Yt(t), Et.mmdruntime_deallocateBuffer(this.__wbg_ptr, e, t);
            }
            createMmdModel(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return Yt(this.__wbg_ptr), Yt(e), Yt(t), Et.mmdruntime_createMmdModel(this.__wbg_ptr, e, t) >>> 0;
            }
            destroyMmdModel(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              Yt(this.__wbg_ptr), Yt(e), Et.mmdruntime_destroyMmdModel(this.__wbg_ptr, e);
            }
            getAnimationArena(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return Yt(this.__wbg_ptr), Yt(e), Et.mmdruntime_getAnimationArena(this.__wbg_ptr, e) >>> 0;
            }
            getAnimationIkSolverStateArena(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return Yt(this.__wbg_ptr), Yt(e), Et.mmdruntime_getAnimationIkSolverStateArena(this.__wbg_ptr, e) >>> 0;
            }
            getAnimationMorphArena(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return Yt(this.__wbg_ptr), Yt(e), Et.mmdruntime_getAnimationMorphArena(this.__wbg_ptr, e) >>> 0;
            }
            getBoneWorldMatrixArena(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return Yt(this.__wbg_ptr), Yt(e), Et.mmdruntime_getBoneWorldMatrixArena(this.__wbg_ptr, e) >>> 0;
            }
            createBoneWorldMatrixBackBuffer(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return Yt(this.__wbg_ptr), Yt(e), Et.mmdruntime_createBoneWorldMatrixBackBuffer(this.__wbg_ptr, e) >>> 0;
            }
            setRuntimeAnimation(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              Yt(this.__wbg_ptr), Yt(e), Yt(t), Et.mmdruntime_setRuntimeAnimation(this.__wbg_ptr, e, t);
            }
            beforePhysics(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              Yt(this.__wbg_ptr), Qt(e) || Yt(e), Et.mmdruntime_beforePhysics(this.__wbg_ptr, !Qt(e), Qt(e) ? 0 : e);
            }
            afterPhysics() {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              Yt(this.__wbg_ptr), Et.mmdruntime_afterPhysics(this.__wbg_ptr);
            }
            getLockStatePtr() {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return Yt(this.__wbg_ptr), Et.mmdruntime_getLockStatePtr(this.__wbg_ptr) >>> 0;
            }
            swapWorldMatrixBuffer() {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              Yt(this.__wbg_ptr), Et.mmdruntime_swapWorldMatrixBuffer(this.__wbg_ptr);
            }
            static bufferedBeforePhysics(e, t) {
              if ((qt(e, dn), 0 === e.__wbg_ptr)) throw new Error("Attempt to use a moved value");
              Qt(t) || Yt(t), Et.mmdruntime_bufferedBeforePhysics(e.__wbg_ptr, !Qt(t), Qt(t) ? 0 : t);
            }
            static bufferedUpdate(e, t) {
              if ((qt(e, dn), 0 === e.__wbg_ptr)) throw new Error("Attempt to use a moved value");
              Qt(t) || Yt(t), Et.mmdruntime_bufferedUpdate(e.__wbg_ptr, !Qt(t), Qt(t) ? 0 : t);
            }
            updateBoneWorldMatrix(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              Yt(this.__wbg_ptr), Yt(e), Yt(t), Et.mmdruntime_updateBoneWorldMatrix(this.__wbg_ptr, e, t);
            }
            updateBackBufferBoneWorldMatrix(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              Yt(this.__wbg_ptr), Yt(e), Yt(t), Et.mmdruntime_updateBackBufferBoneWorldMatrix(this.__wbg_ptr, e, t);
            }
            updataBoneLocalMatrices(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              Yt(this.__wbg_ptr), Yt(e), Et.mmdruntime_updataBoneLocalMatrices(this.__wbg_ptr, e);
            }
          }
          const cn =
            "undefined" == typeof FinalizationRegistry
              ? { register: () => {}, unregister: () => {} }
              : new FinalizationRegistry((e) => Et.__wbg_wbg_rayon_poolbuilder_free(e >>> 0));
          class mn {
            constructor() {
              throw new Error("cannot invoke `new` directly");
            }
            static __wrap(e) {
              e >>>= 0;
              const t = Object.create(mn.prototype);
              return (t.__wbg_ptr = e), cn.register(t, t.__wbg_ptr, t), t;
            }
            __destroy_into_raw() {
              const e = this.__wbg_ptr;
              return (this.__wbg_ptr = 0), cn.unregister(this), e;
            }
            free() {
              const e = this.__destroy_into_raw();
              Et.__wbg_wbg_rayon_poolbuilder_free(e);
            }
            numThreads() {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return Yt(this.__wbg_ptr), Et.wbg_rayon_poolbuilder_numThreads(this.__wbg_ptr) >>> 0;
            }
            receiver() {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return Yt(this.__wbg_ptr), Et.wbg_rayon_poolbuilder_receiver(this.__wbg_ptr) >>> 0;
            }
            build() {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              Yt(this.__wbg_ptr), Et.wbg_rayon_poolbuilder_build(this.__wbg_ptr);
            }
          }
          function un() {
            const e = { wbg: {} };
            return (
              (e.wbg.__wbindgen_object_drop_ref = function (e) {
                Lt(e);
              }),
              (e.wbg.__wbg_new_abda76e883ba8a5f = function () {
                return Xt(function () {
                  return Ut(new Error());
                }, arguments);
              }),
              (e.wbg.__wbg_stack_658279fe44541cf6 = function () {
                return Xt(function (e, t) {
                  const n = (function (e, t, n) {
                      if ("string" != typeof e) throw new Error("expected a string argument, found " + typeof e);
                      if (void 0 === n) {
                        const n = Zt.encode(e),
                          i = t(n.length, 1) >>> 0;
                        return (
                          Kt()
                            .subarray(i, i + n.length)
                            .set(n),
                          (Jt = n.length),
                          i
                        );
                      }
                      let i = e.length,
                        o = t(i, 1) >>> 0;
                      const r = Kt();
                      let a = 0;
                      for (; a < i; a++) {
                        const t = e.charCodeAt(a);
                        if (t > 127) break;
                        r[o + a] = t;
                      }
                      if (a !== i) {
                        0 !== a && (e = e.slice(a)), (o = n(o, i, (i = a + 3 * e.length), 1) >>> 0);
                        const t = Kt().subarray(o + a, o + i),
                          r = en(e, t);
                        if (r.read !== e.length) throw new Error("failed to pass whole string");
                        (a += r.written), (o = n(o, i, a, 1) >>> 0);
                      }
                      return (Jt = a), o;
                    })(Nt(t).stack, Et.__wbindgen_malloc, Et.__wbindgen_realloc),
                    i = Jt;
                  (nn()[e / 4 + 1] = i), (nn()[e / 4 + 0] = n);
                }, arguments);
              }),
              (e.wbg.__wbg_error_f851667af71bcfc6 = function () {
                return Xt(function (e, t) {
                  let n, i;
                  try {
                    (n = e), (i = t), console.error(jt(e, t));
                  } finally {
                    Et.__wbindgen_free(n, i, 1);
                  }
                }, arguments);
              }),
              (e.wbg.__wbg_instanceof_Window_cee7a886d55e7df5 = function () {
                return Xt(function (e) {
                  let t;
                  try {
                    t = Nt(e) instanceof Window;
                  } catch (e) {
                    t = !1;
                  }
                  const n = t;
                  return Vt(n), n;
                }, arguments);
              }),
              (e.wbg.__wbg_newnoargs_cfecb3965268594c = function () {
                return Xt(function (e, t) {
                  return Ut(new Function(jt(e, t)));
                }, arguments);
              }),
              (e.wbg.__wbg_call_3f093dd26d5569f8 = function () {
                return on(function (e, t) {
                  return Ut(Nt(e).call(Nt(t)));
                }, arguments);
              }),
              (e.wbg.__wbindgen_object_clone_ref = function (e) {
                return Ut(Nt(e));
              }),
              (e.wbg.__wbg_self_05040bd9523805b9 = function () {
                return on(function () {
                  return Ut(self.self);
                }, arguments);
              }),
              (e.wbg.__wbg_window_adc720039f2cb14f = function () {
                return on(function () {
                  return Ut(window.window);
                }, arguments);
              }),
              (e.wbg.__wbg_globalThis_622105db80c1457d = function () {
                return on(function () {
                  return Ut(globalThis.globalThis);
                }, arguments);
              }),
              (e.wbg.__wbg_global_f56b013ed9bcf359 = function () {
                return on(function () {
                  return Ut(H.g.global);
                }, arguments);
              }),
              (e.wbg.__wbindgen_is_undefined = function (e) {
                const t = void 0 === Nt(e);
                return Vt(t), t;
              }),
              (e.wbg.__wbindgen_throw = function (e, t) {
                throw new Error(jt(e, t));
              }),
              (e.wbg.__wbindgen_module = function () {
                return Ut(_n.__wbindgen_wasm_module);
              }),
              (e.wbg.__wbindgen_memory = function () {
                return Ut(Et.memory);
              }),
              (e.wbg.__wbg_startWorkers_2ee336a9694dda13 = function () {
                return Xt(function (e, t, n) {
                  return Ut(
                    (async function (e, t, n) {
                      if (0 === n.numThreads()) throw new Error("num_threads must be > 0.");
                      const i = { module: e, memory: t, receiver: n.receiver() };
                      (Ct = await Promise.all(
                        Array.from({ length: n.numThreads() }, async () => {
                          const e = new Worker(new URL(H.p + H.u(614), H.b), { type: void 0 });
                          return (
                            e.postMessage(i),
                            await new Promise((t) => e.addEventListener("message", t, { once: !0 })),
                            e
                          );
                        })
                      )),
                        n.build();
                    })(Lt(e), Lt(t), mn.__wrap(n))
                  );
                }, arguments);
              }),
              e
            );
          }
          function pn(e, t) {
            e.wbg.memory = t || new WebAssembly.Memory({ initial: 19, maximum: 16384, shared: !0 });
          }
          function gn(e, t) {
            return (
              (Et = e.exports), (_n.__wbindgen_wasm_module = t), (tn = null), (zt = null), Et.__wbindgen_start(), Et
            );
          }
          function fn(e, t) {
            if (void 0 !== Et) return Et;
            const n = un();
            return (
              pn(n, t),
              e instanceof WebAssembly.Module || (e = new WebAssembly.Module(e)),
              gn(new WebAssembly.Instance(e, n), e)
            );
          }
          async function _n(e, t) {
            if (void 0 !== Et) return Et;
            void 0 === e && (e = new URL(H(858), H.b));
            const n = un();
            ("string" == typeof e ||
              ("function" == typeof Request && e instanceof Request) ||
              ("function" == typeof URL && e instanceof URL)) &&
              (e = fetch(e)),
              pn(n, t);
            const { instance: i, module: o } = await (async function (e, t) {
              if ("function" == typeof Response && e instanceof Response) {
                if ("function" == typeof WebAssembly.instantiateStreaming)
                  try {
                    return await WebAssembly.instantiateStreaming(e, t);
                  } catch (t) {
                    if ("application/wasm" == e.headers.get("Content-Type")) throw t;
                    console.warn(
                      "`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",
                      t
                    );
                  }
                const n = await e.arrayBuffer();
                return await WebAssembly.instantiate(n, t);
              }
              {
                const n = await WebAssembly.instantiate(e, t);
                return n instanceof WebAssembly.Instance ? { instance: n, module: e } : n;
              }
            })(await e, n);
            return gn(i, o);
          }
          const bn = _n;
          class yn {
            getWasmInstanceInner() {
              return e;
            }
          }
          let An, Mn;
          const Tn = new Array(128).fill(void 0);
          function wn(e) {
            return Tn[e];
          }
          Tn.push(void 0, null, !0, !1);
          let xn = Tn.length;
          function In(e) {
            const t = wn(e);
            return (
              (function (e) {
                e < 132 || ((Tn[e] = xn), (xn = e));
              })(e),
              t
            );
          }
          function vn(e) {
            xn === Tn.length && Tn.push(Tn.length + 1);
            const t = xn;
            return (xn = Tn[t]), (Tn[t] = e), t;
          }
          const Bn =
            "undefined" != typeof TextDecoder
              ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 })
              : {
                  decode: () => {
                    throw Error("TextDecoder not available");
                  },
                };
          "undefined" != typeof TextDecoder && Bn.decode();
          let Pn = null;
          function On(e, t) {
            return (
              (e >>>= 0),
              Bn.decode(
                ((null !== Pn && Pn.buffer === Mn.memory.buffer) || (Pn = new Uint8Array(Mn.memory.buffer)), Pn).slice(
                  e,
                  e + t
                )
              )
            );
          }
          function Fn(e) {
            return null == e;
          }
          function Rn(e, t) {
            if (!(e instanceof t)) throw new Error(`expected instance of ${t.name}`);
            return e.ptr;
          }
          function Sn() {
            Mn.init();
          }
          function Cn() {
            const e = Mn.createMmdRuntime();
            return Wn.__wrap(e);
          }
          function En() {
            const e = Mn.createAnimationPool();
            return Un.__wrap(e);
          }
          function kn(e, t) {
            try {
              return e.apply(this, t);
            } catch (e) {
              Mn.__wbindgen_exn_store(vn(e));
            }
          }
          function Nn(e) {
            return In(Mn.initThreadPool(e));
          }
          function Dn(e) {
            Mn.wbg_rayon_start_worker(e);
          }
          const Ln =
            "undefined" == typeof FinalizationRegistry
              ? { register: () => {}, unregister: () => {} }
              : new FinalizationRegistry((e) => Mn.__wbg_animationpool_free(e >>> 0));
          class Un {
            static __wrap(e) {
              e >>>= 0;
              const t = Object.create(Un.prototype);
              return (t.__wbg_ptr = e), Ln.register(t, t.__wbg_ptr, t), t;
            }
            __destroy_into_raw() {
              const e = this.__wbg_ptr;
              return (this.__wbg_ptr = 0), Ln.unregister(this), e;
            }
            free() {
              const e = this.__destroy_into_raw();
              Mn.__wbg_animationpool_free(e);
            }
            allocateLengthsBuffer(e) {
              return Mn.animationpool_allocateLengthsBuffer(this.__wbg_ptr, e) >>> 0;
            }
            deallocateLengthsBuffer(e, t) {
              Mn.animationpool_deallocateLengthsBuffer(this.__wbg_ptr, e, t);
            }
            createBoneTracks(e, t) {
              return Mn.animationpool_createBoneTracks(this.__wbg_ptr, e, t) >>> 0;
            }
            getBoneTrackFrameNumbers(e, t) {
              return Mn.animationpool_getBoneTrackFrameNumbers(this.__wbg_ptr, e, t) >>> 0;
            }
            getBoneTrackRotations(e, t) {
              return Mn.animationpool_getBoneTrackRotations(this.__wbg_ptr, e, t) >>> 0;
            }
            getBoneTrackRotationInterpolations(e, t) {
              return Mn.animationpool_getBoneTrackRotationInterpolations(this.__wbg_ptr, e, t) >>> 0;
            }
            createMovableBoneTracks(e, t) {
              return Mn.animationpool_createMovableBoneTracks(this.__wbg_ptr, e, t) >>> 0;
            }
            getMovableBoneTrackFrameNumbers(e, t) {
              return Mn.animationpool_getMovableBoneTrackFrameNumbers(this.__wbg_ptr, e, t) >>> 0;
            }
            getMovableBoneTrackPositions(e, t) {
              return Mn.animationpool_getMovableBoneTrackPositions(this.__wbg_ptr, e, t) >>> 0;
            }
            getMovableBoneTrackPositionInterpolations(e, t) {
              return Mn.animationpool_getMovableBoneTrackPositionInterpolations(this.__wbg_ptr, e, t) >>> 0;
            }
            getMovableBoneTrackRotations(e, t) {
              return Mn.animationpool_getMovableBoneTrackRotations(this.__wbg_ptr, e, t) >>> 0;
            }
            getMovableBoneTrackRotationInterpolations(e, t) {
              return Mn.animationpool_getMovableBoneTrackRotationInterpolations(this.__wbg_ptr, e, t) >>> 0;
            }
            createMorphTracks(e, t) {
              return Mn.animationpool_createMorphTracks(this.__wbg_ptr, e, t) >>> 0;
            }
            getMorphTrackFrameNumbers(e, t) {
              return Mn.animationpool_getMorphTrackFrameNumbers(this.__wbg_ptr, e, t) >>> 0;
            }
            getMorphTrackWeights(e, t) {
              return Mn.animationpool_getMorphTrackWeights(this.__wbg_ptr, e, t) >>> 0;
            }
            createAnimation(e, t, n, i, o, r, a, s) {
              return Mn.animationpool_createAnimation(this.__wbg_ptr, e, t, n, i, o, r, a, s) >>> 0;
            }
            getPropertyTrackFrameNumbers(e) {
              return Mn.animationpool_getPropertyTrackFrameNumbers(this.__wbg_ptr, e) >>> 0;
            }
            getPropertyTrackIkStates(e, t) {
              return Mn.animationpool_getPropertyTrackIkStates(this.__wbg_ptr, e, t) >>> 0;
            }
            destroyAnimation(e) {
              Mn.animationpool_destroyAnimation(this.__wbg_ptr, e);
            }
            createBoneBindIndexMap(e) {
              return Mn.animationpool_createBoneBindIndexMap(this.__wbg_ptr, e) >>> 0;
            }
            createMovableBoneBindIndexMap(e) {
              return Mn.animationpool_createMovableBoneBindIndexMap(this.__wbg_ptr, e) >>> 0;
            }
            createMorphBindIndexMap(e, t) {
              return Mn.animationpool_createMorphBindIndexMap(this.__wbg_ptr, e, t) >>> 0;
            }
            getNthMorphBindIndexMap(e, t) {
              return Mn.animationpool_getNthMorphBindIndexMap(this.__wbg_ptr, e, t) >>> 0;
            }
            createIkSolverBindIndexMap(e) {
              return Mn.animationpool_createIkSolverBindIndexMap(this.__wbg_ptr, e) >>> 0;
            }
            createRuntimeAnimation(e, t, n, i, o) {
              return Mn.animationpool_createRuntimeAnimation(this.__wbg_ptr, e, t, n, i, o) >>> 0;
            }
            destroyRuntimeAnimation(e) {
              Mn.animationpool_destroyRuntimeAnimation(this.__wbg_ptr, e);
            }
            animateMmdModel(e, t, n) {
              Mn.animationpool_animateMmdModel(this.__wbg_ptr, e, t, n);
            }
          }
          const Vn =
            "undefined" == typeof FinalizationRegistry
              ? { register: () => {}, unregister: () => {} }
              : new FinalizationRegistry((e) => Mn.__wbg_mmdruntime_free(e >>> 0));
          class Wn {
            static __wrap(e) {
              e >>>= 0;
              const t = Object.create(Wn.prototype);
              return (t.__wbg_ptr = e), Vn.register(t, t.__wbg_ptr, t), t;
            }
            __destroy_into_raw() {
              const e = this.__wbg_ptr;
              return (this.__wbg_ptr = 0), Vn.unregister(this), e;
            }
            free() {
              const e = this.__destroy_into_raw();
              Mn.__wbg_mmdruntime_free(e);
            }
            allocateBuffer(e) {
              return Mn.mmdruntime_allocateBuffer(this.__wbg_ptr, e) >>> 0;
            }
            deallocateBuffer(e, t) {
              Mn.mmdruntime_deallocateBuffer(this.__wbg_ptr, e, t);
            }
            createMmdModel(e, t) {
              return Mn.mmdruntime_createMmdModel(this.__wbg_ptr, e, t) >>> 0;
            }
            destroyMmdModel(e) {
              Mn.mmdruntime_destroyMmdModel(this.__wbg_ptr, e);
            }
            getAnimationArena(e) {
              return Mn.mmdruntime_getAnimationArena(this.__wbg_ptr, e) >>> 0;
            }
            getAnimationIkSolverStateArena(e) {
              return Mn.mmdruntime_getAnimationIkSolverStateArena(this.__wbg_ptr, e) >>> 0;
            }
            getAnimationMorphArena(e) {
              return Mn.mmdruntime_getAnimationMorphArena(this.__wbg_ptr, e) >>> 0;
            }
            getBoneWorldMatrixArena(e) {
              return Mn.mmdruntime_getBoneWorldMatrixArena(this.__wbg_ptr, e) >>> 0;
            }
            createBoneWorldMatrixBackBuffer(e) {
              return Mn.mmdruntime_createBoneWorldMatrixBackBuffer(this.__wbg_ptr, e) >>> 0;
            }
            setRuntimeAnimation(e, t) {
              Mn.mmdruntime_setRuntimeAnimation(this.__wbg_ptr, e, t);
            }
            beforePhysics(e) {
              Mn.mmdruntime_beforePhysics(this.__wbg_ptr, !Fn(e), Fn(e) ? 0 : e);
            }
            afterPhysics() {
              Mn.mmdruntime_afterPhysics(this.__wbg_ptr);
            }
            getLockStatePtr() {
              return Mn.mmdruntime_getLockStatePtr(this.__wbg_ptr) >>> 0;
            }
            swapWorldMatrixBuffer() {
              Mn.mmdruntime_swapWorldMatrixBuffer(this.__wbg_ptr);
            }
            static bufferedBeforePhysics(e, t) {
              Rn(e, Wn), Mn.mmdruntime_bufferedBeforePhysics(e.__wbg_ptr, !Fn(t), Fn(t) ? 0 : t);
            }
            static bufferedUpdate(e, t) {
              Rn(e, Wn), Mn.mmdruntime_bufferedUpdate(e.__wbg_ptr, !Fn(t), Fn(t) ? 0 : t);
            }
            updateBoneWorldMatrix(e, t) {
              Mn.mmdruntime_updateBoneWorldMatrix(this.__wbg_ptr, e, t);
            }
            updateBackBufferBoneWorldMatrix(e, t) {
              Mn.mmdruntime_updateBackBufferBoneWorldMatrix(this.__wbg_ptr, e, t);
            }
            updataBoneLocalMatrices(e) {
              Mn.mmdruntime_updataBoneLocalMatrices(this.__wbg_ptr, e);
            }
          }
          const zn =
            "undefined" == typeof FinalizationRegistry
              ? { register: () => {}, unregister: () => {} }
              : new FinalizationRegistry((e) => Mn.__wbg_wbg_rayon_poolbuilder_free(e >>> 0));
          class Kn {
            static __wrap(e) {
              e >>>= 0;
              const t = Object.create(Kn.prototype);
              return (t.__wbg_ptr = e), zn.register(t, t.__wbg_ptr, t), t;
            }
            __destroy_into_raw() {
              const e = this.__wbg_ptr;
              return (this.__wbg_ptr = 0), zn.unregister(this), e;
            }
            free() {
              const e = this.__destroy_into_raw();
              Mn.__wbg_wbg_rayon_poolbuilder_free(e);
            }
            numThreads() {
              return Mn.wbg_rayon_poolbuilder_numThreads(this.__wbg_ptr) >>> 0;
            }
            receiver() {
              return Mn.wbg_rayon_poolbuilder_receiver(this.__wbg_ptr) >>> 0;
            }
            build() {
              Mn.wbg_rayon_poolbuilder_build(this.__wbg_ptr);
            }
          }
          function jn() {
            const e = { wbg: {} };
            return (
              (e.wbg.__wbindgen_object_drop_ref = function (e) {
                In(e);
              }),
              (e.wbg.__wbg_instanceof_Window_cee7a886d55e7df5 = function (e) {
                let t;
                try {
                  t = wn(e) instanceof Window;
                } catch (e) {
                  t = !1;
                }
                return t;
              }),
              (e.wbg.__wbg_newnoargs_cfecb3965268594c = function (e, t) {
                return vn(new Function(On(e, t)));
              }),
              (e.wbg.__wbg_call_3f093dd26d5569f8 = function () {
                return kn(function (e, t) {
                  return vn(wn(e).call(wn(t)));
                }, arguments);
              }),
              (e.wbg.__wbindgen_object_clone_ref = function (e) {
                return vn(wn(e));
              }),
              (e.wbg.__wbg_self_05040bd9523805b9 = function () {
                return kn(function () {
                  return vn(self.self);
                }, arguments);
              }),
              (e.wbg.__wbg_window_adc720039f2cb14f = function () {
                return kn(function () {
                  return vn(window.window);
                }, arguments);
              }),
              (e.wbg.__wbg_globalThis_622105db80c1457d = function () {
                return kn(function () {
                  return vn(globalThis.globalThis);
                }, arguments);
              }),
              (e.wbg.__wbg_global_f56b013ed9bcf359 = function () {
                return kn(function () {
                  return vn(H.g.global);
                }, arguments);
              }),
              (e.wbg.__wbindgen_is_undefined = function (e) {
                return void 0 === wn(e);
              }),
              (e.wbg.__wbindgen_throw = function (e, t) {
                throw new Error(On(e, t));
              }),
              (e.wbg.__wbindgen_module = function () {
                return vn(Hn.__wbindgen_wasm_module);
              }),
              (e.wbg.__wbindgen_memory = function () {
                return vn(Mn.memory);
              }),
              (e.wbg.__wbg_startWorkers_2ee336a9694dda13 = function (e, t, n) {
                return vn(
                  (async function (e, t, n) {
                    if (0 === n.numThreads()) throw new Error("num_threads must be > 0.");
                    const i = { module: e, memory: t, receiver: n.receiver() };
                    (An = await Promise.all(
                      Array.from({ length: n.numThreads() }, async () => {
                        const e = new Worker(new URL(H.p + H.u(256), H.b), { type: void 0 });
                        return (
                          e.postMessage(i), await new Promise((t) => e.addEventListener("message", t, { once: !0 })), e
                        );
                      })
                    )),
                      n.build();
                  })(In(e), In(t), Kn.__wrap(n))
                );
              }),
              e
            );
          }
          function Yn(e, t) {
            e.wbg.memory = t || new WebAssembly.Memory({ initial: 18, maximum: 16384, shared: !0 });
          }
          function Qn(e, t) {
            return (Mn = e.exports), (Hn.__wbindgen_wasm_module = t), (Pn = null), Mn.__wbindgen_start(), Mn;
          }
          function qn(e, t) {
            if (void 0 !== Mn) return Mn;
            const n = jn();
            return (
              Yn(n, t),
              e instanceof WebAssembly.Module || (e = new WebAssembly.Module(e)),
              Qn(new WebAssembly.Instance(e, n), e)
            );
          }
          async function Hn(e, t) {
            if (void 0 !== Mn) return Mn;
            void 0 === e && (e = new URL(H(2524), H.b));
            const n = jn();
            ("string" == typeof e ||
              ("function" == typeof Request && e instanceof Request) ||
              ("function" == typeof URL && e instanceof URL)) &&
              (e = fetch(e)),
              Yn(n, t);
            const { instance: i, module: o } = await (async function (e, t) {
              if ("function" == typeof Response && e instanceof Response) {
                if ("function" == typeof WebAssembly.instantiateStreaming)
                  try {
                    return await WebAssembly.instantiateStreaming(e, t);
                  } catch (t) {
                    if ("application/wasm" == e.headers.get("Content-Type")) throw t;
                    console.warn(
                      "`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",
                      t
                    );
                  }
                const n = await e.arrayBuffer();
                return await WebAssembly.instantiate(n, t);
              }
              {
                const n = await WebAssembly.instantiate(e, t);
                return n instanceof WebAssembly.Instance ? { instance: n, module: e } : n;
              }
            })(await e, n);
            return Qn(i, o);
          }
          const Gn = Hn;
          class $n {
            getWasmInstanceInner() {
              return t;
            }
          }
          let Xn;
          const Jn = new Array(128).fill(void 0);
          function Zn(e) {
            return Jn[e];
          }
          Jn.push(void 0, null, !0, !1);
          let ei = Jn.length;
          const ti =
            "undefined" != typeof TextDecoder
              ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 })
              : {
                  decode: () => {
                    throw Error("TextDecoder not available");
                  },
                };
          "undefined" != typeof TextDecoder && ti.decode();
          let ni = null;
          function ii() {
            return (null !== ni && 0 !== ni.byteLength) || (ni = new Uint8Array(Xn.memory.buffer)), ni;
          }
          function oi(e, t) {
            return (e >>>= 0), ti.decode(ii().subarray(e, e + t));
          }
          function ri() {
            Xn.init();
          }
          function ai() {
            const e = Xn.createMmdRuntime();
            return yi.__wrap(e);
          }
          function si() {
            const e = Xn.createAnimationPool();
            return _i.__wrap(e);
          }
          function li(e) {
            if ("number" != typeof e) throw new Error("expected a number argument, found " + typeof e);
          }
          function hi(e) {
            return null == e;
          }
          function di(e, t) {
            try {
              return e.apply(this, t);
            } catch (e) {
              let t = (function () {
                try {
                  return e instanceof Error ? `${e.message}\n\nStack:\n${e.stack}` : e.toString();
                } catch (e) {
                  return "<failed to stringify thrown value>";
                }
              })();
              throw (
                (console.error("wasm-bindgen: imported JS function that was not marked as `catch` threw an error:", t),
                e)
              );
            }
          }
          let ci = 0;
          const mi =
              "undefined" != typeof TextEncoder
                ? new TextEncoder("utf-8")
                : {
                    encode: () => {
                      throw Error("TextEncoder not available");
                    },
                  },
            ui =
              "function" == typeof mi.encodeInto
                ? function (e, t) {
                    return mi.encodeInto(e, t);
                  }
                : function (e, t) {
                    const n = mi.encode(e);
                    return t.set(n), { read: e.length, written: n.length };
                  };
          let pi = null;
          function gi() {
            return (null !== pi && 0 !== pi.byteLength) || (pi = new Int32Array(Xn.memory.buffer)), pi;
          }
          const fi =
            "undefined" == typeof FinalizationRegistry
              ? { register: () => {}, unregister: () => {} }
              : new FinalizationRegistry((e) => Xn.__wbg_animationpool_free(e >>> 0));
          class _i {
            constructor() {
              throw new Error("cannot invoke `new` directly");
            }
            static __wrap(e) {
              e >>>= 0;
              const t = Object.create(_i.prototype);
              return (t.__wbg_ptr = e), fi.register(t, t.__wbg_ptr, t), t;
            }
            __destroy_into_raw() {
              const e = this.__wbg_ptr;
              return (this.__wbg_ptr = 0), fi.unregister(this), e;
            }
            free() {
              const e = this.__destroy_into_raw();
              Xn.__wbg_animationpool_free(e);
            }
            allocateLengthsBuffer(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return li(this.__wbg_ptr), li(e), Xn.animationpool_allocateLengthsBuffer(this.__wbg_ptr, e) >>> 0;
            }
            deallocateLengthsBuffer(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              li(this.__wbg_ptr), li(e), li(t), Xn.animationpool_deallocateLengthsBuffer(this.__wbg_ptr, e, t);
            }
            createBoneTracks(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return li(this.__wbg_ptr), li(e), li(t), Xn.animationpool_createBoneTracks(this.__wbg_ptr, e, t) >>> 0;
            }
            getBoneTrackFrameNumbers(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                li(this.__wbg_ptr), li(e), li(t), Xn.animationpool_getBoneTrackFrameNumbers(this.__wbg_ptr, e, t) >>> 0
              );
            }
            getBoneTrackRotations(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                li(this.__wbg_ptr), li(e), li(t), Xn.animationpool_getBoneTrackRotations(this.__wbg_ptr, e, t) >>> 0
              );
            }
            getBoneTrackRotationInterpolations(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                li(this.__wbg_ptr),
                li(e),
                li(t),
                Xn.animationpool_getBoneTrackRotationInterpolations(this.__wbg_ptr, e, t) >>> 0
              );
            }
            createMovableBoneTracks(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                li(this.__wbg_ptr), li(e), li(t), Xn.animationpool_createMovableBoneTracks(this.__wbg_ptr, e, t) >>> 0
              );
            }
            getMovableBoneTrackFrameNumbers(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                li(this.__wbg_ptr),
                li(e),
                li(t),
                Xn.animationpool_getMovableBoneTrackFrameNumbers(this.__wbg_ptr, e, t) >>> 0
              );
            }
            getMovableBoneTrackPositions(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                li(this.__wbg_ptr),
                li(e),
                li(t),
                Xn.animationpool_getMovableBoneTrackPositions(this.__wbg_ptr, e, t) >>> 0
              );
            }
            getMovableBoneTrackPositionInterpolations(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                li(this.__wbg_ptr),
                li(e),
                li(t),
                Xn.animationpool_getMovableBoneTrackPositionInterpolations(this.__wbg_ptr, e, t) >>> 0
              );
            }
            getMovableBoneTrackRotations(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                li(this.__wbg_ptr),
                li(e),
                li(t),
                Xn.animationpool_getMovableBoneTrackRotations(this.__wbg_ptr, e, t) >>> 0
              );
            }
            getMovableBoneTrackRotationInterpolations(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                li(this.__wbg_ptr),
                li(e),
                li(t),
                Xn.animationpool_getMovableBoneTrackRotationInterpolations(this.__wbg_ptr, e, t) >>> 0
              );
            }
            createMorphTracks(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return li(this.__wbg_ptr), li(e), li(t), Xn.animationpool_createMorphTracks(this.__wbg_ptr, e, t) >>> 0;
            }
            getMorphTrackFrameNumbers(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                li(this.__wbg_ptr), li(e), li(t), Xn.animationpool_getMorphTrackFrameNumbers(this.__wbg_ptr, e, t) >>> 0
              );
            }
            getMorphTrackWeights(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                li(this.__wbg_ptr), li(e), li(t), Xn.animationpool_getMorphTrackWeights(this.__wbg_ptr, e, t) >>> 0
              );
            }
            createAnimation(e, t, n, i, o, r, a, s) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                li(this.__wbg_ptr),
                li(e),
                li(t),
                li(n),
                li(i),
                li(o),
                li(r),
                li(a),
                li(s),
                Xn.animationpool_createAnimation(this.__wbg_ptr, e, t, n, i, o, r, a, s) >>> 0
              );
            }
            getPropertyTrackFrameNumbers(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return li(this.__wbg_ptr), li(e), Xn.animationpool_getPropertyTrackFrameNumbers(this.__wbg_ptr, e) >>> 0;
            }
            getPropertyTrackIkStates(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                li(this.__wbg_ptr), li(e), li(t), Xn.animationpool_getPropertyTrackIkStates(this.__wbg_ptr, e, t) >>> 0
              );
            }
            destroyAnimation(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              li(this.__wbg_ptr), li(e), Xn.animationpool_destroyAnimation(this.__wbg_ptr, e);
            }
            createBoneBindIndexMap(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return li(this.__wbg_ptr), li(e), Xn.animationpool_createBoneBindIndexMap(this.__wbg_ptr, e) >>> 0;
            }
            createMovableBoneBindIndexMap(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return li(this.__wbg_ptr), li(e), Xn.animationpool_createMovableBoneBindIndexMap(this.__wbg_ptr, e) >>> 0;
            }
            createMorphBindIndexMap(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                li(this.__wbg_ptr), li(e), li(t), Xn.animationpool_createMorphBindIndexMap(this.__wbg_ptr, e, t) >>> 0
              );
            }
            getNthMorphBindIndexMap(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                li(this.__wbg_ptr), li(e), li(t), Xn.animationpool_getNthMorphBindIndexMap(this.__wbg_ptr, e, t) >>> 0
              );
            }
            createIkSolverBindIndexMap(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return li(this.__wbg_ptr), li(e), Xn.animationpool_createIkSolverBindIndexMap(this.__wbg_ptr, e) >>> 0;
            }
            createRuntimeAnimation(e, t, n, i, o) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return (
                li(this.__wbg_ptr),
                li(e),
                li(t),
                li(n),
                li(i),
                li(o),
                Xn.animationpool_createRuntimeAnimation(this.__wbg_ptr, e, t, n, i, o) >>> 0
              );
            }
            destroyRuntimeAnimation(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              li(this.__wbg_ptr), li(e), Xn.animationpool_destroyRuntimeAnimation(this.__wbg_ptr, e);
            }
            animateMmdModel(e, t, n) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              li(this.__wbg_ptr), li(e), li(t), Xn.animationpool_animateMmdModel(this.__wbg_ptr, e, t, n);
            }
          }
          const bi =
            "undefined" == typeof FinalizationRegistry
              ? { register: () => {}, unregister: () => {} }
              : new FinalizationRegistry((e) => Xn.__wbg_mmdruntime_free(e >>> 0));
          class yi {
            constructor() {
              throw new Error("cannot invoke `new` directly");
            }
            static __wrap(e) {
              e >>>= 0;
              const t = Object.create(yi.prototype);
              return (t.__wbg_ptr = e), bi.register(t, t.__wbg_ptr, t), t;
            }
            __destroy_into_raw() {
              const e = this.__wbg_ptr;
              return (this.__wbg_ptr = 0), bi.unregister(this), e;
            }
            free() {
              const e = this.__destroy_into_raw();
              Xn.__wbg_mmdruntime_free(e);
            }
            allocateBuffer(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return li(this.__wbg_ptr), li(e), Xn.mmdruntime_allocateBuffer(this.__wbg_ptr, e) >>> 0;
            }
            deallocateBuffer(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              li(this.__wbg_ptr), li(e), li(t), Xn.mmdruntime_deallocateBuffer(this.__wbg_ptr, e, t);
            }
            createMmdModel(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return li(this.__wbg_ptr), li(e), li(t), Xn.mmdruntime_createMmdModel(this.__wbg_ptr, e, t) >>> 0;
            }
            destroyMmdModel(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              li(this.__wbg_ptr), li(e), Xn.mmdruntime_destroyMmdModel(this.__wbg_ptr, e);
            }
            getAnimationArena(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return li(this.__wbg_ptr), li(e), Xn.mmdruntime_getAnimationArena(this.__wbg_ptr, e) >>> 0;
            }
            getAnimationIkSolverStateArena(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return li(this.__wbg_ptr), li(e), Xn.mmdruntime_getAnimationIkSolverStateArena(this.__wbg_ptr, e) >>> 0;
            }
            getAnimationMorphArena(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return li(this.__wbg_ptr), li(e), Xn.mmdruntime_getAnimationMorphArena(this.__wbg_ptr, e) >>> 0;
            }
            getBoneWorldMatrixArena(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return li(this.__wbg_ptr), li(e), Xn.mmdruntime_getBoneWorldMatrixArena(this.__wbg_ptr, e) >>> 0;
            }
            createBoneWorldMatrixBackBuffer(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return li(this.__wbg_ptr), li(e), Xn.mmdruntime_createBoneWorldMatrixBackBuffer(this.__wbg_ptr, e) >>> 0;
            }
            setRuntimeAnimation(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              li(this.__wbg_ptr), li(e), li(t), Xn.mmdruntime_setRuntimeAnimation(this.__wbg_ptr, e, t);
            }
            beforePhysics(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              li(this.__wbg_ptr), hi(e) || li(e), Xn.mmdruntime_beforePhysics(this.__wbg_ptr, !hi(e), hi(e) ? 0 : e);
            }
            afterPhysics() {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              li(this.__wbg_ptr), Xn.mmdruntime_afterPhysics(this.__wbg_ptr);
            }
            getLockStatePtr() {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              return li(this.__wbg_ptr), Xn.mmdruntime_getLockStatePtr(this.__wbg_ptr) >>> 0;
            }
            swapWorldMatrixBuffer() {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              li(this.__wbg_ptr), Xn.mmdruntime_swapWorldMatrixBuffer(this.__wbg_ptr);
            }
            updateBoneWorldMatrix(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              li(this.__wbg_ptr), li(e), li(t), Xn.mmdruntime_updateBoneWorldMatrix(this.__wbg_ptr, e, t);
            }
            updateBackBufferBoneWorldMatrix(e, t) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              li(this.__wbg_ptr), li(e), li(t), Xn.mmdruntime_updateBackBufferBoneWorldMatrix(this.__wbg_ptr, e, t);
            }
            updataBoneLocalMatrices(e) {
              if (0 == this.__wbg_ptr) throw new Error("Attempt to use a moved value");
              li(this.__wbg_ptr), li(e), Xn.mmdruntime_updataBoneLocalMatrices(this.__wbg_ptr, e);
            }
          }
          function Ai() {
            const e = { wbg: {} };
            return (
              (e.wbg.__wbindgen_object_drop_ref = function (e) {
                !(function (e) {
                  const t = Zn(e);
                  (function (e) {
                    e < 132 || ((Jn[e] = ei), (ei = e));
                  })(e);
                })(e);
              }),
              (e.wbg.__wbg_new_abda76e883ba8a5f = function () {
                return di(function () {
                  return (function (e) {
                    ei === Jn.length && Jn.push(Jn.length + 1);
                    const t = ei;
                    if (((ei = Jn[t]), "number" != typeof ei)) throw new Error("corrupt heap");
                    return (Jn[t] = e), t;
                  })(new Error());
                }, arguments);
              }),
              (e.wbg.__wbg_stack_658279fe44541cf6 = function () {
                return di(function (e, t) {
                  const n = (function (e, t, n) {
                      if ("string" != typeof e) throw new Error("expected a string argument, found " + typeof e);
                      if (void 0 === n) {
                        const n = mi.encode(e),
                          i = t(n.length, 1) >>> 0;
                        return (
                          ii()
                            .subarray(i, i + n.length)
                            .set(n),
                          (ci = n.length),
                          i
                        );
                      }
                      let i = e.length,
                        o = t(i, 1) >>> 0;
                      const r = ii();
                      let a = 0;
                      for (; a < i; a++) {
                        const t = e.charCodeAt(a);
                        if (t > 127) break;
                        r[o + a] = t;
                      }
                      if (a !== i) {
                        0 !== a && (e = e.slice(a)), (o = n(o, i, (i = a + 3 * e.length), 1) >>> 0);
                        const t = ii().subarray(o + a, o + i),
                          r = ui(e, t);
                        if (r.read !== e.length) throw new Error("failed to pass whole string");
                        (a += r.written), (o = n(o, i, a, 1) >>> 0);
                      }
                      return (ci = a), o;
                    })(Zn(t).stack, Xn.__wbindgen_malloc, Xn.__wbindgen_realloc),
                    i = ci;
                  (gi()[e / 4 + 1] = i), (gi()[e / 4 + 0] = n);
                }, arguments);
              }),
              (e.wbg.__wbg_error_f851667af71bcfc6 = function () {
                return di(function (e, t) {
                  let n, i;
                  try {
                    (n = e), (i = t), console.error(oi(e, t));
                  } finally {
                    Xn.__wbindgen_free(n, i, 1);
                  }
                }, arguments);
              }),
              (e.wbg.__wbindgen_throw = function (e, t) {
                throw new Error(oi(e, t));
              }),
              e
            );
          }
          function Mi(e, t) {
            return (Xn = e.exports), (wi.__wbindgen_wasm_module = t), (pi = null), (ni = null), Xn;
          }
          function Ti(e) {
            if (void 0 !== Xn) return Xn;
            const t = Ai();
            return (
              e instanceof WebAssembly.Module || (e = new WebAssembly.Module(e)), Mi(new WebAssembly.Instance(e, t), e)
            );
          }
          async function wi(e) {
            if (void 0 !== Xn) return Xn;
            void 0 === e && (e = new URL(H(7236), H.b));
            const t = Ai();
            ("string" == typeof e ||
              ("function" == typeof Request && e instanceof Request) ||
              ("function" == typeof URL && e instanceof URL)) &&
              (e = fetch(e));
            const { instance: n, module: i } = await (async function (e, t) {
              if ("function" == typeof Response && e instanceof Response) {
                if ("function" == typeof WebAssembly.instantiateStreaming)
                  try {
                    return await WebAssembly.instantiateStreaming(e, t);
                  } catch (t) {
                    if ("application/wasm" == e.headers.get("Content-Type")) throw t;
                    console.warn(
                      "`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",
                      t
                    );
                  }
                const n = await e.arrayBuffer();
                return await WebAssembly.instantiate(n, t);
              }
              {
                const n = await WebAssembly.instantiate(e, t);
                return n instanceof WebAssembly.Instance ? { instance: n, module: e } : n;
              }
            })(await e, t);
            return Mi(n, i);
          }
          const xi = wi;
          class Ii {
            getWasmInstanceInner() {
              return n;
            }
          }
          let vi;
          const Bi =
            "undefined" != typeof TextDecoder
              ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 })
              : {
                  decode: () => {
                    throw Error("TextDecoder not available");
                  },
                };
          "undefined" != typeof TextDecoder && Bi.decode();
          let Pi = null;
          function Oi(e) {
            return null == e;
          }
          function Fi() {
            vi.init();
          }
          function Ri() {
            const e = vi.createMmdRuntime();
            return Ni.__wrap(e);
          }
          function Si() {
            const e = vi.createAnimationPool();
            return Ei.__wrap(e);
          }
          const Ci =
            "undefined" == typeof FinalizationRegistry
              ? { register: () => {}, unregister: () => {} }
              : new FinalizationRegistry((e) => vi.__wbg_animationpool_free(e >>> 0));
          class Ei {
            static __wrap(e) {
              e >>>= 0;
              const t = Object.create(Ei.prototype);
              return (t.__wbg_ptr = e), Ci.register(t, t.__wbg_ptr, t), t;
            }
            __destroy_into_raw() {
              const e = this.__wbg_ptr;
              return (this.__wbg_ptr = 0), Ci.unregister(this), e;
            }
            free() {
              const e = this.__destroy_into_raw();
              vi.__wbg_animationpool_free(e);
            }
            allocateLengthsBuffer(e) {
              return vi.animationpool_allocateLengthsBuffer(this.__wbg_ptr, e) >>> 0;
            }
            deallocateLengthsBuffer(e, t) {
              vi.animationpool_deallocateLengthsBuffer(this.__wbg_ptr, e, t);
            }
            createBoneTracks(e, t) {
              return vi.animationpool_createBoneTracks(this.__wbg_ptr, e, t) >>> 0;
            }
            getBoneTrackFrameNumbers(e, t) {
              return vi.animationpool_getBoneTrackFrameNumbers(this.__wbg_ptr, e, t) >>> 0;
            }
            getBoneTrackRotations(e, t) {
              return vi.animationpool_getBoneTrackRotations(this.__wbg_ptr, e, t) >>> 0;
            }
            getBoneTrackRotationInterpolations(e, t) {
              return vi.animationpool_getBoneTrackRotationInterpolations(this.__wbg_ptr, e, t) >>> 0;
            }
            createMovableBoneTracks(e, t) {
              return vi.animationpool_createMovableBoneTracks(this.__wbg_ptr, e, t) >>> 0;
            }
            getMovableBoneTrackFrameNumbers(e, t) {
              return vi.animationpool_getMovableBoneTrackFrameNumbers(this.__wbg_ptr, e, t) >>> 0;
            }
            getMovableBoneTrackPositions(e, t) {
              return vi.animationpool_getMovableBoneTrackPositions(this.__wbg_ptr, e, t) >>> 0;
            }
            getMovableBoneTrackPositionInterpolations(e, t) {
              return vi.animationpool_getMovableBoneTrackPositionInterpolations(this.__wbg_ptr, e, t) >>> 0;
            }
            getMovableBoneTrackRotations(e, t) {
              return vi.animationpool_getMovableBoneTrackRotations(this.__wbg_ptr, e, t) >>> 0;
            }
            getMovableBoneTrackRotationInterpolations(e, t) {
              return vi.animationpool_getMovableBoneTrackRotationInterpolations(this.__wbg_ptr, e, t) >>> 0;
            }
            createMorphTracks(e, t) {
              return vi.animationpool_createMorphTracks(this.__wbg_ptr, e, t) >>> 0;
            }
            getMorphTrackFrameNumbers(e, t) {
              return vi.animationpool_getMorphTrackFrameNumbers(this.__wbg_ptr, e, t) >>> 0;
            }
            getMorphTrackWeights(e, t) {
              return vi.animationpool_getMorphTrackWeights(this.__wbg_ptr, e, t) >>> 0;
            }
            createAnimation(e, t, n, i, o, r, a, s) {
              return vi.animationpool_createAnimation(this.__wbg_ptr, e, t, n, i, o, r, a, s) >>> 0;
            }
            getPropertyTrackFrameNumbers(e) {
              return vi.animationpool_getPropertyTrackFrameNumbers(this.__wbg_ptr, e) >>> 0;
            }
            getPropertyTrackIkStates(e, t) {
              return vi.animationpool_getPropertyTrackIkStates(this.__wbg_ptr, e, t) >>> 0;
            }
            destroyAnimation(e) {
              vi.animationpool_destroyAnimation(this.__wbg_ptr, e);
            }
            createBoneBindIndexMap(e) {
              return vi.animationpool_createBoneBindIndexMap(this.__wbg_ptr, e) >>> 0;
            }
            createMovableBoneBindIndexMap(e) {
              return vi.animationpool_createMovableBoneBindIndexMap(this.__wbg_ptr, e) >>> 0;
            }
            createMorphBindIndexMap(e, t) {
              return vi.animationpool_createMorphBindIndexMap(this.__wbg_ptr, e, t) >>> 0;
            }
            getNthMorphBindIndexMap(e, t) {
              return vi.animationpool_getNthMorphBindIndexMap(this.__wbg_ptr, e, t) >>> 0;
            }
            createIkSolverBindIndexMap(e) {
              return vi.animationpool_createIkSolverBindIndexMap(this.__wbg_ptr, e) >>> 0;
            }
            createRuntimeAnimation(e, t, n, i, o) {
              return vi.animationpool_createRuntimeAnimation(this.__wbg_ptr, e, t, n, i, o) >>> 0;
            }
            destroyRuntimeAnimation(e) {
              vi.animationpool_destroyRuntimeAnimation(this.__wbg_ptr, e);
            }
            animateMmdModel(e, t, n) {
              vi.animationpool_animateMmdModel(this.__wbg_ptr, e, t, n);
            }
          }
          const ki =
            "undefined" == typeof FinalizationRegistry
              ? { register: () => {}, unregister: () => {} }
              : new FinalizationRegistry((e) => vi.__wbg_mmdruntime_free(e >>> 0));
          class Ni {
            static __wrap(e) {
              e >>>= 0;
              const t = Object.create(Ni.prototype);
              return (t.__wbg_ptr = e), ki.register(t, t.__wbg_ptr, t), t;
            }
            __destroy_into_raw() {
              const e = this.__wbg_ptr;
              return (this.__wbg_ptr = 0), ki.unregister(this), e;
            }
            free() {
              const e = this.__destroy_into_raw();
              vi.__wbg_mmdruntime_free(e);
            }
            allocateBuffer(e) {
              return vi.mmdruntime_allocateBuffer(this.__wbg_ptr, e) >>> 0;
            }
            deallocateBuffer(e, t) {
              vi.mmdruntime_deallocateBuffer(this.__wbg_ptr, e, t);
            }
            createMmdModel(e, t) {
              return vi.mmdruntime_createMmdModel(this.__wbg_ptr, e, t) >>> 0;
            }
            destroyMmdModel(e) {
              vi.mmdruntime_destroyMmdModel(this.__wbg_ptr, e);
            }
            getAnimationArena(e) {
              return vi.mmdruntime_getAnimationArena(this.__wbg_ptr, e) >>> 0;
            }
            getAnimationIkSolverStateArena(e) {
              return vi.mmdruntime_getAnimationIkSolverStateArena(this.__wbg_ptr, e) >>> 0;
            }
            getAnimationMorphArena(e) {
              return vi.mmdruntime_getAnimationMorphArena(this.__wbg_ptr, e) >>> 0;
            }
            getBoneWorldMatrixArena(e) {
              return vi.mmdruntime_getBoneWorldMatrixArena(this.__wbg_ptr, e) >>> 0;
            }
            createBoneWorldMatrixBackBuffer(e) {
              return vi.mmdruntime_createBoneWorldMatrixBackBuffer(this.__wbg_ptr, e) >>> 0;
            }
            setRuntimeAnimation(e, t) {
              vi.mmdruntime_setRuntimeAnimation(this.__wbg_ptr, e, t);
            }
            beforePhysics(e) {
              vi.mmdruntime_beforePhysics(this.__wbg_ptr, !Oi(e), Oi(e) ? 0 : e);
            }
            afterPhysics() {
              vi.mmdruntime_afterPhysics(this.__wbg_ptr);
            }
            getLockStatePtr() {
              return vi.mmdruntime_getLockStatePtr(this.__wbg_ptr) >>> 0;
            }
            swapWorldMatrixBuffer() {
              vi.mmdruntime_swapWorldMatrixBuffer(this.__wbg_ptr);
            }
            updateBoneWorldMatrix(e, t) {
              vi.mmdruntime_updateBoneWorldMatrix(this.__wbg_ptr, e, t);
            }
            updateBackBufferBoneWorldMatrix(e, t) {
              vi.mmdruntime_updateBackBufferBoneWorldMatrix(this.__wbg_ptr, e, t);
            }
            updataBoneLocalMatrices(e) {
              vi.mmdruntime_updataBoneLocalMatrices(this.__wbg_ptr, e);
            }
          }
          function Di() {
            const e = { wbg: {} };
            return (
              (e.wbg.__wbindgen_throw = function (e, t) {
                throw new Error(
                  ((n = e),
                  (i = t),
                  (n >>>= 0),
                  Bi.decode(
                    ((null !== Pi && 0 !== Pi.byteLength) || (Pi = new Uint8Array(vi.memory.buffer)), Pi).subarray(
                      n,
                      n + i
                    )
                  ))
                );
                var n, i;
              }),
              e
            );
          }
          function Li(e, t) {
            return (vi = e.exports), (Vi.__wbindgen_wasm_module = t), (Pi = null), vi;
          }
          function Ui(e) {
            if (void 0 !== vi) return vi;
            const t = Di();
            return (
              e instanceof WebAssembly.Module || (e = new WebAssembly.Module(e)), Li(new WebAssembly.Instance(e, t), e)
            );
          }
          async function Vi(e) {
            if (void 0 !== vi) return vi;
            void 0 === e && (e = new URL(H(8754), H.b));
            const t = Di();
            ("string" == typeof e ||
              ("function" == typeof Request && e instanceof Request) ||
              ("function" == typeof URL && e instanceof URL)) &&
              (e = fetch(e));
            const { instance: n, module: i } = await (async function (e, t) {
              if ("function" == typeof Response && e instanceof Response) {
                if ("function" == typeof WebAssembly.instantiateStreaming)
                  try {
                    return await WebAssembly.instantiateStreaming(e, t);
                  } catch (t) {
                    if ("application/wasm" == e.headers.get("Content-Type")) throw t;
                    console.warn(
                      "`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",
                      t
                    );
                  }
                const n = await e.arrayBuffer();
                return await WebAssembly.instantiate(n, t);
              }
              {
                const n = await WebAssembly.instantiate(e, t);
                return n instanceof WebAssembly.Instance ? { instance: n, module: e } : n;
              }
            })(await e, t);
            return Li(n, i);
          }
          const Wi = Vi;
          class zi {
            getWasmInstanceInner() {
              return i;
            }
          }
          class Ki {
            array;
            constructor(e, t, n, i) {
              this.array = new e(t.buffer, n, i);
            }
          }
          class ji {
            _memory;
            _byteOffset;
            _length;
            _array;
            constructor(e, t, n, i) {
              (this._memory = t), (this._byteOffset = n), (this._length = i), (this._array = new e(t.buffer, n, i));
            }
            get array() {
              return (
                this._array.length !== this._length &&
                  (this._array = new this._array.constructor(this._memory.buffer, this._byteOffset, this._length)),
                this._array
              );
            }
          }
          const Yi = new WeakMap();
          async function Qi(e, t = navigator.hardwareConcurrency) {
            const n = e.getWasmInstanceInner();
            {
              const e = Yi.get(n);
              if (void 0 !== e) return e;
            }
            let i = null;
            Yi.set(n, new Promise((e) => (i = e)));
            const o = await n.default();
            n.init();
            const r = o.memory;
            return (
              (n.memory = r),
              r.buffer instanceof ArrayBuffer
                ? (n.createTypedArray = function (e, t, n) {
                    return new ji(e, r, t, n);
                  })
                : (n.createTypedArray = function (e, t, n) {
                    return new Ki(e, r, t, n);
                  }),
              await n.initThreadPool?.(t),
              i(n),
              n
            );
          }
          class qi {
            _logger;
            _runtimeBones;
            _materials;
            _morphs;
            _morphIndexMap;
            _morphWeights;
            _activeMorphs;
            morphTargetManagers;
            constructor(e, t, n, i, o, r) {
              if (((this._logger = r), (this._runtimeBones = e ?? []), null !== n)) {
                const e = (this._materials = new Array(t.length));
                for (let i = 0; i < t.length; ++i) e[i] = new n(t[i]);
              } else this._materials = [];
              const a = (this._morphs = this._createRuntimeMorphData(i, null !== e, null !== n)),
                s = (this._morphIndexMap = new Map());
              for (let e = 0; e < a.length; ++e) {
                const t = a[e];
                let n = s.get(t.name);
                void 0 === n && ((n = []), s.set(t.name, n)), n.push(e);
              }
              (this._morphWeights = new Float32Array(a.length)),
                (this._activeMorphs = new Set()),
                (this.morphTargetManagers = o);
            }
            getMorphWeight(e) {
              const t = this._morphIndexMap.get(e);
              return void 0 === t ? 0 : this._morphWeights[t[0]];
            }
            getMorphIndices(e) {
              return this._morphIndexMap.get(e);
            }
            getMorphWeightFromIndex(e) {
              return this._morphWeights[e];
            }
            getMorphWeights() {
              return this._morphWeights;
            }
            resetMorphWeights() {
              this._morphWeights.fill(0);
            }
            _updatedMaterials = new Set();
            update() {
              const e = this._morphs,
                t = this._morphIndexMap,
                n = this._morphWeights,
                i = this._activeMorphs,
                o = this.morphTargetManagers;
              for (let e = 0; e < o.length; ++e) o[e].areUpdatesFrozen = !0;
              for (const n of i) {
                const i = t.get(n);
                for (let t = 0; t < i.length; ++t) this._resetMorph(e[i[t]]);
              }
              for (const o of i) {
                const r = t.get(o);
                for (let t = 0; t < r.length; ++t) {
                  const a = r[t],
                    s = n[a];
                  this._applyMorph(e[a], s), 0 === s && i.delete(o);
                }
              }
              for (let e = 0; e < o.length; ++e) o[e].areUpdatesFrozen = !1;
              const r = this._updatedMaterials;
              for (const e of r) e.applyChanges();
              r.clear();
            }
            get morphs() {
              return this._morphs;
            }
            _createRuntimeMorphData(e, t, n) {
              const i = [];
              for (let o = 0; o < e.length; ++o) {
                const r = e[o];
                let a = null,
                  s = null,
                  l = null,
                  h = null;
                switch (r.type) {
                  case y.Morph.Type.GroupMorph:
                    (s = r.indices), (l = r.ratios);
                    break;
                  case y.Morph.Type.BoneMorph:
                    t
                      ? ((s = r.indices), (l = r.positions), (h = r.rotations))
                      : ((s = new Int32Array(0)), (l = new Float32Array(0)), (h = new Float32Array(0)));
                    break;
                  case y.Morph.Type.MaterialMorph:
                    if (n) {
                      const e = r.elements,
                        t = new Array(e.length);
                      for (let n = 0; n < e.length; ++n) {
                        const i = e[n];
                        i.type === y.Morph.MaterialMorph.Type.Multiply
                          ? (t[n] = {
                              index: i.index,
                              type: i.type,
                              diffuse:
                                1 !== i.diffuse[0] || 1 !== i.diffuse[1] || 1 !== i.diffuse[2] || 1 !== i.diffuse[3]
                                  ? i.diffuse
                                  : null,
                              specular:
                                1 !== i.specular[0] || 1 !== i.specular[1] || 1 !== i.specular[2] ? i.specular : null,
                              shininess: 1 !== i.shininess ? i.shininess : null,
                              ambient:
                                1 !== i.ambient[0] || 1 !== i.ambient[1] || 1 !== i.ambient[2] ? i.ambient : null,
                              edgeColor:
                                1 !== i.edgeColor[0] ||
                                1 !== i.edgeColor[1] ||
                                1 !== i.edgeColor[2] ||
                                1 !== i.edgeColor[3]
                                  ? i.edgeColor
                                  : null,
                              edgeSize: 1 !== i.edgeSize ? i.edgeSize : null,
                              textureColor:
                                1 !== i.textureColor[0] ||
                                1 !== i.textureColor[1] ||
                                1 !== i.textureColor[2] ||
                                1 !== i.textureColor[3]
                                  ? i.textureColor
                                  : null,
                              sphereTextureColor:
                                1 !== i.sphereTextureColor[0] ||
                                1 !== i.sphereTextureColor[1] ||
                                1 !== i.sphereTextureColor[2] ||
                                1 !== i.sphereTextureColor[3]
                                  ? i.sphereTextureColor
                                  : null,
                              toonTextureColor:
                                1 !== i.toonTextureColor[0] ||
                                1 !== i.toonTextureColor[1] ||
                                1 !== i.toonTextureColor[2] ||
                                1 !== i.toonTextureColor[3]
                                  ? i.toonTextureColor
                                  : null,
                            })
                          : (t[n] = {
                              index: i.index,
                              type: i.type,
                              diffuse:
                                0 !== i.diffuse[0] || 0 !== i.diffuse[1] || 0 !== i.diffuse[2] || 0 !== i.diffuse[3]
                                  ? i.diffuse
                                  : null,
                              specular:
                                0 !== i.specular[0] || 0 !== i.specular[1] || 0 !== i.specular[2] ? i.specular : null,
                              shininess: 0 !== i.shininess ? i.shininess : null,
                              ambient:
                                0 !== i.ambient[0] || 0 !== i.ambient[1] || 0 !== i.ambient[2] ? i.ambient : null,
                              edgeColor:
                                0 !== i.edgeColor[0] ||
                                0 !== i.edgeColor[1] ||
                                0 !== i.edgeColor[2] ||
                                0 !== i.edgeColor[3]
                                  ? i.edgeColor
                                  : null,
                              edgeSize: 0 !== i.edgeSize ? i.edgeSize : null,
                              textureColor:
                                0 !== i.textureColor[0] ||
                                0 !== i.textureColor[1] ||
                                0 !== i.textureColor[2] ||
                                0 !== i.textureColor[3]
                                  ? i.textureColor
                                  : null,
                              sphereTextureColor:
                                0 !== i.sphereTextureColor[0] ||
                                0 !== i.sphereTextureColor[1] ||
                                0 !== i.sphereTextureColor[2] ||
                                0 !== i.sphereTextureColor[3]
                                  ? i.sphereTextureColor
                                  : null,
                              toonTextureColor:
                                0 !== i.toonTextureColor[0] ||
                                0 !== i.toonTextureColor[1] ||
                                0 !== i.toonTextureColor[2] ||
                                0 !== i.toonTextureColor[3]
                                  ? i.toonTextureColor
                                  : null,
                            });
                      }
                      a = t;
                    } else a = [];
                    break;
                  case y.Morph.Type.UvMorph:
                  case y.Morph.Type.AdditionalUvMorph1:
                  case y.Morph.Type.AdditionalUvMorph2:
                  case y.Morph.Type.AdditionalUvMorph3:
                  case y.Morph.Type.AdditionalUvMorph4:
                  case y.Morph.Type.VertexMorph:
                    s = r.morphTargets;
                }
                const d = { name: r.name, type: r.type, materialElements: a, elements: s, elements2: l, elements3: h };
                i.push(d);
              }
              {
                const e = [],
                  t = (n) => {
                    const o = i[n];
                    if (o.type !== y.Morph.Type.GroupMorph) return;
                    const r = o.elements;
                    for (let a = 0; a < r.length; ++a) {
                      const s = r[a];
                      e.includes(s)
                        ? (this._logger.warn(`Looping group morph detected resolves to -1: ${o.name} -> ${i[s].name}`),
                          (r[a] = -1))
                        : 0 <= s && s < i.length && (e.push(n), t(s), e.pop());
                    }
                  };
                for (let n = 0; n < i.length; ++n) e.push(n), t(n), (e.length = 0);
              }
              return i;
            }
            groupMorphFlatForeach(e, t) {
              this._groupMorphFlatForeach(e, t);
            }
            _groupMorphFlatForeach(e, t, n = 1) {
              const i = this._morphs,
                o = e.elements,
                r = e.elements2;
              for (let e = 0; e < o.length; ++e) {
                const a = o[e],
                  s = r[e],
                  l = i[a];
                l.type === y.Morph.Type.GroupMorph ? this._groupMorphFlatForeach(l, t, s * n) : t(a, s * n);
              }
            }
            _resetMorph(e) {
              switch (e.type) {
                case y.Morph.Type.GroupMorph:
                  {
                    const t = this._morphs;
                    this._groupMorphFlatForeach(e, (e, n) => {
                      const i = t[e];
                      void 0 !== i && this._resetMorph(i);
                    });
                  }
                  break;
                case y.Morph.Type.BoneMorph:
                  this._resetBoneMorph(e);
                  break;
                case y.Morph.Type.MaterialMorph:
                  {
                    const t = e.materialElements;
                    for (let e = 0; e < t.length; ++e) {
                      const n = t[e],
                        i = this._materials;
                      if (-1 === n.index) for (let e = 0; e < i.length; ++e) i[e]?.reset();
                      else i[n.index]?.reset();
                    }
                  }
                  break;
                case y.Morph.Type.VertexMorph:
                case y.Morph.Type.UvMorph:
                case y.Morph.Type.AdditionalUvMorph1:
                case y.Morph.Type.AdditionalUvMorph2:
                case y.Morph.Type.AdditionalUvMorph3:
                case y.Morph.Type.AdditionalUvMorph4: {
                  const t = e.elements;
                  for (let e = 0; e < t.length; ++e) t[e].influence = 0;
                }
              }
            }
            _applyMorph(e, t) {
              switch (e.type) {
                case y.Morph.Type.GroupMorph:
                  {
                    const n = this._morphs;
                    this._groupMorphFlatForeach(e, (e, i) => {
                      const o = n[e];
                      void 0 !== o && this._applyMorph(o, t * i);
                    });
                  }
                  break;
                case y.Morph.Type.BoneMorph:
                  this._applyBoneMorph(e, t);
                  break;
                case y.Morph.Type.MaterialMorph:
                  {
                    const n = e.materialElements;
                    for (let e = 0; e < n.length; ++e) {
                      const i = n[e],
                        o = this._materials;
                      if (-1 === i.index)
                        for (let e = 0; e < o.length; ++e) {
                          const n = o[e];
                          void 0 !== n && this._applyMaterialMorph(i, n, t);
                        }
                      else {
                        const e = o[i.index];
                        void 0 !== e && this._applyMaterialMorph(i, e, t);
                      }
                    }
                  }
                  break;
                case y.Morph.Type.VertexMorph:
                case y.Morph.Type.UvMorph:
                case y.Morph.Type.AdditionalUvMorph1:
                case y.Morph.Type.AdditionalUvMorph2:
                case y.Morph.Type.AdditionalUvMorph3:
                case y.Morph.Type.AdditionalUvMorph4: {
                  const n = e.elements;
                  for (let e = 0; e < n.length; ++e) n[e].influence += t;
                }
              }
            }
            _applyMaterialMorph(e, t, n) {
              if (e.type === y.Morph.MaterialMorph.Type.Multiply) {
                if (null !== e.diffuse) {
                  const i = t.diffuse;
                  for (let t = 0; t < 4; ++t) i[t] = i[t] + (i[t] * e.diffuse[t] - i[t]) * n;
                }
                if (null !== e.specular) {
                  const i = t.specular;
                  for (let t = 0; t < 3; ++t) i[t] = i[t] + (i[t] * e.specular[t] - i[t]) * n;
                }
                if (
                  (null !== e.shininess && (t.shininess = t.shininess + (t.shininess * e.shininess - t.shininess) * n),
                  null !== e.ambient)
                ) {
                  const i = t.ambient;
                  for (let t = 0; t < 3; ++t) i[t] = i[t] + (i[t] * e.ambient[t] - i[t]) * n;
                }
                if (null !== e.edgeColor) {
                  const i = t.edgeColor;
                  for (let t = 0; t < 4; ++t) i[t] = i[t] + (i[t] * e.edgeColor[t] - i[t]) * n;
                }
                if (
                  (null !== e.edgeSize && (t.edgeSize = t.edgeSize + (t.edgeSize * e.edgeSize - t.edgeSize) * n),
                  null !== e.textureColor)
                ) {
                  const i = t.textureColor;
                  for (let t = 0; t < 4; ++t) i[t] = i[t] + (i[t] * e.textureColor[t] - i[t]) * n;
                }
                if (null !== e.sphereTextureColor) {
                  const i = t.sphereTextureColor;
                  for (let t = 0; t < 4; ++t) i[t] = i[t] + (i[t] * e.sphereTextureColor[t] - i[t]) * n;
                }
                if (null !== e.toonTextureColor) {
                  const i = t.toonTextureColor;
                  for (let t = 0; t < 4; ++t) i[t] = i[t] + (i[t] * e.toonTextureColor[t] - i[t]) * n;
                }
              } else {
                if (null !== e.diffuse) {
                  const i = t.diffuse;
                  for (let t = 0; t < 4; ++t) i[t] += e.diffuse[t] * n;
                }
                if (null !== e.specular) {
                  const i = t.specular;
                  for (let t = 0; t < 3; ++t) i[t] += e.specular[t] * n;
                }
                if ((null !== e.shininess && (t.shininess += e.shininess * n), null !== e.ambient)) {
                  const i = t.ambient;
                  for (let t = 0; t < 3; ++t) i[t] += e.ambient[t] * n;
                }
                if (null !== e.edgeColor) {
                  const i = t.edgeColor;
                  for (let t = 0; t < 4; ++t) i[t] += e.edgeColor[t] * n;
                }
                if ((null !== e.edgeSize && (t.edgeSize += e.edgeSize * n), null !== e.textureColor)) {
                  const i = t.textureColor;
                  for (let t = 0; t < 4; ++t) i[t] += e.textureColor[t] * n;
                }
                if (null !== e.sphereTextureColor) {
                  const i = t.sphereTextureColor;
                  for (let t = 0; t < 4; ++t) i[t] += e.sphereTextureColor[t] * n;
                }
                if (null !== e.toonTextureColor) {
                  const i = t.toonTextureColor;
                  for (let t = 0; t < 4; ++t) i[t] += e.toonTextureColor[t] * n;
                }
              }
              this._updatedMaterials.add(t);
            }
          }
          class Hi extends qi {
            _wasmMorphWeights;
            _wasmMorphIndexMap;
            constructor(e, t, n, i, o, r, a) {
              super(null, n, i, o, r, a), (this._wasmMorphWeights = e), (this._wasmMorphIndexMap = t);
            }
            setMorphWeight(e, t) {
              const n = this._morphIndexMap.get(e);
              if (void 0 === n) return;
              const i = this._morphWeights,
                o = this._wasmMorphWeights.array,
                r = this._wasmMorphIndexMap;
              for (let e = 0; e < n.length; ++e) {
                const a = n[e];
                (i[a] = t), (o[r[a]] = t);
              }
              0 !== t && this._activeMorphs.add(e);
            }
            setMorphWeightFromIndex(e, t, n = !0) {
              (this._morphWeights[e] = t),
                n && (this._wasmMorphWeights.array[this._wasmMorphIndexMap[e]] = t),
                0 !== t && this._activeMorphs.add(this._morphs[e].name);
            }
            resetMorphWeights() {
              super.resetMorphWeights(), this._wasmMorphWeights.array.fill(0);
            }
            syncWasmMorphWeights() {
              const e = this._morphWeights,
                t = this._wasmMorphWeights.array,
                n = this._wasmMorphIndexMap;
              for (let i = 0; i < e.length; ++i) t[n[i]] = e[i];
            }
            _resetBoneMorph(e) {}
            _applyBoneMorph(e, t) {}
            get wasmMorphIndexMap() {
              return this._wasmMorphIndexMap;
            }
          }
          class Gi {
            diffuse;
            specular;
            shininess;
            ambient;
            edgeColor;
            edgeSize;
            textureColor;
            sphereTextureColor;
            toonTextureColor;
            _material;
            _initialDiffuse;
            _initialSpecular;
            _initialShininess;
            _initialAmbient;
            _initialEdgeColor;
            _initialEdgeSize;
            _initialTextureColor;
            _initialSphereTextureColor;
            _initialToonTextureColor;
            _initialTransparencyMode;
            _initialBackFaceCulling;
            constructor(e) {
              this._material = e;
              const t = e.diffuseColor;
              this.diffuse = [t.r, t.g, t.b, e.alpha];
              const n = e.specularColor;
              (this.specular = [n.r, n.g, n.b]), (this.shininess = e.specularPower);
              const i = e.ambientColor;
              this.ambient = [i.r, i.g, i.b];
              const o = e.outlineColor;
              (this.edgeColor = [o.r, o.g, o.b, e.outlineAlpha]),
                (this.edgeSize = e.outlineWidth),
                (this.textureColor = [1, 1, 1, 1]),
                (this.sphereTextureColor = [1, 1, 1, 1]),
                (this.toonTextureColor = [1, 1, 1, 1]),
                (this._initialDiffuse = [...this.diffuse]),
                (this._initialSpecular = [...this.specular]),
                (this._initialShininess = this.shininess),
                (this._initialAmbient = [...this.ambient]),
                (this._initialEdgeColor = [...this.edgeColor]),
                (this._initialEdgeSize = this.edgeSize),
                (this._initialTextureColor = [...this.textureColor]),
                (this._initialSphereTextureColor = [...this.sphereTextureColor]),
                (this._initialToonTextureColor = [...this.toonTextureColor]),
                (this._initialTransparencyMode = e.transparencyMode),
                (this._initialBackFaceCulling = e.backFaceCulling);
            }
            reset() {
              for (let e = 0; e < 4; ++e)
                (this.diffuse[e] = this._initialDiffuse[e]),
                  (this.edgeColor[e] = this._initialEdgeColor[e]),
                  (this.textureColor[e] = this._initialTextureColor[e]),
                  (this.sphereTextureColor[e] = this._initialSphereTextureColor[e]),
                  (this.toonTextureColor[e] = this._initialToonTextureColor[e]);
              for (let e = 0; e < 3; ++e)
                (this.specular[e] = this._initialSpecular[e]), (this.ambient[e] = this._initialAmbient[e]);
              (this.shininess = this._initialShininess), (this.edgeSize = this._initialEdgeSize);
            }
            applyChanges() {
              const e = this._material;
              e.diffuseColor.set(this.diffuse[0], this.diffuse[1], this.diffuse[2]),
                (e.alpha = this.diffuse[3]),
                1 === this.diffuse[3]
                  ? ((e.transparencyMode = this._initialTransparencyMode),
                    (e.backFaceCulling = this._initialBackFaceCulling))
                  : ((e.transparencyMode = N.Material.MATERIAL_ALPHABLEND), (e.backFaceCulling = !1)),
                e.specularColor.set(this.specular[0], this.specular[1], this.specular[2]),
                (e.specularPower = this.shininess),
                e.ambientColor.set(this.ambient[0], this.ambient[1], this.ambient[2]),
                e.outlineColor.set(this.edgeColor[0], this.edgeColor[1], this.edgeColor[2]),
                (e.outlineAlpha = this.edgeColor[3]),
                (e.outlineWidth = this.edgeSize),
                e.textureColor.set(
                  this.textureColor[0],
                  this.textureColor[1],
                  this.textureColor[2],
                  this.textureColor[3]
                ),
                e.sphereTextureColor.set(
                  this.sphereTextureColor[0],
                  this.sphereTextureColor[1],
                  this.sphereTextureColor[2],
                  this.sphereTextureColor[3]
                ),
                e.toonTextureColor.set(
                  this.toonTextureColor[0],
                  this.toonTextureColor[1],
                  this.toonTextureColor[2],
                  this.toonTextureColor[3]
                );
            }
          }
          class $i {
            encodePhysics;
            constructor() {
              this.encodePhysics = !0;
            }
            computeSize(e) {
              let t = 12;
              const n = e.bones;
              for (let e = 0; e < n.length; ++e) {
                t += 24;
                const i = n[e];
                if ((i.appendTransform && (t += 8), i.ik)) {
                  t += 16;
                  const e = i.ik.links;
                  for (let n = 0; n < e.length; ++n) (t += 8), e[n].limitation && (t += 24);
                }
              }
              t += 4;
              const i = e.morphs;
              for (let e = 0; e < i.length; ++e) {
                const n = i[e];
                switch (n.type) {
                  case y.Morph.Type.BoneMorph: {
                    const e = n.indices;
                    t += 8 + 4 * e.length + 12 * e.length + 16 * e.length;
                    break;
                  }
                  case y.Morph.Type.GroupMorph: {
                    const e = n.indices;
                    t += 8 + 4 * e.length + 4 * e.length;
                    break;
                  }
                }
              }
              if (this.encodePhysics) {
                t += 4;
                const n = e.rigidBodies;
                for (let e = 0; e < n.length; ++e) t += 68;
                t += 4;
                const i = e.joints;
                for (let e = 0; e < i.length; ++e) t += 108;
              } else t += 8;
              return t;
            }
            encode(e, t, n) {
              const i = new _t(n.buffer);
              i.offset = n.byteOffset;
              const o = new E.Vector3(),
                r = e.bones;
              i.setUint32(r.length);
              let a = 0,
                s = 0;
              for (let e = 0; e < r.length; ++e) {
                const t = r[e];
                t.appendTransform && (a += 1), t.ik && (s += 1);
              }
              i.setUint32(a), i.setUint32(s);
              for (let e = 0; e < r.length; ++e) {
                const n = r[e];
                if (
                  (i.setFloat32Array(t[e].getRestMatrix().getTranslationToRef(o).asArray()),
                  i.setInt32(n.parentBoneIndex),
                  i.setInt32(n.transformOrder),
                  i.setUint16(n.flag),
                  (i.offset += 2),
                  n.appendTransform &&
                    (i.setInt32(n.appendTransform.parentIndex), i.setFloat32(n.appendTransform.ratio)),
                  n.ik)
                ) {
                  i.setInt32(n.ik.target),
                    i.setInt32(n.ik.iteration),
                    i.setFloat32(n.ik.rotationConstraint),
                    i.setUint32(n.ik.links.length);
                  const e = n.ik.links;
                  for (let t = 0; t < e.length; ++t) {
                    const n = e[t];
                    i.setInt32(n.target),
                      i.setUint8(n.limitation ? 1 : 0),
                      (i.offset += 3),
                      n.limitation &&
                        (i.setFloat32Array(n.limitation.minimumAngle), i.setFloat32Array(n.limitation.maximumAngle));
                  }
                }
              }
              const l = e.morphs;
              let h = 0;
              for (let e = 0; e < l.length; ++e)
                switch (l[e].type) {
                  case y.Morph.Type.BoneMorph:
                  case y.Morph.Type.GroupMorph:
                    h += 1;
                }
              const d = new Int32Array(l.length).fill(-1);
              for (let e = 0, t = 0; e < l.length; ++e) {
                const n = l[e];
                (n.type !== y.Morph.Type.BoneMorph && n.type !== y.Morph.Type.GroupMorph) || ((d[e] = t), (t += 1));
              }
              i.setUint32(h);
              for (let e = 0; e < l.length; ++e) {
                const t = l[e];
                switch (t.type) {
                  case y.Morph.Type.BoneMorph:
                    i.setUint8(t.type),
                      (i.offset += 3),
                      i.setUint32(t.indices.length),
                      i.setInt32Array(t.indices),
                      i.setFloat32Array(t.positions),
                      i.setFloat32Array(t.rotations);
                    break;
                  case y.Morph.Type.GroupMorph: {
                    i.setUint8(t.type), (i.offset += 3), i.setUint32(t.indices.length);
                    const e = t.indices,
                      n = new Int32Array(e.length);
                    for (let t = 0; t < n.length; ++t) n[t] = d[e[t]];
                    i.setInt32Array(n), i.setFloat32Array(t.ratios);
                  }
                }
              }
              if (this.encodePhysics) {
                const t = e.rigidBodies;
                i.setUint32(t.length);
                for (let e = 0; e < t.length; ++e) {
                  const n = t[e];
                  i.setInt32(n.boneIndex),
                    i.setUint8(n.collisionGroup),
                    i.setUint8(n.shapeType),
                    i.setUint16(n.collisionMask),
                    i.setFloat32Array(n.shapeSize),
                    i.setFloat32Array(n.shapePosition),
                    i.setFloat32Array(n.shapeRotation),
                    i.setFloat32(n.mass),
                    i.setFloat32(n.linearDamping),
                    i.setFloat32(n.angularDamping),
                    i.setFloat32(n.repulsion),
                    i.setFloat32(n.friction),
                    i.setUint8(n.physicsMode),
                    (i.offset += 3);
                }
                const n = e.joints;
                i.setUint32(n.length);
                for (let e = 0; e < n.length; ++e) {
                  const t = n[e];
                  i.setUint8(t.type),
                    (i.offset += 3),
                    i.setInt32(t.rigidbodyIndexA),
                    i.setInt32(t.rigidbodyIndexB),
                    i.setFloat32Array(t.position),
                    i.setFloat32Array(t.rotation),
                    i.setFloat32Array(t.positionMin),
                    i.setFloat32Array(t.positionMax),
                    i.setFloat32Array(t.rotationMin),
                    i.setFloat32Array(t.rotationMax),
                    i.setFloat32Array(t.springPosition),
                    i.setFloat32Array(t.springRotation);
                }
              } else i.setUint32(0), i.setUint32(0);
              return d;
            }
          }
          class Xi {
            _lock;
            constructor(e) {
              this._lock = e;
            }
            wait() {
              const e = this._lock.array;
              let t = !1;
              const n = performance.now();
              for (; 0 !== e[0]; ) t = !0;
              if (t) {
                const e = performance.now() - n;
                console.trace(`Spinlock wait time: ${e}ms`);
              }
            }
          }
          var Ji, Zi;
          !(function (e) {
            (e[(e.Immediate = 0)] = "Immediate"), (e[(e.Buffered = 1)] = "Buffered");
          })(Ji || (Ji = {}));
          class eo {
            wasmInstance;
            wasmInternal;
            lock;
            _usingWasmBackBuffer;
            _lastRequestAnimationFrameTime;
            _needToSyncEvaluate;
            _mmdMetadataEncoder;
            _physics;
            _models;
            _camera;
            _audioPlayer;
            _loggingEnabled;
            log;
            warn;
            error;
            _isRegistered;
            onAnimationDurationChangedObservable;
            onPlayAnimationObservable;
            onPauseAnimationObservable;
            onSeekAnimationObservable;
            onAnimationTickObservable;
            _evaluationType;
            _currentFrameTime;
            _animationTimeScale;
            _animationPaused;
            _animationFrameTimeDuration;
            _useManualAnimationDuration;
            _needToInitializePhysicsModels;
            _needToInitializePhysicsModelsBuffer;
            _beforePhysicsBinded;
            _afterPhysicsBinded;
            _bindedDispose;
            _disposeObservableObject;
            constructor(e, t = null, n = null) {
              (this.wasmInstance = e),
                (this.wasmInternal = e.createMmdRuntime()),
                (this.lock = new Xi(e.createTypedArray(Uint8Array, this.wasmInternal.getLockStatePtr(), 1))),
                (this._usingWasmBackBuffer = !1),
                (this._lastRequestAnimationFrameTime = null),
                (this._needToSyncEvaluate = !0),
                (this._mmdMetadataEncoder = new $i()),
                (this._physics = n),
                (this._models = []),
                (this._camera = null),
                (this._audioPlayer = null),
                (this._loggingEnabled = !1),
                (this.log = this._logDisabled),
                (this.warn = this._warnDisabled),
                (this.error = this._errorDisabled),
                (this._isRegistered = !1),
                (this.onAnimationDurationChangedObservable = new U.Observable()),
                (this.onPlayAnimationObservable = new U.Observable()),
                (this.onPauseAnimationObservable = new U.Observable()),
                (this.onSeekAnimationObservable = new U.Observable()),
                (this.onAnimationTickObservable = new U.Observable()),
                (this._evaluationType = Ji.Immediate),
                (this._currentFrameTime = 0),
                (this._animationTimeScale = 1),
                (this._animationPaused = !0),
                (this._animationFrameTimeDuration = 0),
                (this._useManualAnimationDuration = !1),
                (this._needToInitializePhysicsModels = new Set()),
                (this._needToInitializePhysicsModelsBuffer = new Set()),
                (this._beforePhysicsBinded = null),
                (this._afterPhysicsBinded = this.afterPhysics.bind(this)),
                null !== t
                  ? ((this._bindedDispose = () => this.dispose(t)),
                    (this._disposeObservableObject = t),
                    null !== this._disposeObservableObject &&
                      this._disposeObservableObject.onDisposeObservable.add(this._bindedDispose))
                  : ((this._bindedDispose = null), (this._disposeObservableObject = null));
            }
            dispose(e) {
              this.lock.wait();
              for (let e = 0; e < this._models.length; ++e) this._models[e].dispose();
              (this._models.length = 0),
                this.setCamera(null),
                this.setAudioPlayer(null),
                this.onAnimationDurationChangedObservable.clear(),
                this.onPlayAnimationObservable.clear(),
                this.onPauseAnimationObservable.clear(),
                this.onSeekAnimationObservable.clear(),
                this.onAnimationTickObservable.clear(),
                this._needToInitializePhysicsModels.clear(),
                this.unregister(e),
                this.wasmInternal.free(),
                null !== this._disposeObservableObject &&
                  null !== this._bindedDispose &&
                  this._disposeObservableObject.onDisposeObservable.removeCallback(this._bindedDispose);
            }
            createMmdModel(e, t = {}) {
              if (!gt.isMmdSkinnedMesh(e)) throw new Error("Mesh validation failed.");
              return this.createMmdModelFromSkeleton(e, e.metadata.skeleton, t);
            }
            createMmdModelFromSkeleton(e, t, n = {}) {
              void 0 === n.materialProxyConstructor && (n.materialProxyConstructor = Gi),
                void 0 === n.buildPhysics && (n.buildPhysics = !0),
                this.lock.wait();
              const i = this._usingWasmBackBuffer;
              i && (this.wasmInternal.swapWorldMatrixBuffer(), (this._usingWasmBackBuffer = !1));
              const o = this._mmdMetadataEncoder;
              o.encodePhysics = n.buildPhysics;
              const r = o.computeSize(e.metadata),
                a = this.wasmInternal,
                s = a.allocateBuffer(r),
                l = this.wasmInstance.createTypedArray(Uint8Array, s, r),
                h = o.encode(e.metadata, t.bones, l.array),
                d = a.createMmdModel(s, r),
                c = new oo(this, d, e, t, n.materialProxyConstructor, h, n.buildPhysics ? this._physics : null);
              return (
                this._models.push(c),
                (this._evaluationType === Ji.Buffered
                  ? this._needToInitializePhysicsModelsBuffer
                  : this._needToInitializePhysicsModels
                ).add(c),
                a.deallocateBuffer(s, r),
                i && (this.wasmInternal.swapWorldMatrixBuffer(), (this._usingWasmBackBuffer = !0)),
                (this._needToSyncEvaluate = !0),
                c.onCurrentAnimationChangedObservable.add(this._onAnimationChanged),
                c
              );
            }
            destroyMmdModel(e) {
              e.dispose();
              const t = this._models,
                n = t.indexOf(e);
              if (n < 0) throw new Error("Model not found.");
              t.splice(n, 1), this.lock.wait(), this.wasmInternal.destroyMmdModel(e.ptr);
            }
            setCamera(e) {
              null !== this._camera &&
                this._camera.onCurrentAnimationChangedObservable.removeCallback(this._onAnimationChanged),
                null !== e && e.onCurrentAnimationChangedObservable.add(this._onAnimationChanged),
                (this._camera = e),
                this._onAnimationChanged(e?.currentAnimation ?? null);
            }
            _setAudioPlayerLastValue = null;
            async setAudioPlayer(e) {
              if (
                this._audioPlayer !== e &&
                ((this._setAudioPlayerLastValue = e),
                null !== this._audioPlayer &&
                  (this._audioPlayer.onDurationChangedObservable.removeCallback(this._onAudioDurationChanged),
                  this._audioPlayer.onPlaybackRateChangedObservable.removeCallback(this._onAudioPlaybackRateChanged),
                  this._audioPlayer.onPlayObservable.removeCallback(this._onAudioPlay),
                  this._audioPlayer.onPauseObservable.removeCallback(this._onAudioPause),
                  this._audioPlayer.onSeekObservable.removeCallback(this._onAudioSeek),
                  this._audioPlayer.pause()),
                (this._audioPlayer = null),
                null !== e)
              ) {
                if (!this._animationPaused) {
                  const t = 30 * e.duration;
                  if (
                    this._currentFrameTime < t &&
                    ((e.currentTime = this._currentFrameTime / 30), await e.play(), this._setAudioPlayerLastValue !== e)
                  )
                    return void e.pause();
                }
                (this._audioPlayer = e),
                  this._onAudioDurationChanged(),
                  e.onDurationChangedObservable.add(this._onAudioDurationChanged),
                  e.onPlaybackRateChangedObservable.add(this._onAudioPlaybackRateChanged),
                  e.onPlayObservable.add(this._onAudioPlay),
                  e.onPauseObservable.add(this._onAudioPause),
                  e.onSeekObservable.add(this._onAudioSeek),
                  e._setPlaybackRateWithoutNotify(this._animationTimeScale);
              }
            }
            register(e) {
              this._isRegistered ||
                ((this._isRegistered = !0),
                (this._beforePhysicsBinded = () => this.beforePhysics(e.getEngine().getDeltaTime())),
                e.onBeforeAnimationsObservable.add(this._beforePhysicsBinded),
                e.onBeforeRenderObservable.add(this._afterPhysicsBinded));
            }
            unregister(e) {
              this._isRegistered &&
                ((this._isRegistered = !1),
                e.onBeforeAnimationsObservable.removeCallback(this._beforePhysicsBinded),
                e.onBeforeRenderObservable.removeCallback(this._afterPhysicsBinded),
                (this._beforePhysicsBinded = null));
            }
            beforePhysics(e) {
              let t = null;
              if (!this._animationPaused) {
                if (null === this._audioPlayer || this._audioPlayer.paused)
                  this._currentFrameTime += (e / 1e3) * 30 * this._animationTimeScale;
                else {
                  const t = this._audioPlayer.currentTime,
                    n = t - this._currentFrameTime / 30,
                    i = Math.abs(n);
                  if (i < 0.05) this._currentFrameTime += (e / 1e3) * 30 * this._animationTimeScale;
                  else if (i < 0.5)
                    this._currentFrameTime +=
                      n < 0
                        ? (e / 1e3) * 30 * this._animationTimeScale * 0.9
                        : (e / 1e3) * 30 * this._animationTimeScale * 1.1;
                  else {
                    if (60 < Math.abs(t - this._currentFrameTime)) {
                      const e = this._needToInitializePhysicsModels;
                      for (let t = 0; t < this._models.length; ++t) {
                        const n = this._models[t];
                        null !== n.currentAnimation && e.add(n);
                      }
                    }
                    this._currentFrameTime = 30 * t;
                  }
                }
                (t = this._currentFrameTime),
                  this._animationFrameTimeDuration <= t &&
                    ((this._animationPaused = !0),
                    (this._currentFrameTime = this._animationFrameTimeDuration),
                    null === this._audioPlayer || this._audioPlayer.paused
                      ? this.onPauseAnimationObservable.notifyObservers()
                      : this._audioPlayer.pause());
              }
              if (this._evaluationType === Ji.Buffered) {
                const e = this._models;
                {
                  const n = this._lastRequestAnimationFrameTime ?? t;
                  for (let t = 0; t < e.length; ++t) {
                    const i = e[t];
                    void 0 !== i.currentAnimation?.wasmAnimate && e[t].beforePhysicsAndWasm(n);
                  }
                  null !== n && null !== this._camera && this._camera.animate(n);
                }
                if (
                  (void 0 === this.wasmInstance.MmdRuntime.bufferedUpdate &&
                    (this.wasmInternal.beforePhysics(this._lastRequestAnimationFrameTime ?? void 0),
                    this.wasmInternal.afterPhysics()),
                  this.lock.wait(),
                  !1 === this._usingWasmBackBuffer &&
                    ((this._usingWasmBackBuffer = !0), this.wasmInternal.swapWorldMatrixBuffer()),
                  null == this._lastRequestAnimationFrameTime)
                )
                  if (null !== t) {
                    for (let n = 0; n < e.length; ++n) {
                      const i = e[n];
                      void 0 === i.currentAnimation?.wasmAnimate && e[n].beforePhysicsAndWasm(t);
                    }
                    this.wasmInternal.beforePhysics(t ?? void 0), this.wasmInternal.afterPhysics();
                  } else
                    this._needToSyncEvaluate &&
                      ((this._needToSyncEvaluate = !1),
                      this.wasmInternal.beforePhysics(),
                      this.wasmInternal.afterPhysics());
                else if (this._needToSyncEvaluate) {
                  this._needToSyncEvaluate = !1;
                  for (let t = 0; t < e.length; ++t) {
                    const n = e[t];
                    void 0 === n.currentAnimation?.wasmAnimate &&
                      e[t].beforePhysicsAndWasm(this._lastRequestAnimationFrameTime);
                  }
                  this.wasmInternal.beforePhysics(this._lastRequestAnimationFrameTime),
                    this.wasmInternal.afterPhysics();
                }
                for (let t = 0; t < e.length; ++t) e[t].swapWorldTransformMatricesBuffer();
                this.wasmInternal.swapWorldMatrixBuffer();
                for (let t = 0; t < e.length; ++t) e[t].beforePhysics();
                for (let n = 0; n < e.length; ++n) {
                  const i = e[n];
                  void 0 === i.currentAnimation?.wasmAnimate && e[n].beforePhysicsAndWasm(t);
                }
                this.wasmInstance.MmdRuntime.bufferedUpdate?.(this.wasmInternal, t ?? void 0),
                  (this._lastRequestAnimationFrameTime = t);
                const n = this._needToInitializePhysicsModelsBuffer;
                for (const e of n) e.initializePhysics();
                n.clear();
                const i = this._needToInitializePhysicsModels;
                for (const e of i) n.add(e);
                i.clear();
              } else {
                if (!0 === this._usingWasmBackBuffer) {
                  const e = this._needToInitializePhysicsModelsBuffer,
                    t = this._needToInitializePhysicsModels;
                  for (const n of e) t.add(n);
                  this.lock.wait(),
                    (this._usingWasmBackBuffer = !1),
                    (this._lastRequestAnimationFrameTime = null),
                    this.wasmInternal.swapWorldMatrixBuffer();
                }
                const e = this._models;
                for (let n = 0; n < e.length; ++n) e[n].beforePhysicsAndWasm(t);
                this.wasmInternal.beforePhysics(t ?? void 0);
                for (let t = 0; t < e.length; ++t) e[t].beforePhysics();
                this._needToSyncEvaluate = !1;
                const n = this._needToInitializePhysicsModels;
                for (const e of n) e.initializePhysics();
                n.clear(), null !== t && null !== this._camera && this._camera.animate(t);
              }
              null !== t && this.onAnimationTickObservable.notifyObservers();
            }
            afterPhysics() {
              const e = this._models;
              if (this._usingWasmBackBuffer)
                for (let t = 0; t < e.length; ++t) {
                  const n = e[t];
                  n.afterPhysicsAndWasm(), n.afterPhysics();
                }
              else {
                for (let t = 0; t < e.length; ++t) e[t].afterPhysicsAndWasm();
                this.wasmInternal.afterPhysics();
                for (let t = 0; t < e.length; ++t) e[t].afterPhysics();
              }
            }
            _onAnimationChanged = (e) => {
              if (this._useManualAnimationDuration) return;
              const t = e?.animation.endFrame ?? 0;
              this._animationFrameTimeDuration < t
                ? (this._animationFrameTimeDuration = t)
                : t < this._animationFrameTimeDuration &&
                  (this._animationFrameTimeDuration = this._computeAnimationDuration()),
                this.onAnimationDurationChangedObservable.notifyObservers();
            };
            _computeAnimationDuration() {
              let e = 0;
              const t = this._models;
              for (let n = 0; n < t.length; ++n) {
                const i = t[n];
                null !== i.currentAnimation && (e = Math.max(e, i.currentAnimation.animation.endFrame));
              }
              return (
                null !== this._camera &&
                  null !== this._camera.currentAnimation &&
                  (e = Math.max(e, this._camera.currentAnimation.animation.endFrame)),
                null !== this._audioPlayer && (e = Math.max(e, 30 * this._audioPlayer.duration)),
                e
              );
            }
            _onAudioDurationChanged = () => {
              if (!this._animationPaused) {
                const e = this._audioPlayer,
                  t = this._currentFrameTime / 30;
                t < e.duration &&
                  (e._setCurrentTimeWithoutNotify(t),
                  e.play().then(() => {
                    this._setAudioPlayerLastValue === e || e.pause();
                  }));
              }
              if (this._useManualAnimationDuration) return;
              const e = 30 * this._audioPlayer.duration;
              this._animationFrameTimeDuration < e
                ? (this._animationFrameTimeDuration = e)
                : (this._animationFrameTimeDuration = this._computeAnimationDuration()),
                this.onAnimationDurationChangedObservable.notifyObservers();
            };
            _onAudioPlaybackRateChanged = () => {
              this._animationTimeScale = this._audioPlayer.playbackRate;
            };
            _onAudioPlay = () => {
              this._playAnimationInternal();
            };
            _onAudioPause = () => {
              this._audioPlayer.currentTime !== this._audioPlayer.duration &&
                ((this._animationPaused = !0), this.onPauseAnimationObservable.notifyObservers());
            };
            _onAudioSeek = () => {
              this._seekAnimationInternal(30 * this._audioPlayer.currentTime, this._animationPaused);
            };
            _playAnimationInternal() {
              if (this._animationPaused) {
                if (((this._animationPaused = !1), 0 === this._currentFrameTime)) {
                  const e = this._models,
                    t =
                      this._evaluationType === Ji.Buffered
                        ? this._needToInitializePhysicsModelsBuffer
                        : this._needToInitializePhysicsModels;
                  for (let n = 0; n < e.length; ++n) t.add(e[n]);
                }
                this.onPlayAnimationObservable.notifyObservers();
              }
            }
            async playAnimation() {
              if (null !== this._audioPlayer && this._currentFrameTime < 30 * this._audioPlayer.duration)
                try {
                  const e = this._currentFrameTime / 30;
                  0.05 < Math.abs(this._audioPlayer.currentTime - e) &&
                    this._audioPlayer._setCurrentTimeWithoutNotify(e),
                    await this._audioPlayer.play();
                } catch (e) {
                  if (!(e instanceof DOMException && "NotSupportedError" === e.name)) throw e;
                  this.error("Failed to play audio."), this._playAnimationInternal();
                }
              else this._playAnimationInternal();
            }
            pauseAnimation() {
              null === this._audioPlayer || this._audioPlayer.paused
                ? ((this._animationPaused = !0), this.onPauseAnimationObservable.notifyObservers())
                : (this._audioPlayer.pause(), (this._animationPaused = !0));
            }
            _seekAnimationInternal(e, t) {
              if (60 < Math.abs(e - this._currentFrameTime)) {
                const e =
                  this._evaluationType === Ji.Buffered
                    ? this._needToInitializePhysicsModelsBuffer
                    : this._needToInitializePhysicsModels;
                for (let t = 0; t < this._models.length; ++t) {
                  const n = this._models[t];
                  null !== n.currentAnimation && e.add(n);
                }
              }
              if (((this._currentFrameTime = e), t)) {
                const t = this._models;
                if (this._evaluationType === Ji.Buffered)
                  (this._lastRequestAnimationFrameTime = e), (this._needToSyncEvaluate = !0);
                else {
                  this.lock.wait();
                  for (let n = 0; n < t.length; ++n) {
                    const i = t[n].currentAnimation;
                    null !== i && (void 0 !== i.wasmAnimate ? (i.wasmAnimate(e), i.animate(e)) : i.animate(e));
                  }
                }
                null !== this._camera && null !== this._camera.currentAnimation && this._camera.animate(e),
                  this.onAnimationTickObservable.notifyObservers();
              }
              this.onSeekAnimationObservable.notifyObservers();
            }
            async seekAnimation(e, t = !1) {
              if (((e = Math.max(0, Math.min(e, this._animationFrameTimeDuration))), null !== this._audioPlayer))
                if (this._audioPlayer.paused)
                  if (
                    !this._animationPaused &&
                    30 * this._audioPlayer.currentTime < this._animationFrameTimeDuration &&
                    e < 30 * this._audioPlayer.duration
                  )
                    try {
                      this._audioPlayer._setCurrentTimeWithoutNotify(e / 30), await this._audioPlayer.play();
                    } catch (n) {
                      if (!(n instanceof DOMException && "NotSupportedError" === n.name)) throw n;
                      this.error("Failed to play audio."), this._seekAnimationInternal(e, t);
                    }
                  else this._seekAnimationInternal(e, t), this._audioPlayer?._setCurrentTimeWithoutNotify(e / 30);
                else this._audioPlayer.currentTime = e / 30;
              else this._seekAnimationInternal(e, t);
            }
            get isAnimationPlaying() {
              return !this._animationPaused;
            }
            get models() {
              return this._models;
            }
            get camera() {
              return this._camera;
            }
            get audioPlayer() {
              return this._audioPlayer;
            }
            get timeScale() {
              return this._animationTimeScale;
            }
            set timeScale(e) {
              (this._animationTimeScale = e),
                null !== this._audioPlayer && this._audioPlayer._setPlaybackRateWithoutNotify(e);
            }
            get currentFrameTime() {
              return this._currentFrameTime;
            }
            get currentTime() {
              return this._currentFrameTime / 30;
            }
            get animationFrameTimeDuration() {
              return this._animationFrameTimeDuration;
            }
            get animationDuration() {
              return this._animationFrameTimeDuration / 30;
            }
            setManualAnimationDuration(e) {
              (null !== e || this._useManualAnimationDuration) &&
                (null === e
                  ? ((this._useManualAnimationDuration = !1),
                    (this._animationFrameTimeDuration = this._computeAnimationDuration()))
                  : ((this._useManualAnimationDuration = !0), (this._animationFrameTimeDuration = e)),
                this.onAnimationDurationChangedObservable.notifyObservers());
            }
            get evaluationType() {
              return this._evaluationType;
            }
            set evaluationType(e) {
              if (this._evaluationType === e) return;
              Ji.Buffered, (this._evaluationType = e);
              const t = this._models;
              for (let n = 0; n < t.length; ++n) t[n].onEvaluationTypeChanged(e);
            }
            get usingWasmBackBuffer() {
              return this._usingWasmBackBuffer;
            }
            get loggingEnabled() {
              return this._loggingEnabled;
            }
            set loggingEnabled(e) {
              (this._loggingEnabled = e),
                e
                  ? ((this.log = this._logEnabled), (this.warn = this._warnEnabled), (this.error = this._errorEnabled))
                  : ((this.log = this._logDisabled),
                    (this.warn = this._warnDisabled),
                    (this.error = this._errorDisabled));
            }
            _logEnabled(e) {
              k.Logger.Log(e);
            }
            _logDisabled() {}
            _warnEnabled(e) {
              k.Logger.Warn(e);
            }
            _warnDisabled() {}
            _errorEnabled(e) {
              k.Logger.Error(e);
            }
            _errorDisabled() {}
          }
          class to {
            _frontBuffer;
            _backBuffer;
            constructor(e, t) {
              (this._frontBuffer = e), (this._backBuffer = t ?? e);
            }
            setBackBuffer(e) {
              this._backBuffer = e;
            }
            swap() {
              const e = this._backBuffer;
              (this._backBuffer = this._frontBuffer), (this._frontBuffer = e);
            }
            get frontBuffer() {
              return this._frontBuffer.array;
            }
            get backBuffer() {
              return this._backBuffer.array;
            }
          }
          class no {
            _data;
            _frontBufferPtr;
            _frontBufferSpan;
            _backBufferSpan;
            constructor(e, t, n, i) {
              this._data = t;
              const o = (this._frontBufferPtr = t.frontBuffer.byteOffset);
              this._frontBufferSpan = e.createTypedArray(t.frontBuffer.constructor, o + n, i);
              const r = t.backBuffer.byteOffset;
              this._backBufferSpan = e.createTypedArray(t.backBuffer.constructor, r + n, i);
            }
            updateBackBufferReference(e) {
              const t = this._frontBufferSpan.array,
                n = t.byteOffset - this._frontBufferPtr,
                i = t.length,
                o = this._data.backBuffer.byteOffset;
              this._backBufferSpan = e.createTypedArray(this._data.backBuffer.constructor, o + n, i);
            }
            get array() {
              if (this._frontBufferPtr !== this._data.frontBuffer.byteOffset) {
                this._frontBufferPtr = this._data.frontBuffer.byteOffset;
                const e = this._backBufferSpan;
                (this._backBufferSpan = this._frontBufferSpan), (this._frontBufferSpan = e);
              }
              return this._frontBufferSpan.array;
            }
          }
          class io {
            linkedBone;
            name;
            parentBone;
            childBones;
            transformOrder;
            flag;
            transformAfterPhysics;
            _worldMatrix;
            get worldMatrix() {
              return this._worldMatrix.array;
            }
            ikSolverIndex;
            _boneIndex;
            _mmdRuntime;
            _mmdModelPtr;
            constructor(e, t, n, i, o, r, a) {
              (this.linkedBone = e),
                (this.name = t.name),
                (this.parentBone = null),
                (this.childBones = []),
                (this.transformOrder = t.transformOrder),
                (this.flag = t.flag),
                (this.transformAfterPhysics = 0 != (t.flag & y.Bone.Flag.TransformAfterPhysics)),
                (this._worldMatrix = new no(r.wasmInstance, n, 16 * i * 4, 16)),
                (this.ikSolverIndex = o),
                (this._boneIndex = i),
                (this._mmdRuntime = r),
                (this._mmdModelPtr = a);
            }
            updateBackBufferReference(e) {
              this._worldMatrix.updateBackBufferReference(e);
            }
            updateWorldMatrix() {
              this._mmdRuntime.usingWasmBackBuffer
                ? this._mmdRuntime.wasmInternal.updateBackBufferBoneWorldMatrix(this._mmdModelPtr, this._boneIndex)
                : this._mmdRuntime.wasmInternal.updateBoneWorldMatrix(this._mmdModelPtr, this._boneIndex);
            }
            getWorldMatrixToRef(e) {
              return E.Matrix.FromArrayToRef(this._worldMatrix.array, 0, e);
            }
            getWorldTranslationToRef(e) {
              return E.Vector3.FromArrayToRef(this._worldMatrix.array, 12, e);
            }
            setWorldTranslationFromRef(e) {
              const t = this._worldMatrix.array;
              (t[12] = e.x), (t[13] = e.y), (t[14] = e.z);
            }
          }
          class oo {
            ptr;
            mesh;
            skeleton;
            _worldTransformMatrices;
            get worldTransformMatrices() {
              return this._worldTransformMatrices.frontBuffer;
            }
            _boneAnimationStates;
            get boneAnimationStates() {
              return this._runtime.lock.wait(), this._boneAnimationStates.array;
            }
            _ikSolverStates;
            get ikSolverStates() {
              return this._runtime.lock.wait(), this._ikSolverStates.array;
            }
            runtimeBones;
            morph;
            _physicsModel;
            _runtime;
            _sortedRuntimeBones;
            onCurrentAnimationChangedObservable;
            _animations;
            _animationIndexMap;
            _currentAnimation;
            _needStateReset;
            constructor(e, t, n, i, o, r, a) {
              const s = e.wasmInstance,
                l = e.wasmInternal;
              this._runtime = e;
              const h = n.metadata,
                d = n;
              (d.metadata = {
                isRuntimeMmdModel: !0,
                header: h.header,
                meshes: h.meshes,
                materials: h.materials,
                skeleton: h.skeleton,
              }),
                (this.ptr = t),
                (this.mesh = d),
                (this.skeleton = i);
              const c = l.getBoneWorldMatrixArena(t),
                m = l.getAnimationArena(t),
                u = l.getAnimationIkSolverStateArena(t),
                p = l.getAnimationMorphArena(t),
                g = s.createTypedArray(Float32Array, c, 16 * h.bones.length);
              let f = g;
              if (e.evaluationType === Ji.Buffered) {
                const e = l.createBoneWorldMatrixBackBuffer(this.ptr);
                f = s.createTypedArray(Float32Array, e, 16 * h.bones.length);
              }
              const _ = (this._worldTransformMatrices = new to(g, f));
              this._boneAnimationStates = s.createTypedArray(Float32Array, m, 12 * h.bones.length);
              let b = 0;
              for (let e = 0; e < h.bones.length; ++e) h.bones[e].ik && (b += 1);
              (this._ikSolverStates = s.createTypedArray(Uint8Array, u, b)),
                i.prepare(),
                this._disableSkeletonWorldMatrixUpdate(i);
              const A = (this.runtimeBones = this._buildRuntimeSkeleton(i.bones, h.bones, _, e, t)),
                M = (this._sortedRuntimeBones = [...A]);
              M.sort((e, t) => e.transformOrder - t.transformOrder);
              const T = h.morphs;
              let w = 0;
              for (let e = 0; e < T.length; ++e)
                switch (T[e].type) {
                  case y.Morph.Type.BoneMorph:
                  case y.Morph.Type.GroupMorph:
                    w += 1;
                }
              const x = s.createTypedArray(Float32Array, p, w),
                I = [];
              {
                const e = h.meshes;
                for (let t = 0; t < e.length; ++t) {
                  const n = e[t].morphTargetManager;
                  null !== n && I.push(n);
                }
              }
              if (((this.morph = new Hi(x, r, h.materials, o, h.morphs, I, e)), null !== a)) {
                this.beforePhysicsAndWasm(null), l.updataBoneLocalMatrices(t);
                for (let e = 0; e < M.length; ++e) null === M[e].parentBone && M[e].updateWorldMatrix();
                this._physicsModel = a.buildPhysics(n, A, h.rigidBodies, h.joints, e);
              } else this._physicsModel = null;
              (this.onCurrentAnimationChangedObservable = new U.Observable()),
                (this._animations = []),
                (this._animationIndexMap = new Map()),
                (this._currentAnimation = null),
                (this._needStateReset = !1);
            }
            dispose() {
              this._enableSkeletonWorldMatrixUpdate(), this.onCurrentAnimationChangedObservable.clear();
              const e = this._animations;
              for (let t = 0; t < e.length; ++t) e[t].dispose?.();
              (this._animations.length = 0), this._animationIndexMap.clear(), (this.mesh.metadata = null);
            }
            get sortedRuntimeBones() {
              return this._sortedRuntimeBones;
            }
            addAnimation(e, t) {
              let n;
              if (void 0 !== e.createWasmRuntimeModelAnimation)
                this._runtime.lock.wait(),
                  (n = e.createWasmRuntimeModelAnimation(
                    this,
                    () => {
                      this._removeAnimationByReference(n);
                    },
                    t,
                    this._runtime
                  ));
              else {
                if (void 0 === e.createRuntimeModelAnimation)
                  throw new Error(
                    'animation is not MmdWasmAnimation or MmdAnimation or MmdModelAnimationGroup or MmdCompositeAnimation. are you missing import "babylon-mmd/esm/Runtime/Optimized/Animation/mmdWasmRuntimeModelAnimation" or "babylon-mmd/esm/Runtime/Animation/mmdRuntimeModelAnimation" or "babylon-mmd/esm/Runtime/Animation/mmdRuntimeModelAnimationGroup" or "babylon-mmd/esm/Runtime/Animation/mmdCompositeRuntimeModelAnimation"?'
                  );
                (n = e.createRuntimeModelAnimation(this, t, this._runtime)),
                  void 0 !== e.ptr &&
                    this._runtime.warn(
                      'MmdWasmAnimation has better performance in the wasm animation runtime. consider importing "babylon-mmd/esm/Runtime/Optimized/Animation/mmdWasmRuntimeModelAnimation" instead of "babylon-mmd/esm/Runtime/Animation/mmdRuntimeModelAnimation"'
                    );
              }
              this._animationIndexMap.set(e.name, this._animations.length), this._animations.push(n);
            }
            _removeAnimationByReference(e) {
              const t = this._animations.indexOf(e);
              -1 !== t && this._removeAnimation(t, !0);
            }
            removeAnimation(e) {
              this._removeAnimation(e, !1);
            }
            _removeAnimation(e, t) {
              const n = this._animations[e];
              void 0 !== n &&
                (this._currentAnimation === n &&
                  (this._resetPose(),
                  void 0 !== this._currentAnimation.wasmAnimate &&
                    (this._runtime.lock.wait(), this._runtime.wasmInternal.setRuntimeAnimation(this.ptr, 0)),
                  (this._currentAnimation = null),
                  this.onCurrentAnimationChangedObservable.notifyObservers(null)),
                this._animationIndexMap.delete(n.animation.name),
                this._animations.splice(e, 1),
                t || n.dispose?.());
            }
            setAnimation(e, t = !0) {
              if (null === e)
                return void (
                  null !== this._currentAnimation &&
                  (this._resetPose(),
                  void 0 !== this._currentAnimation.wasmAnimate &&
                    (this._runtime.lock.wait(), this._runtime.wasmInternal.setRuntimeAnimation(this.ptr, 0)),
                  (this._currentAnimation = null),
                  this.onCurrentAnimationChangedObservable.notifyObservers(null))
                );
              const n = this._animationIndexMap.get(e);
              if (void 0 === n) throw new Error(`Animation '${e}' is not found.`);
              null !== this._currentAnimation && (this._resetPose(), (this._needStateReset = !0));
              const i = (this._currentAnimation = this._animations[n]);
              void 0 !== i.wasmAnimate &&
                (this._runtime.lock.wait(), this._runtime.wasmInternal.setRuntimeAnimation(this.ptr, i.ptr)),
                i.induceMaterialRecompile(t, this._runtime),
                this.onCurrentAnimationChangedObservable.notifyObservers(i);
            }
            get runtimeAnimations() {
              return this._animations;
            }
            get currentAnimation() {
              return this._currentAnimation;
            }
            initializePhysics() {
              this._physicsModel?.initialize();
            }
            beforePhysicsAndWasm(e) {
              if (
                (null !== e &&
                  (this._needStateReset &&
                    ((this._needStateReset = !1), this.ikSolverStates.fill(1), this.morph.resetMorphWeights()),
                  null !== this._currentAnimation && this._currentAnimation.animate(e)),
                this.morph.update(),
                void 0 === this._currentAnimation?.wasmAnimate)
              ) {
                const e = this.skeleton.bones,
                  t = this.boneAnimationStates;
                for (let n = 0; n < e.length; ++n) {
                  const i = e[n],
                    o = 12 * n;
                  {
                    const { x: e, y: n, z: r } = i.position;
                    (t[o + 0] = e), (t[o + 1] = n), (t[o + 2] = r);
                  }
                  {
                    const { x: e, y: n, z: r, w: a } = i.rotationQuaternion;
                    (t[o + 4] = e), (t[o + 5] = n), (t[o + 6] = r), (t[o + 7] = a);
                  }
                  {
                    const { x: e, y: n, z: r } = i.scaling;
                    (t[o + 8] = e), (t[o + 9] = n), (t[o + 10] = r);
                  }
                }
              }
            }
            beforePhysics() {
              this._physicsModel?.syncBodies();
            }
            afterPhysicsAndWasm() {
              const e = this._physicsModel;
              null !== e && e.syncBones();
            }
            afterPhysics() {
              this.mesh.metadata.skeleton._markAsDirty();
            }
            _buildRuntimeSkeleton(e, t, n, i, o) {
              const r = [];
              let a = 0;
              for (let s = 0; s < t.length; ++s) {
                const l = t[s];
                let h = -1;
                void 0 !== l.ik && ((h = a), (a += 1)), r.push(new io(e[s], l, n, s, h, i, o));
              }
              for (let e = 0; e < t.length; ++e) {
                const n = t[e],
                  i = r[e],
                  o = n.parentBoneIndex;
                if (0 <= o && o < r.length) {
                  const e = r[o];
                  (i.parentBone = e), e.childBones.push(i);
                }
              }
              return r;
            }
            _originalComputeTransformMatrices = null;
            _disableSkeletonWorldMatrixUpdate(e) {
              if (null !== this._originalComputeTransformMatrices) return;
              this._originalComputeTransformMatrices = e._computeTransformMatrices;
              const t = this._worldTransformMatrices;
              e._computeTransformMatrices = function (e, n) {
                this.onBeforeComputeObservable.notifyObservers(this);
                const i = t.frontBuffer;
                for (let t = 0; t < this.bones.length; t++) {
                  const n = this.bones[t];
                  if (((n._childUpdateId += 1), -1 !== n._index)) {
                    const o = null === n._index ? t : n._index;
                    n.getAbsoluteInverseBindMatrix().multiplyToArray(
                      E.Matrix.FromArrayToRef(i, 16 * t, n.getFinalMatrix()),
                      e,
                      16 * o
                    );
                  }
                }
                this._identity.copyToArray(e, 16 * this.bones.length);
              };
            }
            _enableSkeletonWorldMatrixUpdate() {
              null !== this._originalComputeTransformMatrices &&
                ((this.skeleton._computeTransformMatrices = this._originalComputeTransformMatrices),
                (this._originalComputeTransformMatrices = null));
            }
            _resetPose() {
              const e = new E.Vector3();
              if (void 0 === this._currentAnimation?.wasmAnimate) {
                const t = this._sortedRuntimeBones,
                  n = E.Quaternion.Identity();
                for (let i = 0; i < t.length; ++i) {
                  const o = t[i].linkedBone;
                  o.getRestMatrix().getTranslationToRef(e),
                    (o.position = e),
                    o.setRotationQuaternion(n, ze.Space.LOCAL);
                }
              } else {
                this._runtime.lock.wait();
                const t = this.skeleton.bones,
                  n = this.boneAnimationStates;
                for (let i = 0; i < t.length; ++i) {
                  const o = t[i],
                    r = 12 * i,
                    { x: a, y: s, z: l } = o.getRestMatrix().getTranslationToRef(e);
                  (n[r + 0] = a),
                    (n[r + 1] = s),
                    (n[r + 2] = l),
                    (n[r + 4] = 0),
                    (n[r + 5] = 0),
                    (n[r + 6] = 0),
                    (n[r + 7] = 1),
                    (n[r + 8] = 1),
                    (n[r + 9] = 1),
                    (n[r + 10] = 1);
                }
              }
              this.mesh.metadata.skeleton._markAsDirty();
            }
            onEvaluationTypeChanged(e) {
              if (e === Ji.Buffered) {
                const e = this._worldTransformMatrices;
                if (e.frontBuffer === e.backBuffer) {
                  const t = this._runtime.wasmInstance,
                    n = this._runtime.wasmInternal.createBoneWorldMatrixBackBuffer(this.ptr),
                    i = t.createTypedArray(Float32Array, n, e.frontBuffer.length);
                  e.setBackBuffer(i);
                  const o = this._sortedRuntimeBones;
                  for (let e = 0; e < o.length; ++e) o[e].updateBackBufferReference(t);
                }
              }
            }
            swapWorldTransformMatricesBuffer() {
              this._worldTransformMatrices.swap();
            }
          }
          class ro {
            index;
            name;
            get position() {
              return this._position;
            }
            set position(e) {
              this._position.copyFrom(e);
            }
            get rotationQuaternion() {
              return this._rotationQuaternion;
            }
            set rotationQuaternion(e) {
              this._rotationQuaternion.copyFrom(e);
            }
            get scaling() {
              return this._scaling;
            }
            set scaling(e) {
              this._scaling.copyFrom(e);
            }
            _position;
            _rotationQuaternion;
            _scaling;
            parent;
            children;
            bone;
            _boneWorldRestRotationMatrix;
            _boneFinalMatrix;
            _boneFinalMatrixInverse;
            _boneParent;
            _restMatrix;
            _positionApplyScale;
            _scalingMatrix;
            constructor(e, t, n, i, o) {
              (this.index = e),
                (this.name = t),
                (this._position = E.Vector3.Zero()),
                (this._rotationQuaternion = E.Quaternion.Identity()),
                (this._scaling = E.Vector3.One()),
                (this.parent = null),
                (this.children = []),
                (this.bone = n),
                (this._boneWorldRestRotationMatrix = null !== n ? n.getFinalMatrix().getRotationMatrix() : null),
                (this._boneFinalMatrix = null !== n ? E.Matrix.Identity() : null),
                (this._boneFinalMatrixInverse = null !== n ? E.Matrix.Identity() : null),
                (this._boneParent = null),
                (this._restMatrix = E.Matrix.Identity()),
                (this._positionApplyScale = i),
                (this._scalingMatrix = o);
            }
            getRestMatrix() {
              return this._restMatrix;
            }
            setRotationQuaternion(e) {
              this._rotationQuaternion.copyFrom(e);
            }
            updateBoneParent() {
              let e = this.parent;
              if (null !== e) for (; null === e.bone && ((e = e.parent), null !== e); );
              this._boneParent = e;
            }
            computeBoneFinalMatrix(e, t) {
              const n = this._boneFinalMatrix;
              "センター" === this.name ? t.getWorldMatrixToRef(n) : e[this.index].getWorldMatrixToRef(n),
                this._scalingMatrix.multiplyToRef(n, n),
                n.multiplyToRef(this._scalingMatrix, n);
              const i = this._positionApplyScale;
              {
                const e = n.m;
                n.setTranslationFromFloats(e[12] * i.x, e[13] * i.y, e[14] * i.z);
              }
              this._boneWorldRestRotationMatrix.multiplyToRef(n, n), this._boneFinalMatrixInverse.copyFrom(n).invert();
            }
            static _BoneLocalMatrix = new E.Matrix();
            apply() {
              const e = this._boneParent,
                t = ro._BoneLocalMatrix.copyFrom(this._boneFinalMatrix);
              null !== e && t.multiplyToRef(e._boneFinalMatrixInverse, t), (this.bone._matrix = t);
            }
          }
          class ao {
            bones;
            _skeleton;
            _runtimeBones;
            _upperBodyBone;
            constructor(e, t) {
              (this.bones = e), (this._skeleton = t), (this._runtimeBones = null), (this._upperBodyBone = null);
            }
            lateInitialize(e) {
              this._runtimeBones = e;
              let t = null;
              for (let n = 0; n < e.length; ++n) {
                const i = e[n];
                if ("上半身" === i.name) {
                  t = i;
                  break;
                }
              }
              this._upperBodyBone = t;
            }
            prepare() {}
            get _computeTransformMatrices() {
              return !0;
            }
            set _computeTransformMatrices(e) {
              if (!0 === e) {
                this._skeleton.onBeforeComputeObservable.removeCallback(this._onBeforeCompute);
                const e = this._skeleton.bones;
                let t = 0;
                for (let n = 0; n < e.length; ++n) null !== e[n]._linkedTransformNode && (t += 1);
                this._skeleton._numBonesWithLinkedTransformNode = t;
              } else
                this._skeleton.onBeforeComputeObservable.add(this._onBeforeCompute),
                  (this._skeleton._numBonesWithLinkedTransformNode = 0);
            }
            _onBeforeCompute = () => {
              const e = this.bones,
                t = this._runtimeBones,
                n = this._upperBodyBone;
              for (let i = 0; i < e.length; ++i) null !== e[i].bone && e[i].computeBoneFinalMatrix(t, n);
              for (let t = 0; t < e.length; ++t) null !== e[t].bone && e[t].apply();
            };
          }
          class so {
            static _StandardSkeletonMetaData = [
              ["全ての親", -1, 0, 31, null, null],
              ["センター", 0, 0, 30, null, null],
              ["グルーブ", 1, 0, 30, null, null],
              ["腰", 2, 0, 26, null, null],
              ["右足IK親", 0, 0, 31, null, null],
              [
                "右足ＩＫ",
                4,
                1,
                62,
                null,
                {
                  target: 67,
                  iteration: 40,
                  rotationConstraint: 2,
                  links: [
                    {
                      target: 66,
                      limitation: {
                        minimumAngle: [-3.1415927410125732, 0, 0],
                        maximumAngle: [-0.008726646192371845, 0, 0],
                      },
                    },
                    { target: 65, limitation: void 0 },
                  ],
                },
              ],
              [
                "右つま先ＩＫ",
                5,
                2,
                62,
                null,
                { target: 72, iteration: 3, rotationConstraint: 4, links: [{ target: 67, limitation: void 0 }] },
              ],
              ["左足IK親", 0, 0, 31, null, null],
              [
                "左足ＩＫ",
                7,
                1,
                62,
                null,
                {
                  target: 71,
                  iteration: 40,
                  rotationConstraint: 2,
                  links: [
                    {
                      target: 70,
                      limitation: {
                        minimumAngle: [-3.1415927410125732, 0, 0],
                        maximumAngle: [-0.008726646192371845, 0, 0],
                      },
                    },
                    { target: 69, limitation: void 0 },
                  ],
                },
              ],
              [
                "左つま先ＩＫ",
                8,
                2,
                62,
                null,
                { target: 73, iteration: 3, rotationConstraint: 4, links: [{ target: 71, limitation: void 0 }] },
              ],
              ["上半身", 3, 0, 27, null, null],
              ["上半身2", 10, 0, 27, null, null],
              ["下半身", 3, 0, 26, null, null],
              ["首", 11, 0, 27, null, null],
              ["頭", 13, 0, 26, null, null],
              ["右肩P", 11, 0, 26, null, null],
              ["右肩", 15, 0, 2075, null, null],
              ["右肩C", 16, 0, 274, { parentIndex: 15, ratio: -1 }, null],
              ["右腕", 17, 0, 2075, null, null],
              ["右腕捩", 18, 0, 1050, null, null],
              ["右ひじ", 19, 0, 2075, null, null],
              ["右手捩", 20, 0, 1050, null, null],
              ["右手首", 21, 0, 2075, null, null],
              ["右親指０", 22, 0, 2079, null, null],
              ["右親指１", 23, 0, 2075, null, null],
              ["右親指２", 24, 0, 2075, null, null],
              ["右小指１", 22, 0, 2075, null, null],
              ["右小指２", 26, 0, 2075, null, null],
              ["右小指３", 27, 0, 2075, null, null],
              ["右薬指１", 22, 0, 2075, null, null],
              ["右薬指２", 29, 0, 2075, null, null],
              ["右薬指３", 30, 0, 2075, null, null],
              ["右中指１", 22, 0, 2075, null, null],
              ["右中指２", 32, 0, 2075, null, null],
              ["右中指３", 33, 0, 2075, null, null],
              ["右人指１", 22, 0, 2075, null, null],
              ["右人指２", 35, 0, 2075, null, null],
              ["右人指３", 36, 0, 2075, null, null],
              ["左肩P", 11, 0, 26, null, null],
              ["左肩", 38, 0, 2075, null, null],
              ["左肩C", 39, 0, 274, { parentIndex: 38, ratio: -1 }, null],
              ["左腕", 40, 0, 2075, null, null],
              ["左腕捩", 41, 0, 1050, null, null],
              ["左ひじ", 42, 0, 2075, null, null],
              ["左手捩", 43, 0, 1050, null, null],
              ["左手首", 44, 0, 2075, null, null],
              ["左親指０", 45, 0, 2079, null, null],
              ["左親指１", 46, 0, 2075, null, null],
              ["左親指２", 47, 0, 2075, null, null],
              ["左小指１", 45, 0, 2075, null, null],
              ["左小指２", 49, 0, 2075, null, null],
              ["左小指３", 50, 0, 2075, null, null],
              ["左薬指１", 45, 0, 2075, null, null],
              ["左薬指２", 52, 0, 2075, null, null],
              ["左薬指３", 53, 0, 2075, null, null],
              ["左中指１", 45, 0, 2075, null, null],
              ["左中指２", 55, 0, 2075, null, null],
              ["左中指３", 56, 0, 2075, null, null],
              ["左人指１", 45, 0, 2075, null, null],
              ["左人指２", 58, 0, 2075, null, null],
              ["左人指３", 59, 0, 2075, null, null],
              ["右目", 14, 2, 2330, { parentIndex: 63, ratio: 1 }, null],
              ["左目", 14, 2, 2330, { parentIndex: 63, ratio: 1 }, null],
              ["両目", 14, 0, 2074, null, null],
              ["腰キャンセル右", 12, 0, 274, { parentIndex: 3, ratio: -1 }, null],
              ["右足", 64, 0, 27, null, null],
              ["右ひざ", 65, 0, 27, null, null],
              ["右足首", 66, 0, 27, null, null],
              ["腰キャンセル左", 12, 0, 274, { parentIndex: 3, ratio: -1 }, null],
              ["左足", 68, 0, 27, null, null],
              ["左ひざ", 69, 0, 27, null, null],
              ["左足首", 70, 0, 27, null, null],
              ["右つま先", 67, 2, 18, null, null],
              ["左つま先", 71, 2, 18, null, null],
              ["右足D", 64, 1, 283, { parentIndex: 65, ratio: 1 }, null],
              ["右ひざD", 74, 1, 283, { parentIndex: 66, ratio: 1 }, null],
              ["右足首D", 75, 2, 282, { parentIndex: 67, ratio: 1 }, null],
              ["左足D", 68, 1, 283, { parentIndex: 69, ratio: 1 }, null],
              ["左ひざD", 77, 1, 283, { parentIndex: 70, ratio: 1 }, null],
              ["左足首D", 78, 2, 282, { parentIndex: 71, ratio: 1 }, null],
              ["右足先EX", 76, 2, 26, null, null],
              ["左足先EX", 79, 2, 26, null, null],
            ];
            _createMetadata(e, t, n, i) {
              const o = { modelName: e, englishModelName: e, comment: "", englishComment: "" },
                r = [],
                a = so._StandardSkeletonMetaData;
              for (let e = 0; e < a.length; ++e) {
                const t = a[e],
                  n = t[5],
                  i = {
                    name: t[0],
                    englishName: "",
                    parentBoneIndex: t[1],
                    transformOrder: t[2],
                    flag: t[3],
                    appendTransform: null !== t[4] ? { ...t[4] } : void 0,
                    ik:
                      null !== n
                        ? {
                            target: n.target,
                            iteration: n.iteration,
                            rotationConstraint: n.rotationConstraint,
                            links: n.links.map((e) => ({
                              target: e.target,
                              limitation: void 0 !== e.limitation ? { ...e.limitation } : void 0,
                            })),
                          }
                        : void 0,
                  };
                r.push(i);
              }
              const s = [];
              for (let e = 0; e < t.length; ++e) {
                const n = t[e];
                null !== n.morphTargetManager && s.push(n.morphTargetManager);
              }
              const l = new Map();
              for (let e = 0; e < s.length; ++e) {
                const t = s[e],
                  n = t.numTargets;
                for (let e = 0; e < n; ++e) {
                  const n = t.getTarget(e),
                    i = n.name;
                  let o = l.get(i);
                  void 0 === o && ((o = []), l.set(i, o)), o.push(n);
                }
              }
              const h = [];
              for (const [e, t] of l) {
                const i = n[e] ?? e,
                  o = {
                    name: i,
                    englishName: i,
                    category: y.Morph.Category.Eye,
                    type: y.Morph.Type.VertexMorph,
                    morphTargets: t,
                  };
                h.push(o);
              }
              return {
                isMmdModel: !0,
                header: o,
                bones: r,
                morphs: h,
                rigidBodies: [],
                joints: [],
                meshes: t,
                materials: [],
                skeleton: i,
              };
            }
            _removeScaleFromOffsetMatrix(e) {
              const t = new E.Vector3();
              e.decompose(t), (t.x = Math.abs(t.x)), (t.y = Math.abs(t.y)), (t.z = Math.abs(t.z));
              const n = e.m;
              return (
                e.setRowFromFloats(0, n[0] / t.x, n[1] / t.x, n[2] / t.x, n[3]),
                e.setRowFromFloats(1, n[4] / t.y, n[5] / t.y, n[6] / t.y, n[7]),
                e.setRowFromFloats(2, n[8] / t.z, n[9] / t.z, n[10] / t.z, n[11]),
                t
              );
            }
            _copyBonePosition(e, t, n) {
              const i = n.get(e),
                o = n.get(t);
              return void 0 === i || void 0 === o ? null : (o._position.copyFrom(i._position), o);
            }
            _getAverageBonePosition(e, t) {
              const n = E.Vector3.Zero();
              for (let i = 0; i < e.length; ++i) {
                const o = t.get(e[i]);
                if (void 0 === o) return null;
                n.addInPlace(o._position);
              }
              return n.scaleInPlace(1 / e.length);
            }
            _buildBoneProxyTree(e, t, n, i, o) {
              const r = i.clone(),
                a = this._removeScaleFromOffsetMatrix(r),
                s = new E.Vector3(1 / a.x, 1 / a.y, 1 / a.z),
                l = e.bones,
                h = new Set(),
                d = new Map();
              for (let e = 0; e < l.length; ++e) {
                const n = l[e],
                  i = t[n.name];
                void 0 !== i && d.set(i, n);
              }
              e.prepare(!0);
              const c = [],
                m = new Map();
              for (let e = 0; e < n.length; ++e) {
                const t = n[e],
                  i = d.get(t.name) ?? null,
                  o = new ro(e, t.name, i, s, r);
                null !== i && (i.getFinalMatrix().getTranslationToRef(o._position), h.add(o.name)),
                  c.push(o),
                  m.set(t.name, o);
              }
              for (let e = 0; e < n.length; ++e) {
                const t = n[e],
                  i = c[e],
                  o = t.parentBoneIndex;
                if (-1 !== o) {
                  const e = c[o];
                  (i.parent = e), e.children.push(i);
                }
              }
              h.has("全ての親") || ((m.get("全ての親")._position.y = 0.1 * s.y), h.add("全ての親"));
              {
                const e = h.has("センター"),
                  t = h.has("グルーブ");
                if (e || t)
                  e
                    ? t || (null !== this._copyBonePosition("センター", "グルーブ", m) && h.add("グルーブ"))
                    : null !== this._copyBonePosition("グルーブ", "センター", m) && h.add("センター");
                else {
                  const e = this._getAverageBonePosition(["左足", "左ひざ", "右足", "右ひざ"], m);
                  null !== e &&
                    (m.get("センター")._position.copyFrom(e),
                    m.get("グルーブ")._position.copyFrom(e),
                    h.add("センター"),
                    h.add("グルーブ"));
                }
              }
              {
                const e = h.has("上半身"),
                  t = h.has("下半身"),
                  n = h.has("腰");
                if (e || t || n)
                  e
                    ? t || (null !== this._copyBonePosition(e ? "上半身" : "腰", "下半身", m) && h.add("下半身"))
                    : null !== this._copyBonePosition(t ? "下半身" : "腰", "上半身", m) && h.add("上半身");
                else {
                  const e = this._getAverageBonePosition(["左足", "左足", "右足", "右足", "首"], m);
                  null !== e &&
                    (m.get("上半身")._position.copyFrom(e),
                    m.get("下半身")._position.copyFrom(e),
                    m.get("腰")._position.copyFrom(e),
                    h.add("上半身"),
                    h.add("下半身"),
                    h.add("腰"));
                }
                n || (null !== this._copyBonePosition(t ? "下半身" : "上半身", "腰", m) && h.add("腰"));
              }
              if (!h.has("両目")) {
                const e = this._getAverageBonePosition(["右目", "左目"], m);
                if (null !== e) {
                  const t = m.get("両目");
                  t._position.copyFrom(e);
                  const n = m.get("頭")._position.y - t._position.y;
                  (t._position.y -= 2 * n), h.add("両目");
                }
              }
              if (
                (h.has("右肩P") || (null !== this._copyBonePosition("右肩", "右肩P", m) && h.add("右肩P")),
                h.has("右肩C") || (null !== this._copyBonePosition("右腕", "右肩C", m) && h.add("右肩C")),
                h.has("左肩P") || (null !== this._copyBonePosition("左肩", "左肩P", m) && h.add("左肩P")),
                h.has("左肩C") || (null !== this._copyBonePosition("左腕", "左肩C", m) && h.add("左肩C")),
                !h.has("右腕捩"))
              ) {
                const e = this._getAverageBonePosition(["右腕", "右ひじ"], m);
                null !== e && (m.get("右腕捩")._position.copyFrom(e), h.add("右腕捩"));
              }
              if (!h.has("右手捩")) {
                const e = this._getAverageBonePosition(["右ひじ", "右手首"], m);
                null !== e && (m.get("右手捩")._position.copyFrom(e), h.add("右手捩"));
              }
              if (!h.has("左腕捩")) {
                const e = this._getAverageBonePosition(["左腕", "左ひじ"], m);
                null !== e && (m.get("左腕捩")._position.copyFrom(e), h.add("左腕捩"));
              }
              if (!h.has("左手捩")) {
                const e = this._getAverageBonePosition(["左ひじ", "左手首"], m);
                null !== e && (m.get("左手捩")._position.copyFrom(e), h.add("左手捩"));
              }
              if (
                (h.has("腰キャンセル右") ||
                  (null !== this._copyBonePosition("右足", "腰キャンセル右", m) && h.add("腰キャンセル右")),
                h.has("腰キャンセル左") ||
                  (null !== this._copyBonePosition("左足", "腰キャンセル左", m) && h.add("腰キャンセル左")),
                h.has("右足ＩＫ") || (null !== this._copyBonePosition("右足首", "右足ＩＫ", m) && h.add("右足ＩＫ")),
                !h.has("右足IK親"))
              ) {
                const e = this._copyBonePosition("右足首", "右足IK親", m);
                null !== e && ((e._position.y = 0.1 * s.y), h.add("右足IK親"));
              }
              if (
                (h.has("右つま先ＩＫ") ||
                  (null !== this._copyBonePosition("右つま先", "右つま先ＩＫ", m) && h.add("右つま先ＩＫ")),
                h.has("左足ＩＫ") || (null !== this._copyBonePosition("左足首", "左足ＩＫ", m) && h.add("左足ＩＫ")),
                !h.has("左足IK親"))
              ) {
                const e = this._copyBonePosition("左足首", "左足IK親", m);
                null !== e && ((e._position.y = 0.1 * s.y), h.add("左足IK親"));
              }
              h.has("左つま先ＩＫ") ||
                (null !== this._copyBonePosition("左つま先", "左つま先ＩＫ", m) && h.add("左つま先ＩＫ")),
                h.has("右足D") || (null !== this._copyBonePosition("右足", "右足D", m) && h.add("右足D")),
                h.has("右ひざD") || (null !== this._copyBonePosition("右ひざ", "右ひざD", m) && h.add("右ひざD")),
                h.has("右足首D") || (null !== this._copyBonePosition("右足首", "右足首D", m) && h.add("右足首D")),
                h.has("右足先EX") || (null !== this._copyBonePosition("右つま先", "右足先EX", m) && h.add("右足先EX")),
                h.has("左足D") || (null !== this._copyBonePosition("左足", "左足D", m) && h.add("左足D")),
                h.has("左ひざD") || (null !== this._copyBonePosition("左ひざ", "左ひざD", m) && h.add("左ひざD")),
                h.has("左足首D") || (null !== this._copyBonePosition("左足首", "左足首D", m) && h.add("左足首D")),
                h.has("左足先EX") || (null !== this._copyBonePosition("左つま先", "左足先EX", m) && h.add("左足先EX"));
              for (let e = 0; e < c.length; ++e) {
                const t = c[e];
                t._position.multiplyInPlace(a), E.Vector3.TransformCoordinatesToRef(t._position, r, t._position);
              }
              let u = c.length - h.size;
              for (; 0 < u; )
                for (let e = 0; e < c.length; ++e) {
                  const t = c[e];
                  if (h.has(t.name)) continue;
                  const n = t.parent;
                  null !== n &&
                    h.has(n.name) &&
                    (t._position.copyFrom(n._position),
                    h.add(t.name),
                    (u -= 1),
                    o.warn(
                      `Bone position of ${t.name} is not initialized. Use parent bone position instead. Animation may not work correctly.`
                    ));
                }
              const p = new Map();
              for (let e = 0; e < c.length; ++e) p.set(c[e], c[e]._position.clone());
              for (let e = 0; e < c.length; ++e) {
                const t = c[e],
                  n = t.parent;
                if (null !== n) {
                  const e = p.get(n);
                  t._position.subtractInPlace(e);
                }
                t.getRestMatrix().setTranslation(t._position), t.updateBoneParent();
              }
              return c;
            }
            createMmdModelFromHumanoid(e, t, n, i = {}) {
              const { boneMap: o = {}, morphMap: r = {}, transformOffset: a = E.Matrix.Identity() } = i;
              let s = null;
              for (let e = 0; e < n.length; ++e) {
                const t = n[e];
                if (null !== t.skeleton) {
                  s = t.skeleton;
                  break;
                }
              }
              if (null === s) throw new Error("Skeleton not found.");
              const l = this._createMetadata(t.name, n.slice(), r, s);
              if (((t.metadata = l), !gt.isMmdSkinnedMesh(t))) throw new Error("Mesh validation failed.");
              let h;
              h =
                void 0 !== a.getWorldMatrix
                  ? a.computeWorldMatrix(!0).clone().setTranslationFromFloats(0, 0, 0)
                  : a.clone().setTranslationFromFloats(0, 0, 0);
              const d = this._buildBoneProxyTree(s, o, l.bones, h, e),
                c = new ao(d, s),
                m = e.createMmdModelFromSkeleton(t, c, { materialProxyConstructor: null, buildPhysics: !1 });
              return c.lateInitialize(m.runtimeBones), m;
            }
          }
          !(function (e) {
            (e[(e.Seconds = 0)] = "Seconds"), (e[(e.Frames = 1)] = "Frames");
          })(Zi || (Zi = {}));
          class lo {
            autoHidePlayerControl;
            hidePlayerControlTimeout;
            displayTimeFormat;
            _mmdRuntime;
            _audioPlayer;
            _newCanvasContainer;
            _playerContainer;
            _hidePlayerControlTimeoutId;
            _playButton;
            _timeSlider;
            _soundButton;
            _volumeSlider;
            _currentFrameNumberSpan;
            _endFrameNumberSpan;
            _speedSlider;
            _fullscreenButton;
            _bindedDispose;
            _scene;
            constructor(e, t, n) {
              const i = e.getEngine().getInputElement();
              if (null === i) throw new Error("Failed to get root element.");
              (this.autoHidePlayerControl = !0),
                (this.hidePlayerControlTimeout = 3e3),
                (this.displayTimeFormat = Zi.Seconds),
                (this._mmdRuntime = t),
                (this._audioPlayer = n ?? null);
              const o = (this._newCanvasContainer = this._createCanvasContainer(i.parentElement));
              (this._playerContainer = null),
                (this._hidePlayerControlTimeoutId = void 0),
                (this._playButton = null),
                (this._timeSlider = null),
                (this._soundButton = null),
                (this._volumeSlider = null),
                (this._currentFrameNumberSpan = null),
                (this._endFrameNumberSpan = null),
                (this._speedSlider = null),
                (this._fullscreenButton = null),
                this._createPlayerControl(o, t, n),
                t.onPlayAnimationObservable.add(this._onAnimationPlay),
                t.onPauseAnimationObservable.add(this._onAnimationPause),
                t.onAnimationDurationChangedObservable.add(this._onAnimationDurationChanged),
                t.onAnimationTickObservable.add(this._onAnimationTick),
                n?.onMuteStateChangedObservable.add(this._onMuteStateChanged),
                (this._bindedDispose = this.dispose.bind(this)),
                (this._scene = e),
                e.onDisposeObservable.add(this._bindedDispose);
            }
            _createCanvasContainer(e) {
              const t = e.ownerDocument.createElement("div");
              for (t.style.display = e.style.display; e.childElementCount > 0; ) {
                const n = e.childNodes[0];
                e.removeChild(n), t.appendChild(n);
              }
              return (
                e.appendChild(t), (t.style.width = "100%"), (t.style.height = "100%"), (t.style.overflow = "hidden"), t
              );
            }
            _restoreCanvasContainer(e) {
              const t = this._newCanvasContainer;
              for (; t.childElementCount > 0; ) {
                const n = t.childNodes[0];
                t.removeChild(n), e.appendChild(n);
              }
              e.removeChild(t);
            }
            _createPlayerControl(e, t, n) {
              const i = e.ownerDocument,
                o = (this._playerContainer = i.createElement("div"));
              (o.style.position = "relative"),
                (o.style.bottom = "120px"),
                (o.style.left = "0"),
                (o.style.width = "100%"),
                (o.style.height = "120px"),
                (o.style.transform = "translateY(50%)"),
                (o.style.transition = "transform 0.5s"),
                e.appendChild(o),
                (o.onmouseenter = this._onPlayerControlMouseEnter),
                (o.onmouseleave = this._onPlayerControlMouseLeave);
              {
                const r = i.createElement("div");
                (r.style.position = "absolute"),
                  (r.style.bottom = "0"),
                  (r.style.left = "0"),
                  (r.style.width = "100%"),
                  (r.style.height = "50%"),
                  (r.style.boxSizing = "border-box"),
                  (r.style.background = "linear-gradient(rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.6))"),
                  (r.style.display = "flex"),
                  (r.style.flexDirection = "column"),
                  o.appendChild(r);
                {
                  const o = i.createElement("div");
                  (o.style.width = "100%"),
                    (o.style.boxSizing = "border-box"),
                    (o.style.display = "flex"),
                    (o.style.flexDirection = "row"),
                    (o.style.alignItems = "center"),
                    r.appendChild(o);
                  {
                    const e = (this._timeSlider = i.createElement("input"));
                    (e.style.width = "100%"),
                      (e.style.height = "4px"),
                      (e.style.border = "none"),
                      (e.style.opacity = "0.5"),
                      (e.type = "range"),
                      (e.min = "0"),
                      (e.max = t.animationFrameTimeDuration.toString()),
                      (e.oninput = (n) => {
                        n.preventDefault(), t.seekAnimation(Number(e.value), !0);
                      });
                    {
                      let n = !1;
                      (e.onmousedown = () => {
                        t.isAnimationPlaying && (t.pauseAnimation(), (n = !0));
                      }),
                        (e.onmouseup = () => {
                          n && (t.playAnimation(), (n = !1));
                        });
                    }
                    o.appendChild(e);
                  }
                  const a = i.createElement("div");
                  (a.style.width = "100%"),
                    (a.style.flexGrow = "1"),
                    (a.style.padding = "0 5px"),
                    (a.style.boxSizing = "border-box"),
                    (a.style.display = "flex"),
                    (a.style.flexDirection = "row"),
                    (a.style.alignItems = "space-between"),
                    r.appendChild(a);
                  {
                    const o = i.createElement("div");
                    (o.style.flex = "1"),
                      (o.style.display = "flex"),
                      (o.style.flexDirection = "row"),
                      (o.style.alignItems = "center"),
                      a.appendChild(o);
                    {
                      const e = (this._playButton = i.createElement("button"));
                      if (
                        ((e.style.width = "40px"),
                        (e.style.border = "none"),
                        (e.style.backgroundColor = "rgba(0, 0, 0, 0)"),
                        (e.style.color = "white"),
                        (e.style.fontSize = "18px"),
                        (e.innerText = t.isAnimationPlaying ? "❚❚" : "▶"),
                        (e.onclick = () => {
                          t.isAnimationPlaying ? t.pauseAnimation() : t.playAnimation();
                        }),
                        o.appendChild(e),
                        void 0 !== n)
                      ) {
                        const e = (this._soundButton = i.createElement("button"));
                        (e.style.width = "35px"),
                          (e.style.border = "none"),
                          (e.style.backgroundColor = "rgba(0, 0, 0, 0)"),
                          (e.style.color = "white"),
                          (e.style.fontSize = "20px"),
                          (e.innerText = n.muted ? "🔇" : "🔊"),
                          (e.onclick = () => {
                            n.muted ? n.unmute() : n.mute();
                          }),
                          o.appendChild(e);
                        const t = (this._volumeSlider = i.createElement("input"));
                        (t.style.width = "80px"),
                          (t.style.height = "4px"),
                          (t.style.border = "none"),
                          (t.style.opacity = "0.5"),
                          (t.type = "range"),
                          (t.min = "0"),
                          (t.max = "1"),
                          (t.step = "0.01"),
                          (t.value = n.volume.toString()),
                          (t.oninput = () => {
                            n.volume = Number(t.value);
                          }),
                          o.appendChild(t);
                      }
                      const r = (this._currentFrameNumberSpan = i.createElement("span"));
                      (r.style.width = "40px"),
                        (r.style.textAlign = "right"),
                        (r.style.color = "white"),
                        (r.innerText =
                          this.displayTimeFormat === Zi.Seconds
                            ? this._getFormattedTime(t.currentTime)
                            : Math.floor(t.currentFrameTime).toString()),
                        o.appendChild(r);
                      const a = (this._endFrameNumberSpan = i.createElement("span"));
                      (a.style.width = "50px"),
                        (a.style.textAlign = "left"),
                        (a.style.color = "white"),
                        (a.innerHTML =
                          "&nbsp;/&nbsp;" +
                          (this.displayTimeFormat === Zi.Seconds
                            ? this._getFormattedTime(t.animationDuration)
                            : Math.floor(t.animationFrameTimeDuration).toString())),
                        o.appendChild(a);
                    }
                    const r = i.createElement("div");
                    (r.style.flex = "1"),
                      (r.style.display = "flex"),
                      (r.style.flexDirection = "row"),
                      (r.style.alignItems = "center"),
                      (r.style.justifyContent = "flex-end"),
                      a.appendChild(r);
                    {
                      const n = i.createElement("label");
                      (n.style.width = "40px"),
                        (n.style.textAlign = "center"),
                        (n.style.color = "white"),
                        (n.innerText = "1.00x"),
                        r.appendChild(n);
                      const o = (this._speedSlider = i.createElement("input"));
                      (o.style.width = "80px"),
                        (o.style.height = "4px"),
                        (o.style.border = "none"),
                        (o.style.opacity = "0.5"),
                        (o.type = "range"),
                        (o.min = "0.07"),
                        (o.max = "1"),
                        (o.step = "0.01"),
                        (o.value = t.timeScale.toString()),
                        (o.oninput = () => {
                          (t.timeScale = Number(o.value)), (n.innerText = t.timeScale.toFixed(2) + "x");
                        }),
                        r.appendChild(o);
                      const a = (this._fullscreenButton = i.createElement("button"));
                      (a.style.width = "40px"),
                        (a.style.border = "none"),
                        (a.style.color = "white"),
                        (a.style.backgroundColor = "rgba(0, 0, 0, 0)"),
                        (a.style.fontSize = "20px"),
                        (a.innerText = "🗖"),
                        (a.onclick = () => {
                          i.fullscreenElement ? i.exitFullscreen() : e.requestFullscreen();
                        }),
                        r.appendChild(a);
                    }
                  }
                }
              }
            }
            _onPlayerControlMouseEnter = () => {
              this.autoHidePlayerControl &&
                (window.clearTimeout(this._hidePlayerControlTimeoutId),
                (this._hidePlayerControlTimeoutId = void 0),
                this.showPlayerControl());
            };
            _onPlayerControlMouseLeave = () => {
              this.autoHidePlayerControl &&
                (this._hidePlayerControlTimeoutId = window.setTimeout(
                  this.hidePlayerControl.bind(this),
                  this.hidePlayerControlTimeout
                ));
            };
            _onAnimationPlay = () => {
              this._playButton.innerText = "❚❚";
            };
            _onAnimationPause = () => {
              this._playButton.innerText = "▶";
            };
            _onAnimationDurationChanged = () => {
              const e = this._mmdRuntime;
              (this._timeSlider.max = e.animationFrameTimeDuration.toString()),
                (this._endFrameNumberSpan.innerHTML =
                  "&nbsp;/&nbsp;" +
                  (this.displayTimeFormat === Zi.Seconds
                    ? this._getFormattedTime(e.animationDuration)
                    : Math.floor(e.animationFrameTimeDuration).toString()));
            };
            _onAnimationTick = () => {
              const e = this._mmdRuntime;
              if (((this._timeSlider.value = e.currentFrameTime.toString()), this.displayTimeFormat === Zi.Seconds)) {
                const t = this._getFormattedTime(e.currentTime);
                this._currentFrameNumberSpan.innerText !== t && (this._currentFrameNumberSpan.innerText = t);
              } else this._currentFrameNumberSpan.innerText = Math.floor(e.currentFrameTime).toString();
            };
            _onMuteStateChanged = () => {
              null !== this._soundButton && (this._soundButton.innerText = this._audioPlayer.muted ? "🔇" : "🔊");
            };
            _formattedTimeCacheKey = NaN;
            _formatterTimeCacheValue = "";
            _getFormattedTime(e) {
              const t = Math.floor(e);
              if (t === this._formattedTimeCacheKey) return this._formatterTimeCacheValue;
              if (!isFinite(e))
                return (this._formattedTimeCacheKey = t), (this._formatterTimeCacheValue = "-:--"), "-:--";
              const n = Math.floor(e / 60),
                i = Math.floor(e % 60),
                o = n.toString() + ":" + (i < 10 ? "0" : "") + i.toString();
              return (this._formattedTimeCacheKey = t), (this._formatterTimeCacheValue = o), o;
            }
            hidePlayerControl() {
              (this._playerContainer.style.transform = "translateY(50%)"), (this._hidePlayerControlTimeoutId = void 0);
            }
            showPlayerControl() {
              this._playerContainer.style.transform = "translateY(0)";
            }
            dispose() {
              null !== this._newCanvasContainer &&
                (this._restoreCanvasContainer(this._newCanvasContainer.parentElement),
                (this._newCanvasContainer = null),
                (this._playButton.onclick = null),
                (this._timeSlider.oninput = null),
                (this._timeSlider.onmousedown = null),
                (this._timeSlider.onmouseup = null),
                null !== this._audioPlayer && ((this._soundButton.onclick = null), (this._volumeSlider.oninput = null)),
                (this._speedSlider.oninput = null),
                (this._fullscreenButton.onclick = null),
                (this._playerContainer.onmouseenter = null),
                (this._playerContainer.onmouseleave = null),
                this._playerContainer.remove(),
                this._mmdRuntime.onPlayAnimationObservable.removeCallback(this._onAnimationPlay),
                this._mmdRuntime.onPauseAnimationObservable.removeCallback(this._onAnimationPause),
                this._mmdRuntime.onAnimationDurationChangedObservable.removeCallback(this._onAnimationDurationChanged),
                this._mmdRuntime.onAnimationTickObservable.removeCallback(this._onAnimationTick),
                this._audioPlayer?.onMuteStateChangedObservable.removeCallback(this._onMuteStateChanged),
                this._scene.onDisposeObservable.removeCallback(this._bindedDispose));
            }
          }
          var ho = H(1068);
          class co extends ho.Camera {
            ignoreParentScaling = !1;
            rotation = new E.Vector3();
            distance = -45;
            _viewMatrix = E.Matrix.Zero();
            _tmpUpVector = E.Vector3.Zero();
            _tmpTargetVector = E.Vector3.Zero();
            onCurrentAnimationChangedObservable;
            _animations;
            _animationIndexMap;
            _currentAnimation;
            constructor(e, t = new E.Vector3(0, 10, 0), n, i = !0) {
              super(e, t, n, i),
                (this.fov = (Math.PI / 180) * 30),
                (this.onCurrentAnimationChangedObservable = new U.Observable()),
                (this._animations = []),
                (this._animationIndexMap = new Map()),
                (this._currentAnimation = null);
            }
            addAnimation(e) {
              let t;
              if (!e.createRuntimeCameraAnimation)
                throw new Error(
                  'animation is not MmdAnimation or MmdCameraAnimationGroup or MmdCompositeAnimation. are you missing import "babylon-mmd/esm/Runtime/Animation/mmdRuntimeCameraAnimation" or "babylon-mmd/esm/Runtime/Animation/mmdRuntimeCameraAnimationGroup" or "babylon-mmd/esm/Runtime/Animation/mmdCompositeRuntimeCameraAnimation"?'
                );
              (t = e.createRuntimeCameraAnimation(this)),
                this._animationIndexMap.set(e.name, this._animations.length),
                this._animations.push(t);
            }
            removeAnimation(e) {
              const t = this._animations[e];
              this._currentAnimation === t && (this._currentAnimation = null),
                this._animationIndexMap.delete(t.animation.name),
                this._animations.splice(e, 1),
                t.dispose?.();
            }
            setAnimation(e) {
              if (null === e)
                return void (
                  null !== this._currentAnimation &&
                  ((this._currentAnimation = null), this.onCurrentAnimationChangedObservable.notifyObservers(null))
                );
              const t = this._animationIndexMap.get(e);
              if (void 0 === t) throw new Error(`Animation ${e} is not found`);
              (this._currentAnimation = this._animations[t]),
                this.onCurrentAnimationChangedObservable.notifyObservers(this._currentAnimation);
            }
            get runtimeAnimations() {
              return this._animations;
            }
            get currentAnimation() {
              return this._currentAnimation;
            }
            animate(e) {
              null !== this._currentAnimation && this._currentAnimation.animate(e);
            }
            _storedPosition = null;
            _storedRotation = null;
            _storedDistance = 0;
            storeState() {
              return (
                (this._storedPosition = this.position.clone()),
                (this._storedRotation = this.rotation.clone()),
                (this._storedDistance = this.distance),
                super.storeState()
              );
            }
            _restoreStateValues() {
              return (
                !!super._restoreStateValues() &&
                ((this.position = this._storedPosition.clone()),
                (this.rotation = this._storedRotation.clone()),
                (this.distance = this._storedDistance),
                !0)
              );
            }
            _initCache() {
              super._initCache(),
                (this._cache.rotation = new E.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)),
                (this._cache.distance = Number.MAX_VALUE);
            }
            _updateCache(e) {
              e || super._updateCache(),
                this._cache.rotation.copyFrom(this.rotation),
                (this._cache.distance = this.distance);
            }
            _isSynchronizedViewMatrix() {
              return (
                !!super._isSynchronizedViewMatrix() &&
                this._cache.rotation.equals(this.rotation) &&
                this._cache.distance === this.distance
              );
            }
            static _RotationMatrix = new E.Matrix();
            static _CameraEyePosition = new E.Vector3();
            static _UpVector = new E.Vector3();
            static _TargetVector = new E.Vector3();
            _getViewMatrix() {
              const e = E.Matrix.RotationYawPitchRollToRef(
                  -this.rotation.y,
                  -this.rotation.x,
                  -this.rotation.z,
                  co._RotationMatrix
                ),
                t = this.position.addToRef(
                  E.Vector3.TransformCoordinatesFromFloatsToRef(0, 0, this.distance, e, co._CameraEyePosition),
                  co._CameraEyePosition
                ),
                n = E.Vector3.TransformNormalFromFloatsToRef(0, 0, 1, e, co._TargetVector).addInPlace(t),
                i = E.Vector3.TransformNormalFromFloatsToRef(0, 1, 0, e, co._UpVector);
              if (this.ignoreParentScaling) {
                if (this.parent) {
                  const e = this.parent.getWorldMatrix();
                  E.Vector3.TransformCoordinatesToRef(t, e, this._globalPosition),
                    E.Vector3.TransformCoordinatesToRef(n, e, this._tmpTargetVector),
                    E.Vector3.TransformNormalToRef(i, e, this._tmpUpVector),
                    this._markSyncedWithParent();
                } else
                  this._globalPosition.copyFrom(t), this._tmpTargetVector.copyFrom(n), this._tmpUpVector.copyFrom(i);
                return (
                  this.getScene().useRightHandedSystem
                    ? E.Matrix.LookAtRHToRef(
                        this._globalPosition,
                        this._tmpTargetVector,
                        this._tmpUpVector,
                        this._viewMatrix
                      )
                    : E.Matrix.LookAtLHToRef(
                        this._globalPosition,
                        this._tmpTargetVector,
                        this._tmpUpVector,
                        this._viewMatrix
                      ),
                  this._viewMatrix
                );
              }
              if (
                (this.getScene().useRightHandedSystem
                  ? E.Matrix.LookAtRHToRef(t, n, i, this._viewMatrix)
                  : E.Matrix.LookAtLHToRef(t, n, i, this._viewMatrix),
                this.parent)
              ) {
                const e = this.parent.getWorldMatrix();
                this._viewMatrix.invert(),
                  this._viewMatrix.multiplyToRef(e, this._viewMatrix),
                  this._viewMatrix.getTranslationToRef(this._globalPosition),
                  this._viewMatrix.invert(),
                  this._markSyncedWithParent();
              } else this._globalPosition.copyFrom(t);
              return this._viewMatrix;
            }
            getClassName() {
              return "MmdCamera";
            }
          }
          class mo {
            isLocal;
            affectRotation;
            affectPosition;
            ratio;
            targetBone;
            appendPositionOffset = E.Vector3.Zero();
            appendRotationOffset = E.Quaternion.Identity();
            constructor(e, t, n) {
              (this.isLocal = 0 != (e & y.Bone.Flag.LocalAppendTransform)),
                (this.affectRotation = 0 != (e & y.Bone.Flag.HasAppendRotate)),
                (this.affectPosition = 0 != (e & y.Bone.Flag.HasAppendMove)),
                (this.ratio = t.ratio),
                (this.targetBone = n);
            }
            static _IdentityQuaternion = E.Quaternion.Identity();
            update() {
              const e = this.targetBone;
              if (this.affectRotation) {
                const t = this.appendRotationOffset;
                this.isLocal
                  ? e.getAnimatedRotationToRef(t)
                  : null !== e.appendTransformSolver
                  ? t.copyFrom(e.appendTransformSolver.appendRotationOffset)
                  : e.getAnimatedRotationToRef(t),
                  null !== e.ikRotation && e.ikRotation.multiplyToRef(t, t),
                  E.Quaternion.SlerpToRef(mo._IdentityQuaternion, t, this.ratio, t);
              }
              if (this.affectPosition) {
                const t = this.appendPositionOffset;
                this.isLocal
                  ? e.getAnimationPositionOffsetToRef(t)
                  : null !== e.appendTransformSolver
                  ? t.copyFrom(e.appendTransformSolver.appendPositionOffset)
                  : e.getAnimationPositionOffsetToRef(t),
                  t.scaleInPlace(this.ratio);
              }
            }
          }
          class uo {
            bone;
            minimumAngle;
            maximumAngle;
            prevAngle;
            savedIkRotation;
            planeModeAngle;
            constructor(e, t, n) {
              (this.bone = e),
                (this.minimumAngle = t),
                (this.maximumAngle = n),
                (this.prevAngle = E.Vector3.Zero()),
                (this.savedIkRotation = E.Quaternion.Identity()),
                (this.planeModeAngle = 0);
            }
          }
          class po {
            index;
            iteration;
            limitAngle;
            ikBone;
            targetBone;
            _ikChains;
            constructor(e, t, n) {
              (this.index = e),
                (this.iteration = 0),
                (this.limitAngle = 0),
                (this.ikBone = t),
                (this.targetBone = n),
                (this._ikChains = []);
            }
            addIkChain(e, t, n) {
              e.ikRotation = E.Quaternion.Identity();
              const i = new uo(e, t, n);
              this._ikChains.push(i);
            }
            static _TargetPosition = new E.Vector3();
            static _IkPosition = new E.Vector3();
            solve() {
              const e = this.ikBone,
                t = this.targetBone,
                n = this._ikChains;
              for (let e = 0; e < n.length; ++e) {
                const t = n[e],
                  i = t.bone;
                t.prevAngle.setAll(0),
                  i.ikRotation.set(0, 0, 0, 1),
                  (t.planeModeAngle = 0),
                  i.updateLocalMatrix(),
                  i.updateWorldMatrix();
              }
              let i = Number.MAX_VALUE;
              for (let o = 0; o < this.iteration; ++o) {
                this._solveCore(o);
                const r = t.getWorldTranslationToRef(po._TargetPosition),
                  a = e.getWorldTranslationToRef(po._IkPosition),
                  s = E.Vector3.DistanceSquared(r, a);
                if (!(s < i)) {
                  for (let e = 0; e < n.length; ++e) {
                    const t = n[e];
                    t.bone.ikRotation.copyFrom(t.savedIkRotation),
                      t.bone.updateLocalMatrix(),
                      t.bone.updateWorldMatrix();
                  }
                  break;
                }
                i = s;
                for (let e = 0; e < n.length; ++e) {
                  const t = n[e];
                  t.savedIkRotation.copyFrom(t.bone.ikRotation);
                }
              }
            }
            static _TargetPosition2 = new E.Vector3();
            static _IkPosition2 = new E.Vector3();
            static _InversedChain = new E.Matrix();
            static _ChainCross = new E.Vector3();
            static _Rotation = new E.Quaternion();
            static _ChainRotation = new E.Quaternion();
            static _AnimatedRotation = new E.Quaternion();
            static _ChainRotationMatrix = new E.Matrix();
            static _DecomposedRotation = new E.Vector3();
            static _ClampedRotation = new E.Vector3();
            static _FinalRotationA = new E.Quaternion();
            static _FinalRotationB = new E.Quaternion();
            static _Right = E.Vector3.Right();
            static _Up = E.Vector3.Up();
            static _Forward = E.Vector3.Forward();
            static _InversedAnimatedRotation = new E.Quaternion();
            static _RadToDeg = 180 / Math.PI;
            _solveCore(e) {
              const t = this.ikBone.getWorldTranslationToRef(po._IkPosition2),
                n = this._ikChains;
              for (let i = 0; i < n.length; ++i) {
                const o = n[i],
                  r = o.bone;
                if (r === this.targetBone) continue;
                if (null !== o.minimumAngle) {
                  if (
                    !(
                      (0 === o.minimumAngle.x && 0 === o.maximumAngle.x) ||
                      (0 !== o.minimumAngle.y && 0 !== o.maximumAngle.y) ||
                      (0 !== o.minimumAngle.z && 0 !== o.maximumAngle.z)
                    )
                  ) {
                    this._solvePlane(e, o, 0);
                    continue;
                  }
                  if (
                    !(
                      (0 === o.minimumAngle.y && 0 === o.maximumAngle.y) ||
                      (0 !== o.minimumAngle.x && 0 !== o.maximumAngle.x) ||
                      (0 !== o.minimumAngle.z && 0 !== o.maximumAngle.z)
                    )
                  ) {
                    this._solvePlane(e, o, 1);
                    continue;
                  }
                  if (
                    !(
                      (0 === o.minimumAngle.z && 0 === o.maximumAngle.z) ||
                      (0 !== o.minimumAngle.x && 0 !== o.maximumAngle.x) ||
                      (0 !== o.minimumAngle.y && 0 !== o.maximumAngle.y)
                    )
                  ) {
                    this._solvePlane(e, o, 2);
                    continue;
                  }
                }
                const a = this.targetBone.getWorldTranslationToRef(po._TargetPosition2),
                  s = r.getWorldMatrixToRef(po._InversedChain).invert(),
                  l = E.Vector3.TransformCoordinatesToRef(t, s, po._IkPosition),
                  h = E.Vector3.TransformCoordinatesToRef(a, s, po._TargetPosition),
                  d = l.normalize(),
                  c = h.normalize();
                let m = E.Vector3.Dot(c, d);
                m = Math.max(-1, Math.min(1, m));
                let u = Math.acos(m);
                if (u * po._RadToDeg < 0.001) continue;
                u = Math.max(-this.limitAngle, Math.min(this.limitAngle, u));
                const p = E.Vector3.CrossToRef(c, d, po._ChainCross).normalize(),
                  g = E.Quaternion.RotationAxisToRef(p, u, po._Rotation),
                  f = po._ChainRotation.copyFrom(r.ikRotation),
                  _ = r.getAnimatedRotationToRef(po._AnimatedRotation);
                if ((f.multiplyInPlace(_).multiplyInPlace(g), null !== o.minimumAngle)) {
                  const e = f.toRotationMatrix(po._ChainRotationMatrix),
                    t = this._decomposeToRef(e, o.prevAngle, po._DecomposedRotation),
                    n = E.Vector3.ClampToRef(t, o.minimumAngle, o.maximumAngle, po._ClampedRotation).subtractInPlace(
                      o.prevAngle
                    );
                  n.set(
                    Math.max(-this.limitAngle, Math.min(this.limitAngle, n.x)) + o.prevAngle.x,
                    Math.max(-this.limitAngle, Math.min(this.limitAngle, n.y)) + o.prevAngle.y,
                    Math.max(-this.limitAngle, Math.min(this.limitAngle, n.z)) + o.prevAngle.z
                  );
                  const i = E.Quaternion.RotationAxisToRef(po._Right, n.x, po._FinalRotationA),
                    r = po._FinalRotationB;
                  E.Quaternion.RotationAxisToRef(po._Up, n.y, r),
                    i.multiplyInPlace(r),
                    E.Quaternion.RotationAxisToRef(po._Forward, n.z, r),
                    i.multiplyInPlace(r),
                    E.Matrix.FromQuaternionToRef(i, e),
                    o.prevAngle.copyFrom(n),
                    E.Quaternion.FromRotationMatrixToRef(e, f);
                }
                f.multiplyToRef(E.Quaternion.InverseToRef(_, po._InversedAnimatedRotation), r.ikRotation),
                  r.updateLocalMatrix(),
                  r.updateWorldMatrix();
              }
            }
            static _IkPosition3 = new E.Vector3();
            static _TargetPosition3 = new E.Vector3();
            static _InversedChain2 = new E.Matrix();
            static _ChainIkPosition = new E.Vector3();
            static _ChainTargetPosition = new E.Vector3();
            static _Rotation2 = new E.Quaternion();
            static _TargetVector = new E.Vector3();
            static _InversedAnimatedRotation2 = new E.Quaternion();
            _solvePlane(e, t, n) {
              let i, o, r;
              switch (n) {
                case 0:
                  (i = t.minimumAngle.x), (o = t.maximumAngle.x), (r = po._Right);
                  break;
                case 1:
                  (i = t.minimumAngle.y), (o = t.maximumAngle.y), (r = po._Up);
                  break;
                case 2:
                  (i = t.minimumAngle.z), (o = t.maximumAngle.z), (r = po._Forward);
                  break;
                default:
                  throw new Error("Invalid solve axis");
              }
              const a = this.ikBone.getWorldTranslationToRef(po._IkPosition3),
                s = this.targetBone.getWorldTranslationToRef(po._TargetPosition3),
                l = t.bone.getWorldMatrixToRef(po._InversedChain2).invert(),
                h = E.Vector3.TransformCoordinatesToRef(a, l, po._ChainIkPosition),
                d = E.Vector3.TransformCoordinatesToRef(s, l, po._ChainTargetPosition),
                c = h.normalize(),
                m = d.normalize();
              let u = E.Vector3.Dot(m, c);
              u = Math.max(-1, Math.min(1, u));
              let p = Math.acos(u);
              p = Math.max(-this.limitAngle, Math.min(this.limitAngle, p));
              const g = E.Quaternion.RotationAxisToRef(r, p, po._Rotation2),
                f = m.applyRotationQuaternionToRef(g, po._TargetVector),
                _ = E.Vector3.Dot(f, c),
                b = E.Quaternion.RotationAxisToRef(r, -p, po._Rotation2),
                y = m.applyRotationQuaternionToRef(b, po._TargetVector),
                A = E.Vector3.Dot(y, c);
              let M = t.planeModeAngle;
              if ((_ > A ? (M += p) : (M -= p), 0 === e && (M < i || M > o)))
                if (-M > i && -M < o) M = -M;
                else {
                  const e = 0.5 * (i + o);
                  Math.abs(e - M) > Math.abs(e + M) && (M = -M);
                }
              (M = Math.max(i, Math.min(o, M))), (t.planeModeAngle = M);
              const T = E.Quaternion.InverseToRef(
                t.bone.getAnimatedRotationToRef(po._InversedAnimatedRotation2),
                po._InversedAnimatedRotation2
              );
              E.Quaternion.RotationAxisToRef(r, M, t.bone.ikRotation).multiplyInPlace(T),
                t.bone.updateLocalMatrix(),
                t.bone.updateWorldMatrix();
            }
            static _TwoPi = 2 * Math.PI;
            _normalizeAngle(e) {
              for (; e >= po._TwoPi; ) e -= po._TwoPi;
              for (; e < 0; ) e += po._TwoPi;
              return e;
            }
            _diffAngle(e, t) {
              const n = this._normalizeAngle(e) - this._normalizeAngle(t);
              return n > Math.PI ? n - po._TwoPi : n < -Math.PI ? n + po._TwoPi : n;
            }
            static _Tests = [
              new E.Vector3(),
              new E.Vector3(),
              new E.Vector3(),
              new E.Vector3(),
              new E.Vector3(),
              new E.Vector3(),
              new E.Vector3(),
              new E.Vector3(),
            ];
            _decomposeToRef(e, t, n) {
              const i = n,
                o = -e.m[2];
              if (Math.abs(1 - Math.abs(o)) < 1e-6) {
                i.y = Math.asin(o);
                const n = Math.sin(t.x),
                  r = Math.sin(t.z);
                Math.abs(n) < Math.abs(r)
                  ? Math.cos(t.x) > 0
                    ? ((i.x = 0), (i.z = Math.asin(-e.m[4])))
                    : ((i.x = Math.PI), (i.z = Math.asin(e.m[4])))
                  : Math.cos(t.z) > 0
                  ? ((i.z = 0), (i.x = Math.asin(-e.m[9])))
                  : ((i.z = Math.PI), (i.x = Math.asin(e.m[9])));
              } else
                (i.x = Math.atan2(e.m[6], e.m[10])), (i.y = Math.asin(-e.m[2])), (i.z = Math.atan2(e.m[1], e.m[0]));
              const r = Math.PI,
                a = po._Tests;
              a[0].set(i.x + r, r - i.y, i.z + r),
                a[1].set(i.x + r, r - i.y, i.z - r),
                a[2].set(i.x + r, -r - i.y, i.z + r),
                a[3].set(i.x + r, -r - i.y, i.z - r),
                a[4].set(i.x - r, r - i.y, i.z + r),
                a[5].set(i.x - r, r - i.y, i.z - r),
                a[6].set(i.x - r, -r - i.y, i.z + r),
                a[7].set(i.x - r, -r - i.y, i.z - r);
              let s =
                Math.abs(this._diffAngle(i.x, t.x)) +
                Math.abs(this._diffAngle(i.y, t.y)) +
                Math.abs(this._diffAngle(i.z, t.z));
              for (let e = 0; e < a.length; ++e) {
                const n = a[e],
                  o =
                    Math.abs(this._diffAngle(n.x, t.x)) +
                    Math.abs(this._diffAngle(n.y, t.y)) +
                    Math.abs(this._diffAngle(n.z, t.z));
                o < s && ((s = o), i.copyFrom(n));
              }
              return i;
            }
          }
          class go extends qi {
            setMorphWeight(e, t) {
              const n = this._morphIndexMap.get(e);
              if (void 0 === n) return;
              const i = this._morphWeights;
              for (let e = 0; e < n.length; ++e) i[n[e]] = t;
              0 !== t && this._activeMorphs.add(e);
            }
            setMorphWeightFromIndex(e, t) {
              (this._morphWeights[e] = t), 0 !== t && this._activeMorphs.add(this._morphs[e].name);
            }
            _resetBoneMorph(e) {
              const t = this._runtimeBones,
                n = e.elements;
              for (let e = 0; e < n.length; ++e) {
                const i = t[n[e]];
                void 0 !== i &&
                  (i.morphPositionOffset.set(0, 0, 0), i.morphRotationOffset.set(0, 0, 0, 1), i.disableMorph());
              }
            }
            _tempQuaternion = new E.Quaternion();
            _applyBoneMorph(e, t) {
              const n = this._runtimeBones,
                i = e.elements,
                o = e.elements2,
                r = e.elements3;
              for (let e = 0; e < i.length; ++e) {
                const a = n[i[e]];
                void 0 !== a &&
                  (a.morphPositionOffset.addInPlaceFromFloats(o[3 * e + 0] * t, o[3 * e + 1] * t, o[3 * e + 2] * t),
                  E.Quaternion.SlerpToRef(
                    a.morphRotationOffset,
                    this._tempQuaternion.copyFromFloats(r[4 * e + 0], r[4 * e + 1], r[4 * e + 2], r[4 * e + 3]),
                    t,
                    a.morphRotationOffset
                  ),
                  0 !== t && a.enableMorph());
              }
            }
          }
          class fo {
            linkedBone;
            name;
            parentBone;
            childBones;
            transformOrder;
            flag;
            transformAfterPhysics;
            appendTransformSolver;
            ikSolver;
            morphPositionOffset;
            morphRotationOffset;
            ikRotation;
            localMatrix;
            worldMatrix;
            getAnimatedPositionToRef;
            getAnimatedRotationToRef;
            getAnimationPositionOffsetToRef;
            constructor(e, t, n, i) {
              (this.linkedBone = e),
                (this.name = t.name),
                (this.parentBone = null),
                (this.childBones = []),
                (this.transformOrder = t.transformOrder),
                (this.flag = t.flag),
                (this.transformAfterPhysics = 0 != (t.flag & y.Bone.Flag.TransformAfterPhysics)),
                (this.appendTransformSolver = null),
                (this.ikSolver = null),
                (this.morphPositionOffset = E.Vector3.Zero()),
                (this.morphRotationOffset = E.Quaternion.Identity()),
                (this.ikRotation = null),
                (this.localMatrix = E.Matrix.Identity()),
                (this.worldMatrix = new Float32Array(n.buffer, n.byteOffset + 16 * i * 4, 16)),
                (this.getAnimatedPositionToRef = this._getAnimatedPositionToRef),
                (this.getAnimatedRotationToRef = this._getAnimatedRotationToRef),
                (this.getAnimationPositionOffsetToRef = this._getAnimationPositionOffsetToRef);
            }
            _getAnimatedPositionWithMorphToRef(e) {
              return e.copyFrom(this.linkedBone.position), e.addInPlace(this.morphPositionOffset);
            }
            _getAnimatedPositionToRef(e) {
              return e.copyFrom(this.linkedBone.position), e;
            }
            _getAnimatedRotationToRef(e) {
              return e.copyFrom(this.linkedBone.rotationQuaternion);
            }
            _getAnimatedRotationWithMorphToRef(e) {
              return e.copyFrom(this.linkedBone.rotationQuaternion), e.multiplyInPlace(this.morphRotationOffset);
            }
            static _TempVector3 = new E.Vector3();
            _getAnimationPositionOffsetToRef(e) {
              return (
                e.copyFrom(this.linkedBone.position),
                this.linkedBone.getRestMatrix().getTranslationToRef(fo._TempVector3),
                e.subtractInPlace(fo._TempVector3)
              );
            }
            _getAnimationPositionOffsetWithMorphToRef(e) {
              return (
                e.copyFrom(this.linkedBone.position),
                e.addInPlace(this.morphPositionOffset),
                this.linkedBone.getRestMatrix().getTranslationToRef(fo._TempVector3),
                e.subtractInPlace(fo._TempVector3)
              );
            }
            enableMorph() {
              (this.getAnimatedPositionToRef = this._getAnimatedPositionWithMorphToRef),
                (this.getAnimatedRotationToRef = this._getAnimatedRotationWithMorphToRef),
                (this.getAnimationPositionOffsetToRef = this._getAnimationPositionOffsetWithMorphToRef);
            }
            disableMorph() {
              (this.getAnimatedPositionToRef = this._getAnimatedPositionToRef),
                (this.getAnimatedRotationToRef = this._getAnimatedRotationToRef),
                (this.getAnimationPositionOffsetToRef = this._getAnimationPositionOffsetToRef);
            }
            static _TempRotation = E.Quaternion.Identity();
            static _TempPosition = E.Vector3.Zero();
            updateLocalMatrix() {
              const e = this.getAnimatedRotationToRef(fo._TempRotation);
              null !== this.ikRotation && this.ikRotation.multiplyToRef(e, e);
              const t = this.getAnimatedPositionToRef(fo._TempPosition);
              null !== this.appendTransformSolver &&
                (this.appendTransformSolver.affectRotation &&
                  e.multiplyInPlace(this.appendTransformSolver.appendRotationOffset),
                this.appendTransformSolver.affectPosition &&
                  t.addInPlace(this.appendTransformSolver.appendPositionOffset)),
                E.Matrix.ComposeToRef(this.linkedBone.scaling, e, t, this.localMatrix);
            }
            static _Stack = [];
            static _ParentWorldMatrix = E.Matrix.Identity();
            updateWorldMatrix() {
              const e = fo._Stack;
              (e.length = 0), e.push(this);
              const t = fo._ParentWorldMatrix;
              for (; e.length > 0; ) {
                const n = e.pop(),
                  i = n.parentBone;
                null !== i
                  ? n.localMatrix.multiplyToArray(E.Matrix.FromArrayToRef(i.worldMatrix, 0, t), n.worldMatrix, 0)
                  : n.localMatrix.copyToArray(n.worldMatrix);
                const o = n.childBones;
                for (let t = 0, n = o.length; t < n; ++t) e.push(o[t]);
              }
            }
            getWorldMatrixToRef(e) {
              return E.Matrix.FromArrayToRef(this.worldMatrix, 0, e);
            }
            getWorldTranslationToRef(e) {
              return E.Vector3.FromArrayToRef(this.worldMatrix, 12, e);
            }
            setWorldTranslationFromRef(e) {
              e.toArray(this.worldMatrix, 12);
            }
            get ikSolverIndex() {
              return null !== this.ikSolver ? this.ikSolver.index : -1;
            }
          }
          class _o {
            mesh;
            skeleton;
            worldTransformMatrices;
            ikSolverStates;
            runtimeBones;
            morph;
            _physicsModel;
            _logger;
            _sortedRuntimeBones;
            _sortedRuntimeRootBones;
            onCurrentAnimationChangedObservable;
            _animations;
            _animationIndexMap;
            _currentAnimation;
            _needStateReset;
            constructor(e, t, n, i, o) {
              this._logger = o;
              const r = e.metadata,
                a = e;
              (a.metadata = {
                isRuntimeMmdModel: !0,
                header: r.header,
                meshes: r.meshes,
                materials: r.materials,
                skeleton: r.skeleton,
              }),
                (this.mesh = a),
                (this.skeleton = t);
              const s = (this.worldTransformMatrices = new Float32Array(16 * t.bones.length));
              {
                let e = 0;
                const t = r.bones;
                for (let n = 0; n < t.length; ++n) void 0 !== t[n].ik && (e += 1);
                this.ikSolverStates = new Uint8Array(e).fill(1);
              }
              t.prepare(), this._disableSkeletonWorldMatrixUpdate(t);
              const l = (this.runtimeBones = this._buildRuntimeSkeleton(t.bones, r.bones, s)),
                h = (this._sortedRuntimeBones = [...l]);
              h.sort((e, t) => e.transformOrder - t.transformOrder);
              const d = [];
              for (let e = 0; e < h.length; ++e) {
                const t = h[e];
                null === t.parentBone && d.push(t);
              }
              this._sortedRuntimeRootBones = d;
              const c = [];
              {
                const e = r.meshes;
                for (let t = 0; t < e.length; ++t) {
                  const n = e[t].morphTargetManager;
                  null !== n && c.push(n);
                }
              }
              if (((this.morph = new go(l, r.materials, n, r.morphs, c, o)), null !== i)) {
                for (let e = 0; e < h.length; ++e) h[e].updateLocalMatrix();
                for (let e = 0; e < d.length; ++e) d[e].updateWorldMatrix();
                this._physicsModel = i.buildPhysics(e, l, r.rigidBodies, r.joints, o);
              } else this._physicsModel = null;
              (this.onCurrentAnimationChangedObservable = new U.Observable()),
                (this._animations = []),
                (this._animationIndexMap = new Map()),
                (this._currentAnimation = null),
                (this._needStateReset = !1);
            }
            dispose() {
              this._enableSkeletonWorldMatrixUpdate(),
                this._physicsModel?.dispose(),
                this.onCurrentAnimationChangedObservable.clear();
              const e = this._animations;
              for (let t = 0; t < e.length; ++t) e[t].dispose?.();
              (this._animations.length = 0), this._animationIndexMap.clear(), (this.mesh.metadata = null);
            }
            get sortedRuntimeBones() {
              return this._sortedRuntimeBones;
            }
            addAnimation(e, t) {
              let n;
              if (void 0 === e.createRuntimeModelAnimation)
                throw new Error(
                  'animation is not MmdAnimation or MmdModelAnimationGroup or MmdCompositeAnimation. are you missing import "babylon-mmd/esm/Runtime/Animation/mmdRuntimeModelAnimation" or "babylon-mmd/esm/Runtime/Animation/mmdRuntimeModelAnimationGroup" or "babylon-mmd/esm/Runtime/Animation/mmdCompositeRuntimeModelAnimation"?'
                );
              (n = e.createRuntimeModelAnimation(this, t, this._logger)),
                this._animationIndexMap.set(e.name, this._animations.length),
                this._animations.push(n);
            }
            removeAnimation(e) {
              const t = this._animations[e];
              void 0 !== t &&
                (this._currentAnimation === t &&
                  ((this._currentAnimation = null),
                  this._resetPose(),
                  this.onCurrentAnimationChangedObservable.notifyObservers(null)),
                this._animationIndexMap.delete(t.animation.name),
                this._animations.splice(e, 1),
                t.dispose?.());
            }
            setAnimation(e, t = !0) {
              if (null === e)
                return void (
                  null !== this._currentAnimation &&
                  ((this._currentAnimation = null),
                  this._resetPose(),
                  this.onCurrentAnimationChangedObservable.notifyObservers(null))
                );
              const n = this._animationIndexMap.get(e);
              if (void 0 === n) throw new Error(`Animation '${e}' is not found.`);
              null !== this._currentAnimation && (this._resetPose(), (this._needStateReset = !0));
              const i = (this._currentAnimation = this._animations[n]);
              i.induceMaterialRecompile(t, this._logger), this.onCurrentAnimationChangedObservable.notifyObservers(i);
            }
            get runtimeAnimations() {
              return this._animations;
            }
            get currentAnimation() {
              return this._currentAnimation;
            }
            initializePhysics() {
              this._physicsModel?.initialize();
            }
            beforePhysics(e) {
              null !== e &&
                (this._needStateReset &&
                  ((this._needStateReset = !1), this.morph.resetMorphWeights(), this.ikSolverStates.fill(1)),
                null !== this._currentAnimation && this._currentAnimation.animate(e)),
                this.morph.update(),
                this._update(!1),
                this._physicsModel?.syncBodies();
            }
            afterPhysics() {
              const e = this._physicsModel;
              null !== e && e.syncBones(), this._update(!0), this.mesh.metadata.skeleton._markAsDirty();
            }
            _update(e) {
              const t = this._sortedRuntimeBones;
              for (let n = 0; n < t.length; ++n) {
                const i = t[n];
                i.transformAfterPhysics === e && i.updateLocalMatrix();
              }
              const n = this._sortedRuntimeRootBones;
              for (let t = 0; t < n.length; ++t) {
                const i = n[t];
                i.transformAfterPhysics === e && i.updateWorldMatrix();
              }
              for (let n = 0; n < t.length; ++n) {
                const i = t[n];
                i.transformAfterPhysics === e &&
                  (null !== i.appendTransformSolver &&
                    (i.appendTransformSolver.update(), i.updateLocalMatrix(), i.updateWorldMatrix()),
                  null !== i.ikSolver &&
                    0 !== this.ikSolverStates[i.ikSolver.index] &&
                    (i.ikSolver.solve(), i.updateWorldMatrix()));
              }
              for (let t = 0; t < n.length; ++t) {
                const i = n[t];
                i.transformAfterPhysics === e && i.updateWorldMatrix();
              }
            }
            _buildRuntimeSkeleton(e, t, n) {
              const i = [];
              for (let o = 0; o < t.length; ++o) {
                const r = t[o];
                i.push(new fo(e[o], r, n, o));
              }
              let o = 0;
              for (let e = 0; e < t.length; ++e) {
                const n = t[e],
                  r = i[e],
                  a = n.parentBoneIndex;
                if (0 <= a && a < i.length) {
                  const e = i[a];
                  (r.parentBone = e), e.childBones.push(r);
                }
                if (void 0 !== n.appendTransform) {
                  const e = n.appendTransform.parentIndex;
                  0 <= e && e < i.length
                    ? (r.appendTransformSolver = new mo(n.flag, n.appendTransform, i[e]))
                    : this._logger.error(`Invalid append transform target bone index: ${e}`);
                }
                if (void 0 !== n.ik) {
                  const e = n.ik,
                    t = e.target;
                  if (0 <= t && t < i.length) {
                    const n = (r.ikSolver = new po(o, r, i[t]));
                    (o += 1), (n.iteration = e.iteration), (n.limitAngle = e.rotationConstraint);
                    for (let t = 0; t < e.links.length; ++t) {
                      const o = e.links[t],
                        r = o.target;
                      if (0 <= r && r < i.length) {
                        const e = i[r];
                        n.addIkChain(
                          e,
                          o.limitation?.minimumAngle ? E.Vector3.FromArray(o.limitation.minimumAngle) : null,
                          o.limitation?.maximumAngle ? E.Vector3.FromArray(o.limitation.maximumAngle) : null
                        );
                      } else this._logger.error(`Invalid IK link bone index: ${r}`);
                    }
                  } else this._logger.error(`Invalid IK target bone index: ${t}`);
                }
              }
              return i;
            }
            _originalComputeTransformMatrices = null;
            _disableSkeletonWorldMatrixUpdate(e) {
              if (null !== this._originalComputeTransformMatrices) return;
              this._originalComputeTransformMatrices = e._computeTransformMatrices;
              const t = this.worldTransformMatrices;
              e._computeTransformMatrices = function (e, n) {
                this.onBeforeComputeObservable.notifyObservers(this);
                for (let n = 0; n < this.bones.length; n++) {
                  const i = this.bones[n];
                  if (((i._childUpdateId += 1), -1 !== i._index)) {
                    const o = null === i._index ? n : i._index;
                    i.getAbsoluteInverseBindMatrix().multiplyToArray(
                      E.Matrix.FromArrayToRef(t, 16 * n, i.getFinalMatrix()),
                      e,
                      16 * o
                    );
                  }
                }
                this._identity.copyToArray(e, 16 * this.bones.length);
              };
            }
            _enableSkeletonWorldMatrixUpdate() {
              null !== this._originalComputeTransformMatrices &&
                ((this.skeleton._computeTransformMatrices = this._originalComputeTransformMatrices),
                (this._originalComputeTransformMatrices = null));
            }
            _resetPose() {
              const e = this._sortedRuntimeBones,
                t = new E.Vector3(),
                n = E.Quaternion.Identity();
              for (let i = 0; i < e.length; ++i) {
                const o = e[i].linkedBone;
                o.getRestMatrix().getTranslationToRef(t), (o.position = t), o.setRotationQuaternion(n, ze.Space.LOCAL);
              }
              this.mesh.metadata.skeleton._markAsDirty();
            }
          }
          H(6247);
          var bo = H(4044),
            yo = H(6970),
            Ao = H(3466),
            Mo = H(3301),
            To = H(5755);
          class wo extends bo.TransformNode {
            linkedBone;
            physicsMode;
            bodyOffsetMatrix;
            bodyOffsetInverseMatrix;
            constructor(e, t, n, i, o) {
              super(e, t, o),
                (this.linkedBone = n),
                (this.physicsMode = i),
                (this.bodyOffsetMatrix = E.Matrix.Identity()),
                (this.bodyOffsetInverseMatrix = E.Matrix.Identity());
            }
            static _ParentWorldMatrixInverse = new E.Matrix();
            static _WorldMatrix = new E.Matrix();
            computeBodyOffsetMatrix() {
              const e = this.linkedBone.getWorldMatrixToRef(wo._ParentWorldMatrixInverse).invert();
              E.Matrix.ComposeToRef(
                this.scaling,
                this.rotationQuaternion,
                this.position,
                wo._WorldMatrix
              ).multiplyToRef(e, this.bodyOffsetMatrix),
                this.bodyOffsetMatrix.invertToRef(this.bodyOffsetInverseMatrix);
            }
          }
          class xo {
            _mmdPhysics;
            _nodes;
            _bodies;
            _constraints;
            constructor(e, t, n, i) {
              (this._mmdPhysics = e), (this._nodes = t), (this._bodies = n), (this._constraints = i);
            }
            dispose() {
              const e = this._constraints;
              for (let t = 0; t < e.length; ++t) e[t]?.dispose();
              const t = this._bodies;
              for (let e = 0; e < t.length; ++e) {
                const n = t[e];
                null !== n && (n.shape?.dispose(), n.dispose());
              }
              const n = this._nodes;
              for (let e = 0; e < n.length; ++e) n[e]?.dispose();
            }
            static _NodeWorldMatrix = new E.Matrix();
            static _ZeroVector = E.Vector3.Zero();
            initialize() {
              const e = this._mmdPhysics,
                t = this._nodes;
              for (let n = 0; n < t.length; ++n) {
                const i = t[n];
                if (null === i) continue;
                const o = i.linkedBone.getWorldMatrixToRef(xo._NodeWorldMatrix);
                i.bodyOffsetMatrix.multiplyToRef(o, o), o.decompose(i.scaling, i.rotationQuaternion, i.position);
                const r = i.physicsBody;
                r.setAngularVelocity(xo._ZeroVector),
                  r.setLinearVelocity(xo._ZeroVector),
                  e._enablePreStepOnce(i.physicsBody);
              }
            }
            static _NodeWorldPosition = new E.Vector3();
            static _NodeWorldRotation = new E.Quaternion();
            syncBodies() {
              const e = this._nodes;
              for (let t = 0; t < e.length; ++t) {
                const n = e[t];
                if (null !== n)
                  switch (n.physicsMode) {
                    case y.RigidBody.PhysicsMode.FollowBone:
                      {
                        const e = n.linkedBone.getWorldMatrixToRef(xo._NodeWorldMatrix);
                        n.bodyOffsetMatrix.multiplyToRef(e, e),
                          e.decompose(n.scaling, n.rotationQuaternion, n.position),
                          n.computeWorldMatrix(!0),
                          n.getWorldMatrix().decompose(void 0, xo._NodeWorldRotation, xo._NodeWorldPosition),
                          n.physicsBody.setTargetTransform(xo._NodeWorldPosition, xo._NodeWorldRotation);
                      }
                      break;
                    case y.RigidBody.PhysicsMode.Physics:
                    case y.RigidBody.PhysicsMode.PhysicsWithBone:
                      break;
                    default:
                      throw new Error(`Unknown physics mode: ${n.physicsMode}`);
                  }
              }
            }
            static _BoneWorldPosition = new E.Vector3();
            syncBones() {
              const e = this._nodes;
              for (let t = 0; t < e.length; ++t) {
                const n = e[t];
                if (null !== n)
                  switch (n.physicsMode) {
                    case y.RigidBody.PhysicsMode.FollowBone:
                      break;
                    case y.RigidBody.PhysicsMode.Physics:
                      {
                        n.bodyOffsetInverseMatrix.multiplyToArray(
                          E.Matrix.ComposeToRef(n.scaling, n.rotationQuaternion, n.position, xo._NodeWorldMatrix),
                          n.linkedBone.worldMatrix,
                          0
                        );
                        const e = n.linkedBone.childBones;
                        for (let t = 0; t < e.length; ++t) e[t].updateWorldMatrix();
                      }
                      break;
                    case y.RigidBody.PhysicsMode.PhysicsWithBone:
                      {
                        n.linkedBone.getWorldTranslationToRef(xo._BoneWorldPosition),
                          n.bodyOffsetInverseMatrix.multiplyToArray(
                            E.Matrix.ComposeToRef(n.scaling, n.rotationQuaternion, xo._ZeroVector, xo._NodeWorldMatrix),
                            n.linkedBone.worldMatrix,
                            0
                          ),
                          n.linkedBone.setWorldTranslationFromRef(xo._BoneWorldPosition);
                        const e = n.linkedBone.childBones;
                        for (let t = 0; t < e.length; ++t) e[t].updateWorldMatrix();
                      }
                      break;
                    default:
                      throw new Error(`Unknown physics mode: ${n.physicsMode}`);
                  }
              }
            }
          }
          class Io {
            angularLimitClampThreshold;
            _scene;
            _enablePreStepOnces = [];
            constructor(e) {
              (this.angularLimitClampThreshold = (5 * Math.PI) / 180), (this._scene = e);
            }
            _convertParameter(e) {
              const t = 1 / 60;
              return (1 - (1 - e) ** t) / t;
            }
            _clampAngularLimit(e) {
              return Math.abs(e) < this.angularLimitClampThreshold ? 0 : e;
            }
            buildPhysics(e, t, n, i, o) {
              const r = this._scene,
                a = r.getPhysicsEngine()?.getPhysicsPlugin();
              if (!a) throw new Error("Physics engine is not enabled");
              if ("HavokPlugin" !== a.name) throw new Error("Physics plugin is not HavokPlugin");
              let s;
              {
                e.computeWorldMatrix(!0);
                const t = e.getWorldMatrix(),
                  n = new E.Vector3();
                t.decompose(n),
                  Math.abs(n.x - n.y) < 1e-4 && Math.abs(n.y - n.z) < 1e-4
                    ? Math.abs(n.x - 1) < 1e-4 && Math.abs(n.y - 1) < 1e-4 && Math.abs(n.z - 1) < 1e-4
                      ? (s = 1)
                      : ((s = n.x), o.warn("Root node scaling is not 1, simulation may differ from the original"))
                    : ((s = Math.max(n.x, n.y, n.z)),
                      o.warn("Root node scaling is not uniform, physics may not work correctly"));
              }
              const l = new Array(n.length),
                h = new Array(n.length),
                d = new Array(i.length);
              for (let i = 0; i < n.length; ++i) {
                const d = n[i];
                if (d.boneIndex < 0 || t.length <= d.boneIndex) {
                  o.warn(`Bone index out of range failed to create rigid body: ${d.name}`),
                    (l[i] = null),
                    (h[i] = null);
                  continue;
                }
                const c = t[d.boneIndex];
                let m,
                  u = !1;
                switch (d.shapeType) {
                  case y.RigidBody.ShapeType.Sphere:
                    (m = new To.PhysicsShapeSphere(new E.Vector3(), d.shapeSize[0] * s, r)),
                      0 === d.shapeSize[0] && (u = !0);
                    break;
                  case y.RigidBody.ShapeType.Box:
                    (m = new To.PhysicsShapeBox(
                      new E.Vector3(),
                      new E.Quaternion(),
                      new E.Vector3(2 * d.shapeSize[0] * s, 2 * d.shapeSize[1] * s, 2 * d.shapeSize[2] * s),
                      r
                    )),
                      (0 !== d.shapeSize[0] && 0 !== d.shapeSize[1] && 0 !== d.shapeSize[2]) || (u = !0);
                    break;
                  case y.RigidBody.ShapeType.Capsule:
                    (m = new To.PhysicsShapeCapsule(
                      new E.Vector3(0, (d.shapeSize[1] / 2) * s, 0),
                      new E.Vector3(0, (-d.shapeSize[1] / 2) * s, 0),
                      d.shapeSize[0] * s,
                      r
                    )),
                      (0 !== d.shapeSize[0] && 0 !== d.shapeSize[1]) || (u = !0);
                    break;
                  default:
                    o.warn(`Unknown rigid body shape type: ${d.shapeType}`), (l[i] = null), (h[i] = null);
                    continue;
                }
                (m.material = { friction: d.friction, restitution: d.repulsion }),
                  (m.filterCollideMask = u ? 0 : d.collisionMask),
                  (m.filterMembershipMask = 1 << d.collisionGroup);
                const p = new wo(d.name, r, c, d.physicsMode),
                  g = d.shapePosition;
                p.position.copyFromFloats(g[0], g[1], g[2]);
                const f = d.shapeRotation;
                (p.rotationQuaternion = E.Quaternion.FromEulerAngles(f[0], f[1], f[2])),
                  p.computeBodyOffsetMatrix(),
                  p.setParent(e);
                const _ =
                    d.physicsMode === y.RigidBody.PhysicsMode.FollowBone
                      ? yo.PhysicsMotionType.ANIMATED
                      : yo.PhysicsMotionType.DYNAMIC,
                  b = new Ao.PhysicsBody(p, _, !1, r);
                a.setActivationControl(b, yo.PhysicsActivationControl.ALWAYS_ACTIVE),
                  (b.shape = m),
                  b.setMassProperties({ mass: d.mass }),
                  b.setLinearDamping(this._convertParameter(d.linearDamping)),
                  b.setAngularDamping(this._convertParameter(d.angularDamping)),
                  b.computeMassProperties(),
                  (l[i] = p),
                  (h[i] = b);
              }
              const c = E.Vector3.One(),
                m = new E.Quaternion(),
                u = new E.Vector3(),
                p = new E.Matrix(),
                g = new E.Quaternion(),
                f = new E.Vector3(),
                _ = new E.Matrix(),
                b = new E.Matrix(),
                A = new E.Matrix(),
                M = new E.Matrix();
              for (let e = 0; e < i.length; ++e) {
                const a = i[e];
                if (a.rigidbodyIndexA < 0 || n.length <= a.rigidbodyIndexA) {
                  o.warn(`Rigid body index out of range failed to create joint: ${a.name}`), (d[e] = null);
                  continue;
                }
                if (a.rigidbodyIndexB < 0 || n.length <= a.rigidbodyIndexB) {
                  o.warn(`Rigid body index out of range failed to create joint: ${a.name}`), (d[e] = null);
                  continue;
                }
                const T = h[a.rigidbodyIndexA],
                  w = h[a.rigidbodyIndexB];
                if (null === T || null === w) {
                  o.warn(`Rigid body not found failed to create joint: ${a.name}`), (d[e] = null);
                  continue;
                }
                E.Matrix.ComposeToRef(
                  c,
                  E.Quaternion.FromEulerAnglesToRef(a.rotation[0], a.rotation[1], a.rotation[2], m),
                  u.copyFromFloats(a.position[0] * s, a.position[1] * s, a.position[2] * s),
                  p
                );
                const x = n[a.rigidbodyIndexA],
                  I = n[a.rigidbodyIndexB];
                {
                  const e = x.shapeRotation,
                    t = x.shapePosition;
                  E.Matrix.ComposeToRef(
                    c,
                    E.Quaternion.FromEulerAnglesToRef(e[0], e[1], e[2], g),
                    f.copyFromFloats(t[0] * s, t[1] * s, t[2] * s),
                    _
                  ).invert();
                }
                {
                  const e = I.shapeRotation,
                    t = I.shapePosition;
                  E.Matrix.ComposeToRef(
                    c,
                    E.Quaternion.FromEulerAnglesToRef(e[0], e[1], e[2], g),
                    f.copyFromFloats(t[0] * s, t[1] * s, t[2] * s),
                    b
                  ).invert();
                }
                p.multiplyToRef(_, A), p.multiplyToRef(b, M);
                const v = this._convertParameter(1),
                  B = [
                    {
                      axis: yo.PhysicsConstraintAxis.LINEAR_X,
                      minLimit: a.positionMin[0],
                      maxLimit: a.positionMax[0],
                      stiffness: this._convertParameter(a.springPosition[0]),
                      damping: v,
                    },
                    {
                      axis: yo.PhysicsConstraintAxis.LINEAR_Y,
                      minLimit: a.positionMin[1],
                      maxLimit: a.positionMax[1],
                      stiffness: this._convertParameter(a.springPosition[1]),
                      damping: v,
                    },
                    {
                      axis: yo.PhysicsConstraintAxis.LINEAR_Z,
                      minLimit: a.positionMin[2],
                      maxLimit: a.positionMax[2],
                      stiffness: this._convertParameter(a.springPosition[2]),
                      damping: v,
                    },
                    {
                      axis: yo.PhysicsConstraintAxis.ANGULAR_X,
                      minLimit: this._clampAngularLimit(a.rotationMin[0]),
                      maxLimit: this._clampAngularLimit(a.rotationMax[0]),
                      stiffness: this._convertParameter(a.springRotation[0]),
                      damping: v,
                    },
                    {
                      axis: yo.PhysicsConstraintAxis.ANGULAR_Y,
                      minLimit: this._clampAngularLimit(a.rotationMin[1]),
                      maxLimit: this._clampAngularLimit(a.rotationMax[1]),
                      stiffness: this._convertParameter(a.springRotation[1]),
                      damping: v,
                    },
                    {
                      axis: yo.PhysicsConstraintAxis.ANGULAR_Z,
                      minLimit: this._clampAngularLimit(a.rotationMin[2]),
                      maxLimit: this._clampAngularLimit(a.rotationMax[2]),
                      stiffness: this._convertParameter(a.springRotation[2]),
                      damping: v,
                    },
                  ];
                for (let e = 0; e < B.length; ++e) {
                  const t = B[e];
                  0 === t.stiffness && ((t.stiffness = void 0), (t.damping = void 0));
                }
                const P = new Mo.Physics6DoFConstraint(
                  {
                    pivotA: A.getTranslation(),
                    pivotB: M.getTranslation(),
                    axisA: new E.Vector3(A.m[0], A.m[1], A.m[2]).negateInPlace(),
                    axisB: new E.Vector3(M.m[0], M.m[1], M.m[2]).negateInPlace(),
                    perpAxisA: new E.Vector3(A.m[4], A.m[5], A.m[6]),
                    perpAxisB: new E.Vector3(M.m[4], M.m[5], M.m[6]),
                    collision: !0,
                  },
                  B,
                  r
                );
                T.addConstraint(w, P), (d[e] = P);
                const O = l[a.rigidbodyIndexA],
                  F = l[a.rigidbodyIndexB];
                O.physicsMode !== y.RigidBody.PhysicsMode.FollowBone &&
                F.physicsMode === y.RigidBody.PhysicsMode.PhysicsWithBone
                  ? t[I.boneIndex].parentBone === t[x.boneIndex] && (F.physicsMode = y.RigidBody.PhysicsMode.Physics)
                  : F.physicsMode !== y.RigidBody.PhysicsMode.FollowBone &&
                    O.physicsMode === y.RigidBody.PhysicsMode.PhysicsWithBone &&
                    t[x.boneIndex].parentBone === t[I.boneIndex] &&
                    (O.physicsMode = y.RigidBody.PhysicsMode.Physics);
              }
              return new xo(this, l, h, d);
            }
            _onAfterPhysics = () => {
              const e = this._enablePreStepOnces;
              for (let t = 0; t < e.length; ++t) e[t].disablePreStep = !0;
              e.length = 0;
            };
            _enablePreStepOnce(e) {
              e.disablePreStep &&
                (0 === this._enablePreStepOnces.length &&
                  this._scene.onAfterPhysicsObservable.addOnce(this._onAfterPhysics),
                this._enablePreStepOnces.push(e),
                (e.disablePreStep = !1));
            }
          }
          class vo {
            _physics;
            _models;
            _camera;
            _audioPlayer;
            _loggingEnabled;
            log;
            warn;
            error;
            _isRegistered;
            onAnimationDurationChangedObservable;
            onPlayAnimationObservable;
            onPauseAnimationObservable;
            onSeekAnimationObservable;
            onAnimationTickObservable;
            _currentFrameTime;
            _animationTimeScale;
            _animationPaused;
            _animationFrameTimeDuration;
            _useManualAnimationDuration;
            _needToInitializePhysicsModels;
            _beforePhysicsBinded;
            _afterPhysicsBinded;
            _bindedDispose;
            _disposeObservableObject;
            constructor(e = null, t = null) {
              (this._physics = t),
                (this._models = []),
                (this._camera = null),
                (this._audioPlayer = null),
                (this._loggingEnabled = !1),
                (this.log = this._logDisabled),
                (this.warn = this._warnDisabled),
                (this.error = this._errorDisabled),
                (this._isRegistered = !1),
                (this.onAnimationDurationChangedObservable = new U.Observable()),
                (this.onPlayAnimationObservable = new U.Observable()),
                (this.onPauseAnimationObservable = new U.Observable()),
                (this.onSeekAnimationObservable = new U.Observable()),
                (this.onAnimationTickObservable = new U.Observable()),
                (this._currentFrameTime = 0),
                (this._animationTimeScale = 1),
                (this._animationPaused = !0),
                (this._animationFrameTimeDuration = 0),
                (this._useManualAnimationDuration = !1),
                (this._needToInitializePhysicsModels = new Set()),
                (this._beforePhysicsBinded = null),
                (this._afterPhysicsBinded = this.afterPhysics.bind(this)),
                null !== e
                  ? ((this._bindedDispose = () => this.dispose(e)),
                    (this._disposeObservableObject = e),
                    null !== this._disposeObservableObject &&
                      this._disposeObservableObject.onDisposeObservable.add(this._bindedDispose))
                  : ((this._bindedDispose = null), (this._disposeObservableObject = null));
            }
            dispose(e) {
              for (let e = 0; e < this._models.length; ++e) this._models[e].dispose();
              (this._models.length = 0),
                this.setCamera(null),
                this.setAudioPlayer(null),
                this.onAnimationDurationChangedObservable.clear(),
                this.onPlayAnimationObservable.clear(),
                this.onPauseAnimationObservable.clear(),
                this.onSeekAnimationObservable.clear(),
                this.onAnimationTickObservable.clear(),
                this._needToInitializePhysicsModels.clear(),
                this.unregister(e),
                null !== this._disposeObservableObject &&
                  null !== this._bindedDispose &&
                  this._disposeObservableObject.onDisposeObservable.removeCallback(this._bindedDispose);
            }
            createMmdModel(e, t = {}) {
              if (!gt.isMmdSkinnedMesh(e)) throw new Error("Mesh validation failed.");
              return this.createMmdModelFromSkeleton(e, e.metadata.skeleton, t);
            }
            createMmdModelFromSkeleton(e, t, n = {}) {
              void 0 === n.materialProxyConstructor && (n.materialProxyConstructor = Gi),
                void 0 === n.buildPhysics && (n.buildPhysics = !0);
              const i = new _o(e, t, n.materialProxyConstructor, n.buildPhysics ? this._physics : null, this);
              return (
                this._models.push(i),
                this._needToInitializePhysicsModels.add(i),
                i.onCurrentAnimationChangedObservable.add(this._onAnimationChanged),
                i
              );
            }
            destroyMmdModel(e) {
              e.dispose();
              const t = this._models,
                n = t.indexOf(e);
              if (n < 0) throw new Error("Model not found.");
              t.splice(n, 1);
            }
            setCamera(e) {
              null !== this._camera &&
                this._camera.onCurrentAnimationChangedObservable.removeCallback(this._onAnimationChanged),
                null !== e && e.onCurrentAnimationChangedObservable.add(this._onAnimationChanged),
                (this._camera = e),
                this._onAnimationChanged(e?.currentAnimation ?? null);
            }
            _setAudioPlayerLastValue = null;
            async setAudioPlayer(e) {
              if (
                this._audioPlayer !== e &&
                ((this._setAudioPlayerLastValue = e),
                null !== this._audioPlayer &&
                  (this._audioPlayer.onDurationChangedObservable.removeCallback(this._onAudioDurationChanged),
                  this._audioPlayer.onPlaybackRateChangedObservable.removeCallback(this._onAudioPlaybackRateChanged),
                  this._audioPlayer.onPlayObservable.removeCallback(this._onAudioPlay),
                  this._audioPlayer.onPauseObservable.removeCallback(this._onAudioPause),
                  this._audioPlayer.onSeekObservable.removeCallback(this._onAudioSeek),
                  this._audioPlayer.pause()),
                (this._audioPlayer = null),
                null !== e)
              ) {
                if (!this._animationPaused) {
                  const t = 30 * e.duration;
                  if (
                    this._currentFrameTime < t &&
                    ((e.currentTime = this._currentFrameTime / 30), await e.play(), this._setAudioPlayerLastValue !== e)
                  )
                    return void e.pause();
                }
                (this._audioPlayer = e),
                  this._onAudioDurationChanged(),
                  e.onDurationChangedObservable.add(this._onAudioDurationChanged),
                  e.onPlaybackRateChangedObservable.add(this._onAudioPlaybackRateChanged),
                  e.onPlayObservable.add(this._onAudioPlay),
                  e.onPauseObservable.add(this._onAudioPause),
                  e.onSeekObservable.add(this._onAudioSeek),
                  e._setPlaybackRateWithoutNotify(this._animationTimeScale);
              }
            }
            register(e) {
              this._isRegistered ||
                ((this._isRegistered = !0),
                (this._beforePhysicsBinded = () => this.beforePhysics(e.getEngine().getDeltaTime())),
                e.onBeforeAnimationsObservable.add(this._beforePhysicsBinded),
                e.onBeforeRenderObservable.add(this._afterPhysicsBinded));
            }
            unregister(e) {
              this._isRegistered &&
                ((this._isRegistered = !1),
                e.onBeforeAnimationsObservable.removeCallback(this._beforePhysicsBinded),
                e.onBeforeRenderObservable.removeCallback(this._afterPhysicsBinded),
                (this._beforePhysicsBinded = null));
            }
            beforePhysics(e) {
              if (this._animationPaused) {
                const e = this._models;
                for (let t = 0; t < e.length; ++t) e[t].beforePhysics(null);
              } else {
                if (null === this._audioPlayer || this._audioPlayer.paused)
                  this._currentFrameTime += (e / 1e3) * 30 * this._animationTimeScale;
                else {
                  const t = this._audioPlayer.currentTime,
                    n = t - this._currentFrameTime / 30,
                    i = Math.abs(n);
                  if (i < 0.05) this._currentFrameTime += (e / 1e3) * 30 * this._animationTimeScale;
                  else if (i < 0.5)
                    this._currentFrameTime +=
                      n < 0
                        ? (e / 1e3) * 30 * this._animationTimeScale * 0.9
                        : (e / 1e3) * 30 * this._animationTimeScale * 1.1;
                  else {
                    if (60 < Math.abs(t - this._currentFrameTime)) {
                      const e = this._needToInitializePhysicsModels;
                      for (let t = 0; t < this._models.length; ++t) {
                        const n = this._models[t];
                        null !== n.currentAnimation && e.add(n);
                      }
                    }
                    this._currentFrameTime = 30 * t;
                  }
                }
                const t = this._currentFrameTime;
                this._animationFrameTimeDuration <= t &&
                  ((this._animationPaused = !0),
                  (this._currentFrameTime = this._animationFrameTimeDuration),
                  null === this._audioPlayer || this._audioPlayer.paused
                    ? this.onPauseAnimationObservable.notifyObservers()
                    : this._audioPlayer.pause());
                const n = this._models;
                for (let e = 0; e < n.length; ++e) n[e].beforePhysics(t);
                null !== this._camera && this._camera.animate(t), this.onAnimationTickObservable.notifyObservers();
              }
              const t = this._needToInitializePhysicsModels;
              for (const e of t) e.initializePhysics();
              t.clear();
            }
            afterPhysics() {
              const e = this._models;
              for (let t = 0; t < e.length; ++t) e[t].afterPhysics();
            }
            _onAnimationChanged = (e) => {
              if (this._useManualAnimationDuration) return;
              const t = e?.animation.endFrame ?? 0;
              this._animationFrameTimeDuration < t
                ? (this._animationFrameTimeDuration = t)
                : t < this._animationFrameTimeDuration &&
                  (this._animationFrameTimeDuration = this._computeAnimationDuration()),
                this.onAnimationDurationChangedObservable.notifyObservers();
            };
            _computeAnimationDuration() {
              let e = 0;
              const t = this._models;
              for (let n = 0; n < t.length; ++n) {
                const i = t[n];
                null !== i.currentAnimation && (e = Math.max(e, i.currentAnimation.animation.endFrame));
              }
              return (
                null !== this._camera &&
                  null !== this._camera.currentAnimation &&
                  (e = Math.max(e, this._camera.currentAnimation.animation.endFrame)),
                null !== this._audioPlayer && (e = Math.max(e, 30 * this._audioPlayer.duration)),
                e
              );
            }
            _onAudioDurationChanged = () => {
              if (!this._animationPaused) {
                const e = this._audioPlayer,
                  t = this._currentFrameTime / 30;
                t < e.duration &&
                  (e._setCurrentTimeWithoutNotify(t),
                  e.play().then(() => {
                    this._setAudioPlayerLastValue === e || e.pause();
                  }));
              }
              if (this._useManualAnimationDuration) return;
              const e = 30 * this._audioPlayer.duration;
              this._animationFrameTimeDuration < e
                ? (this._animationFrameTimeDuration = e)
                : (this._animationFrameTimeDuration = this._computeAnimationDuration()),
                this.onAnimationDurationChangedObservable.notifyObservers();
            };
            _onAudioPlaybackRateChanged = () => {
              this._animationTimeScale = this._audioPlayer.playbackRate;
            };
            _onAudioPlay = () => {
              this._playAnimationInternal();
            };
            _onAudioPause = () => {
              this._audioPlayer.currentTime !== this._audioPlayer.duration &&
                ((this._animationPaused = !0), this.onPauseAnimationObservable.notifyObservers());
            };
            _onAudioSeek = () => {
              this._seekAnimationInternal(30 * this._audioPlayer.currentTime, this._animationPaused);
            };
            _playAnimationInternal() {
              if (this._animationPaused) {
                if (((this._animationPaused = !1), 0 === this._currentFrameTime)) {
                  const e = this._models,
                    t = this._needToInitializePhysicsModels;
                  for (let n = 0; n < e.length; ++n) t.add(e[n]);
                }
                this.onPlayAnimationObservable.notifyObservers();
              }
            }
            async playAnimation() {
              if (null !== this._audioPlayer && this._currentFrameTime < 30 * this._audioPlayer.duration)
                try {
                  const e = this._currentFrameTime / 30;
                  0.05 < Math.abs(this._audioPlayer.currentTime - e) &&
                    this._audioPlayer._setCurrentTimeWithoutNotify(e),
                    await this._audioPlayer.play();
                } catch (e) {
                  if (!(e instanceof DOMException && "NotSupportedError" === e.name)) throw e;
                  this.error("Failed to play audio."), this._playAnimationInternal();
                }
              else this._playAnimationInternal();
            }
            pauseAnimation() {
              null === this._audioPlayer || this._audioPlayer.paused
                ? ((this._animationPaused = !0), this.onPauseAnimationObservable.notifyObservers())
                : (this._audioPlayer.pause(), (this._animationPaused = !0));
            }
            _seekAnimationInternal(e, t) {
              if (60 < Math.abs(e - this._currentFrameTime)) {
                const e = this._needToInitializePhysicsModels;
                for (let t = 0; t < this._models.length; ++t) {
                  const n = this._models[t];
                  null !== n.currentAnimation && e.add(n);
                }
              }
              if (((this._currentFrameTime = e), t)) {
                const t = this._models;
                for (let n = 0; n < t.length; ++n) {
                  const i = t[n];
                  null !== i.currentAnimation && i.currentAnimation.animate(e);
                }
                null !== this._camera && null !== this._camera.currentAnimation && this._camera.animate(e),
                  this.onAnimationTickObservable.notifyObservers();
              }
              this.onSeekAnimationObservable.notifyObservers();
            }
            async seekAnimation(e, t = !1) {
              if (((e = Math.max(0, Math.min(e, this._animationFrameTimeDuration))), null !== this._audioPlayer))
                if (this._audioPlayer.paused)
                  if (
                    !this._animationPaused &&
                    30 * this._audioPlayer.currentTime < this._animationFrameTimeDuration &&
                    e < 30 * this._audioPlayer.duration
                  )
                    try {
                      this._audioPlayer._setCurrentTimeWithoutNotify(e / 30), await this._audioPlayer.play();
                    } catch (n) {
                      if (!(n instanceof DOMException && "NotSupportedError" === n.name)) throw n;
                      this.error("Failed to play audio."), this._seekAnimationInternal(e, t);
                    }
                  else this._seekAnimationInternal(e, t), this._audioPlayer?._setCurrentTimeWithoutNotify(e / 30);
                else this._audioPlayer.currentTime = e / 30;
              else this._seekAnimationInternal(e, t);
            }
            get isAnimationPlaying() {
              return !this._animationPaused;
            }
            get models() {
              return this._models;
            }
            get camera() {
              return this._camera;
            }
            get audioPlayer() {
              return this._audioPlayer;
            }
            get timeScale() {
              return this._animationTimeScale;
            }
            set timeScale(e) {
              (this._animationTimeScale = e),
                null !== this._audioPlayer && this._audioPlayer._setPlaybackRateWithoutNotify(e);
            }
            get currentFrameTime() {
              return this._currentFrameTime;
            }
            get currentTime() {
              return this._currentFrameTime / 30;
            }
            get animationFrameTimeDuration() {
              return this._animationFrameTimeDuration;
            }
            get animationDuration() {
              return this._animationFrameTimeDuration / 30;
            }
            setManualAnimationDuration(e) {
              (null !== e || this._useManualAnimationDuration) &&
                (null === e
                  ? ((this._useManualAnimationDuration = !1),
                    (this._animationFrameTimeDuration = this._computeAnimationDuration()))
                  : ((this._useManualAnimationDuration = !0), (this._animationFrameTimeDuration = e)),
                this.onAnimationDurationChangedObservable.notifyObservers());
            }
            get loggingEnabled() {
              return this._loggingEnabled;
            }
            set loggingEnabled(e) {
              (this._loggingEnabled = e),
                e
                  ? ((this.log = this._logEnabled), (this.warn = this._warnEnabled), (this.error = this._errorEnabled))
                  : ((this.log = this._logDisabled),
                    (this.warn = this._warnDisabled),
                    (this.error = this._errorDisabled));
            }
            _logEnabled(e) {
              k.Logger.Log(e);
            }
            _logDisabled() {}
            _warnEnabled(e) {
              k.Logger.Warn(e);
            }
            _warnDisabled() {}
            _errorEnabled(e) {
              k.Logger.Error(e);
            }
            _errorDisabled() {}
          }
        })(),
        G
      );
    })()
);
